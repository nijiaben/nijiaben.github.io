<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[你假笨]]></title>
  <link href="http://nijiaben.github.io/atom.xml" rel="self"/>
  <link href="http://nijiaben.github.io/"/>
  <updated>2014-07-15T01:30:41+08:00</updated>
  <id>http://nijiaben.github.io/</id>
  <author>
    <name><![CDATA[你假笨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从tcp原理角度理解Broken pipe和Connection reset by peer的区别]]></title>
    <link href="http://nijiaben.github.io/blog/2014/07/14/tcp-broken-pipe/"/>
    <updated>2014-07-14T19:31:28+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/07/14/tcp-broken-pipe</id>
    <content type="html"><![CDATA[<p>以前我们经常会碰到<code>Broken pipe</code>或者<code>Connection reset by peer</code>之类的异常，但是tcp实现里什么情况下会抛出这些异常呢，以前我给对方的回答都是模棱两可的，自己说实话都没把握，因为自己也没有验证过，对它们的认识都是从网上看来的，正确与否也不知道，昨天独明突然又问到这个问题，前段时间正好对tcp这块研究了一段时间，有了点理论知识之后再从实践角度对此问题进行一下分析，下面对我这次的调研过程进行下描述与大家分享，希望大家以后对此类问题都能很自信地应答。</p>

<h3>三次握手和四次挥手过程</h3>

<p>在讲具体的原因之前，我们有必要补充下tcp这块的一些基础知识，我们都知道tcp通信有三次握手和四次挥手，网上介绍的文章也一大堆，图我也懒得画了，直接网上找一个图给大家</p>

<!--more-->


<p><img src="http://nijiaben.github.io/images/2014/07/tcp_hank.jpg"></p>

<p>三次握手是最前面的三条线表示的过程，四次挥手是最后面的四条线表示的过程，里面涉及到几个关键词，SYN，ACK，FIN，MSS，其中SYN是主要用在三次握手过程中的，FIN用在四次挥手过程中，ACK在三次握手和四次挥手过程中的作用就是对收到的SYN和FIN做一个确认，SYN，FIN等存在于TCP头里(tcp报文图也给大家弄了个图，不用再去找啦)，0/1表示有无此标记，在tcp实现里后面还会跟一个依次递增的数字，比如上面的J，K等，确认就是递增这些数字(真正的数据报文的ack除外)，MSS是表示每一个tcp报文里数据字段的最大长度，不包括tcp头的大小噢
相信大家看到这两个图会对这些概念有了一个清晰的认识了</p>

<p><img src="http://nijiaben.github.io/images/2014/07/tcp_header.jpg"></p>

<h3>tcpdump抓包工具</h3>

<p>介绍了基础原理之后，再介绍下抓包工具，tcpdump，这工具对你了解tcp的整个过程会非常有帮助，在你无法调试tcp实现的情况下这个工具自然也是必不可少的，具体用法网上有很多介绍，直接从man page上也可以看到详细的介绍，我也不多说啦，下面的截图就是tcpdump根据tcp通信过程获取到的</p>

<p><img src="http://nijiaben.github.io/images/2014/07/tcpdump_1.jpg"></p>

<p>这要稍微提下tcpdump的结果和上面的几个过程的对应关系
前面三条其实就是我们上面所说的三次握手，四次握手过程上面没有完全表现出来，只完成了一半的挥手过程（5，8两条表示的）
里面有几个标识S，F，ack，P，其实还有个R，如果有这些标识那么在tcp头里的SYN，FIN，ACK，PSH，RET分别为1，其中PSH表示要求tcp立即将数据传递给上层，不要做别的什么处理，RET这个表示重置连接，也是和我们今天讨论的问题有很大关系的FLAG，下面会详细介绍</p>

<h3>reset报文发送场景</h3>

<p>RST的标志位，这个标识为在如下几种情况下会被设置，以下是我了解的情况，可能还有更多的场景，没有验证</p>

<ul>
<li>当尝试和未开放的服务器端口建立tcp连接时，服务器tcp将会直接向客户端发送reset报文</li>
<li>双方之前已经正常建立了通信通道，也可能进行过了交互，当某一方在交互的过程中发生了异常，如崩溃等，异常的一方会向对端发送reset报文，通知对方将连接关闭</li>
<li>当收到TCP报文，但是发现该报文不是已建立的TCP连接列表可处理的，则其直接向对端发送reset报文</li>
<li>ack报文丢失，并且超出一定的重传次数或时间后，会主动向对端发送reset报文释放该TCP连接</li>
</ul>


<h3>Broken pipe以及Connection reset by peer</h3>

<p>做了这么些铺垫之后下面进入正题，那么<code>Broken pipe</code>或者<code>Connection reset by peer</code>分别代表什么意思呢，下面从glibc的源码里有对此的介绍</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#. TRANS Broken pipe; there is no process reading from the other end of a pipe.
</span><span class='line'>#. TRANS Every library function that returns this error code also generates a
</span><span class='line'>#. TRANS @code{SIGPIPE} signal; this signal terminates the program if not handled
</span><span class='line'>#. TRANS or blocked.  Thus, your program will never actually see @code{EPIPE}
</span><span class='line'>#. TRANS unless it has handled or blocked @code{SIGPIPE}.
</span><span class='line'>#: sysdeps/generic/siglist.h:39 sysdeps/gnu/errlist.c:359
</span><span class='line'>#: sysdeps/unix/siglist.c:39
</span><span class='line'>msgid "Broken pipe"
</span><span class='line'>msgstr "断开的管道"
</span><span class='line'>
</span><span class='line'>#. TRANS A network connection was closed for reasons outside the control of the
</span><span class='line'>#. TRANS local host, such as by the remote machine rebooting or an unrecoverable
</span><span class='line'>#. TRANS protocol violation.
</span><span class='line'>#: sysdeps/gnu/errlist.c:614
</span><span class='line'>msgid "Connection reset by peer"
</span><span class='line'>msgstr ""
</span></code></pre></td></tr></table></div></figure>


<p>其实我们java异常里看到的<code>Broken pipe</code>或者<code>Connection reset by peer</code>信息不是jdk或者jvm里定义的，我看到这些关键字往往会首先搜索下jdk或者hotspot源码找到位置进行上下文分析，但是这次没找到，后面才想到应该是linux或者glibc里定义的，果然在glibc离看到了如上的描述和定义</p>

<p>对于<code>Broken pipe</code>在管道的另外一端没有进程再读的时候就会抛出此异常，<code>Connection reset by peer</code>的描述其实不是很正确，从我的实践来看只描述了一方面，其实在某一端正常close之后，也是可能会有此异常的。</p>

<h3>异常模拟</h3>

<p>从我的测试场景是这样的，
共同的前提是客户端向服务端发了数据之后立马调用close关闭socket并进程退出，而服务端在收到客户端的数据之后sleep一会，保证对方的socket已经关闭，接着分别进行两种场景测试</p>

<ol>
<li><p>服务端往socket里写一次数据，返回继续做select</p></li>
<li><p>服务端连续写两次数据，必须保证两次的buffer都是有数据的，也就是保证ByteBuffer的pos和limit要不是一个值</p></li>
</ol>


<p>结果：</p>

<ol>
<li><p>会抛出Connection reset by peer
<img src="http://nijiaben.github.io/images/2014/07/tcp_error_1.jpg"></p></li>
<li><p>会抛出Broken pipe
<img src="http://nijiaben.github.io/images/2014/07/tcp_error_2.jpg"></p></li>
</ol>


<p>分析：</p>

<ol>
<li><p>当我们往一个对端已经close的通道写数据的时候，对方的tcp会收到这个报文，并且反馈一个reset报文，tcpdump的结果如下所示,当收到reset报文的时候，继续做select读数据的时候就会抛出<code>Connect reset by peer</code>的异常，从堆栈可以看得出
<img src="http://nijiaben.github.io/images/2014/07/tcpdump_2.jpg"></p></li>
<li><p>当第一次往一个对端已经close的通道写数据的时候会和上面的情况一样，会收到reset报文，当再次往这个socket写数据的时候，就会抛出<code>Broken pipe</code>了
，根据tcp的约定，当收到reset包的时候，上层必须要做出处理，调用将socket文件描述符进行关闭，其实也意味着pipe会关闭，因此会抛出这个顾名思义的异常</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM Attach机制实现]]></title>
    <link href="http://nijiaben.github.io/blog/2014/07/14/jvm-attach/"/>
    <updated>2014-07-14T19:15:52+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/07/14/jvm-attach</id>
    <content type="html"><![CDATA[<h2>Attach是什么</h2>

<p>   在讲这个之前，我们先来点大家都知道的东西，当我们感觉线程一直卡在某个地方，想知道卡在哪里，首先想到的是进行线程dump，而常用的命令是jstack <pid>，我们就可以看到如下线程栈了</p>

<!--more-->


<p><img src="http://nijiaben.github.io/images/2014/07/trd.png"></p>

<p>   大家是否注意过上面圈起来的两个线程，”Attach Listener”和“Signal Dispatcher”，这两个线程是我们这次要讲的Attach机制的关键，先偷偷告诉各位，其实Attach Listener这个线程在jvm起来的时候可能并没有的，后面会细说。</p>

<p>   那Attach机制是什么？说简单点就是jvm提供一种jvm进程间通信的能力，能让一个进程传命令给另外一个进程，并让它执行内部的一些操作，比如说我们为了让另外一个jvm进程把线程dump出来，那么我们跑了一个jstack的进程，然后传了个pid的参数，告诉它要哪个进程进行线程dump，既然是两个进程，那肯定涉及到进程间通信，以及传输协议的定义，比如要执行什么操作，传了什么参数等</p>

<h2>Attach能做些什么</h2>

<p>   总结起来说，比如内存dump，线程dump，类信息统计(比如加载的类及大小以及实例个数等)，动态加载agent(使用过btrace的应该不陌生)，动态设置vm flag(但是并不是所有的flag都可以设置的，因为有些flag是在jvm启动过程中使用的，是一次性的)，打印vm flag，获取系统属性等，这些对应的源码(AttachListener.cpp)如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static AttachOperationFunctionInfo funcs[] = {
</span><span class='line'>  { "agentProperties",  get_agent_properties },
</span><span class='line'>  { "datadump",         data_dump },
</span><span class='line'>  { "dumpheap",         dump_heap },
</span><span class='line'>  { "load",             JvmtiExport::load_agent_library },
</span><span class='line'>  { "properties",       get_system_properties },
</span><span class='line'>  { "threaddump",       thread_dump },
</span><span class='line'>  { "inspectheap",      heap_inspection },
</span><span class='line'>  { "setflag",          set_flag },
</span><span class='line'>  { "printflag",        print_flag },
</span><span class='line'>  { "jcmd",             jcmd },
</span><span class='line'>  { NULL,               NULL }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>后面是命令对应的处理函数。</p>

<h2>Attach在jvm里如何实现的</h2>

<h3>Attach Listener线程的创建</h3>

<p> 前面也提到了，jvm在启动过程中可能并没有启动Attach Listener这个线程，可以通过jvm参数来启动，代码  （Threads::create_vm）如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  if (!DisableAttachMechanism) {
</span><span class='line'>    if (StartAttachListener || AttachListener::init_at_startup()) {
</span><span class='line'>      AttachListener::init();
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>bool AttachListener::init_at_startup() {
</span><span class='line'>  if (ReduceSignalUsage) {
</span><span class='line'>    return true;
</span><span class='line'>  } else {
</span><span class='line'>    return false;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中DisableAttachMechanism，StartAttachListener ，ReduceSignalUsage均默认是false(globals.hpp)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>product(bool, DisableAttachMechanism, false,                              \
</span><span class='line'>         "Disable mechanism that allows tools to Attach to this VM”)   
</span><span class='line'>product(bool, StartAttachListener, false,                                 \
</span><span class='line'>          "Always start Attach Listener at VM startup")  
</span><span class='line'>product(bool, ReduceSignalUsage, false,                                   \
</span><span class='line'>          "Reduce the use of OS signals in Java and/or the VM”)  </span></code></pre></td></tr></table></div></figure>


<p>因此AttachListener::init()并不会被执行，而Attach Listener线程正是在此方法里创建的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Starts the Attach Listener thread
</span><span class='line'>void AttachListener::init() {
</span><span class='line'>  EXCEPTION_MARK;
</span><span class='line'>  klassOop k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), true, CHECK);
</span><span class='line'>  instanceKlassHandle klass (THREAD, k);
</span><span class='line'>  instanceHandle thread_oop = klass-&gt;allocate_instance_handle(CHECK);
</span><span class='line'>
</span><span class='line'>  const char thread_name[] = "Attach Listener";
</span><span class='line'>  Handle string = java_lang_String::create_from_str(thread_name, CHECK);
</span><span class='line'>
</span><span class='line'>  // Initialize thread_oop to put it into the system threadGroup
</span><span class='line'>  Handle thread_group (THREAD, Universe::system_thread_group());
</span><span class='line'>  JavaValue result(T_VOID);
</span><span class='line'>  JavaCalls::call_special(&result, thread_oop,
</span><span class='line'>                       klass,
</span><span class='line'>                       vmSymbols::object_initializer_name(),
</span><span class='line'>                       vmSymbols::threadgroup_string_void_signature(),
</span><span class='line'>                       thread_group,
</span><span class='line'>                       string,
</span><span class='line'>                       CHECK);
</span><span class='line'>
</span><span class='line'>  KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
</span><span class='line'>  JavaCalls::call_special(&result,
</span><span class='line'>                        thread_group,
</span><span class='line'>                        group,
</span><span class='line'>                        vmSymbols::add_method_name(),
</span><span class='line'>                        vmSymbols::thread_void_signature(),
</span><span class='line'>                        thread_oop,             // ARG 1
</span><span class='line'>                        CHECK);
</span><span class='line'>
</span><span class='line'>  { MutexLocker mu(Threads_lock);
</span><span class='line'>    JavaThread* listener_thread = new JavaThread(&Attach_listener_thread_entry);
</span><span class='line'>
</span><span class='line'>    // Check that thread and osthread were created
</span><span class='line'>    if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) {
</span><span class='line'>      vm_exit_during_initialization("java.lang.OutOfMemoryError",
</span><span class='line'>                                    "unable to create new native thread");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    java_lang_Thread::set_thread(thread_oop(), listener_thread);
</span><span class='line'>    java_lang_Thread::set_daemon(thread_oop());
</span><span class='line'>
</span><span class='line'>    listener_thread-&gt;set_threadObj(thread_oop());
</span><span class='line'>    Threads::add(listener_thread);
</span><span class='line'>    Thread::start(listener_thread);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>既然在启动的时候不会创建这个线程，那么我们在上面看到的那个线程是怎么创建的呢，这个就要关注另外一个线程“Signal Dispatcher”了，顾名思义是处理信号的，这个线程是在jvm启动的时候就会创建的，具体代码就不说了。</p>

<p>下面以jstack的实现来说明触发Attach这一机制进行的过程，jstack命令的实现其实是一个叫做JStack.java的类，查看jstack代码后会走到下面的方法里</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static void runThreadDump(String pid, String args[]) throws Exception {
</span><span class='line'>        VirtualMachine vm = null;
</span><span class='line'>        try {
</span><span class='line'>            vm = VirtualMachine.Attach(pid);
</span><span class='line'>        } catch (Exception x) {
</span><span class='line'>            String msg = x.getMessage();
</span><span class='line'>            if (msg != null) {
</span><span class='line'>                System.err.println(pid + ": " + msg);
</span><span class='line'>            } else {
</span><span class='line'>                x.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>            if ((x instanceof AttachNotSupportedException) &&
</span><span class='line'>                (loadSAClass() != null)) {
</span><span class='line'>                System.err.println("The -F option can be used when the target " +
</span><span class='line'>                    "process is not responding");
</span><span class='line'>            }
</span><span class='line'>            System.exit(1);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Cast to HotSpotVirtualMachine as this is implementation specific
</span><span class='line'>        // method.
</span><span class='line'>        InputStream in = ((HotSpotVirtualMachine)vm).remoteDataDump((Object[])args);
</span><span class='line'>
</span><span class='line'>        // read to EOF and just print output
</span><span class='line'>        byte b[] = new byte[256];
</span><span class='line'>        int n;
</span><span class='line'>        do {
</span><span class='line'>            n = in.read(b);
</span><span class='line'>            if (n &gt; 0) {
</span><span class='line'>                String s = new String(b, 0, n, "UTF-8");
</span><span class='line'>                System.out.print(s);
</span><span class='line'>            }
</span><span class='line'>        } while (n &gt; 0);
</span><span class='line'>        in.close();
</span><span class='line'>        vm.detach();
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>请注意VirtualMachine.Attach(pid);这行代码，触发Attach pid的关键，如果是在linux下会走到下面的构造函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LinuxVirtualMachine(AttachProvider provider, String vmid)
</span><span class='line'>        throws AttachNotSupportedException, IOException
</span><span class='line'>    {
</span><span class='line'>        super(provider, vmid);
</span><span class='line'>
</span><span class='line'>        // This provider only understands pids
</span><span class='line'>        int pid;
</span><span class='line'>        try {
</span><span class='line'>            pid = Integer.parseInt(vmid);
</span><span class='line'>        } catch (NumberFormatException x) {
</span><span class='line'>            throw new AttachNotSupportedException("Invalid process identifier");
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Find the socket file. If not found then we attempt to start the
</span><span class='line'>        // Attach mechanism in the target VM by sending it a QUIT signal.
</span><span class='line'>        // Then we attempt to find the socket file again.
</span><span class='line'>        path = findSocketFile(pid);
</span><span class='line'>        if (path == null) {
</span><span class='line'>            File f = createAttachFile(pid);
</span><span class='line'>            try {
</span><span class='line'>                // On LinuxThreads each thread is a process and we don't have the
</span><span class='line'>                // pid of the VMThread which has SIGQUIT unblocked. To workaround
</span><span class='line'>                // this we get the pid of the "manager thread" that is created
</span><span class='line'>                // by the first call to pthread_create. This is parent of all
</span><span class='line'>                // threads (except the initial thread).
</span><span class='line'>                if (isLinuxThreads) {
</span><span class='line'>                    int mpid;
</span><span class='line'>                    try {
</span><span class='line'>                        mpid = getLinuxThreadsManager(pid);
</span><span class='line'>                    } catch (IOException x) {
</span><span class='line'>                        throw new AttachNotSupportedException(x.getMessage());
</span><span class='line'>                    }
</span><span class='line'>                    assert(mpid &gt;= 1);
</span><span class='line'>                    sendQuitToChildrenOf(mpid);
</span><span class='line'>                } else {
</span><span class='line'>                    sendQuitTo(pid);
</span><span class='line'>                }
</span><span class='line'>
</span><span class='line'>                // give the target VM time to start the Attach mechanism
</span><span class='line'>                int i = 0;
</span><span class='line'>                long delay = 200;
</span><span class='line'>                int retries = (int)(AttachTimeout() / delay);
</span><span class='line'>                do {
</span><span class='line'>                    try {
</span><span class='line'>                        Thread.sleep(delay);
</span><span class='line'>                    } catch (InterruptedException x) { }
</span><span class='line'>                    path = findSocketFile(pid);
</span><span class='line'>                    i++;
</span><span class='line'>                } while (i &lt;= retries && path == null);
</span><span class='line'>                if (path == null) {
</span><span class='line'>                    throw new AttachNotSupportedException(
</span><span class='line'>                        "Unable to open socket file: target process not responding " +
</span><span class='line'>                        "or HotSpot VM not loaded");
</span><span class='line'>                }
</span><span class='line'>            } finally {
</span><span class='line'>                f.delete();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Check that the file owner/permission to avoid Attaching to
</span><span class='line'>        // bogus process
</span><span class='line'>        checkPermissions(path);
</span><span class='line'>
</span><span class='line'>        // Check that we can connect to the process
</span><span class='line'>        // - this ensures we throw the permission denied error now rather than
</span><span class='line'>        // later when we attempt to enqueue a command.
</span><span class='line'>        int s = socket();
</span><span class='line'>        try {
</span><span class='line'>            connect(s, path);
</span><span class='line'>        } finally {
</span><span class='line'>            close(s);
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>这里要解释下代码了，首先看到调用了createAttachFile方法在目标进程的cwd目录下创建了一个文件/proc/<pid>/cwd/.Attach_pid<pid>，这个在后面的信号处理过程中会取出来做判断(为了安全)，另外我们知道在linux下线程是用进程实现的，在jvm启动过程中会创建很多线程，比如我们上面的信号线程，也就是会看到很多的pid(应该是LWP)，那么如何找到这个信号处理线程呢，从上面实现来看是找到我们传进去的pid的父进程，然后给它的所有子进程都发送一个SIGQUIT信号，而jvm里除了信号线程，其他线程都设置了对此信号的屏蔽，因此收不到该信号，于是该信号就传给了“Signal Dispatcher”，在传完之后作轮询等待看目标进程是否创建了某个文件，AttachTimeout默认超时时间是5000ms，可通过设置系统变量sun.tools.Attach.AttachTimeout来指定，下面是Signal Dispatcher线程的entry实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void signal_thread_entry(JavaThread* thread, TRAPS) {
</span><span class='line'>  os::set_priority(thread, NearMaxPriority);
</span><span class='line'>  while (true) {
</span><span class='line'>    int sig;
</span><span class='line'>    {
</span><span class='line'>      // FIXME : Currently we have not decieded what should be the status
</span><span class='line'>      //         for this java thread blocked here. Once we decide about
</span><span class='line'>      //         that we should fix this.
</span><span class='line'>      sig = os::signal_wait();
</span><span class='line'>    }
</span><span class='line'>    if (sig == os::sigexitnum_pd()) {
</span><span class='line'>       // Terminate the signal thread
</span><span class='line'>       return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    switch (sig) {
</span><span class='line'>      case SIGBREAK: {
</span><span class='line'>        // Check if the signal is a trigger to start the Attach Listener - in that
</span><span class='line'>        // case don't print stack traces.
</span><span class='line'>        if (!DisableAttachMechanism && AttachListener::is_init_trigger()) {
</span><span class='line'>          continue;
</span><span class='line'>        }
</span><span class='line'>        // Print stack traces
</span><span class='line'>        // Any SIGBREAK operations added here should make sure to flush
</span><span class='line'>        // the output stream (e.g. tty-&gt;flush()) after output.  See 4803766.
</span><span class='line'>        // Each module also prints an extra carriage return after its output.
</span><span class='line'>        VM_PrintThreads op;
</span><span class='line'>        VMThread::execute(&op);
</span><span class='line'>        VM_PrintJNI jni_op;
</span><span class='line'>        VMThread::execute(&jni_op);
</span><span class='line'>        VM_FindDeadlocks op1(tty);
</span><span class='line'>        VMThread::execute(&op1);
</span><span class='line'>        Universe::print_heap_at_SIGBREAK();
</span><span class='line'>        if (PrintClassHistogram) {
</span><span class='line'>          VM_GC_HeapInspection op1(gclog_or_tty, true /* force full GC before heap inspection */,
</span><span class='line'>                                   true /* need_prologue */);
</span><span class='line'>          VMThread::execute(&op1);
</span><span class='line'>        }
</span><span class='line'>        if (JvmtiExport::should_post_data_dump()) {
</span><span class='line'>          JvmtiExport::post_data_dump();
</span><span class='line'>        }
</span><span class='line'>        break;
</span><span class='line'>      }
</span><span class='line'>      ….
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当信号是SIGBREAK(在jvm里做了#define，其实就是SIGQUIT)的时候，就会触发
AttachListener::is_init_trigger()的执行，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bool AttachListener::is_init_trigger() {
</span><span class='line'>  if (init_at_startup() || is_initialized()) {
</span><span class='line'>    return false;               // initialized at startup or already initialized
</span><span class='line'>  }
</span><span class='line'>  char fn[PATH_MAX+1];
</span><span class='line'>  sprintf(fn, ".Attach_pid%d", os::current_process_id());
</span><span class='line'>  int ret;
</span><span class='line'>  struct stat64 st;
</span><span class='line'>  RESTARTABLE(::stat64(fn, &st), ret);
</span><span class='line'>  if (ret == -1) {
</span><span class='line'>    snprintf(fn, sizeof(fn), "%s/.Attach_pid%d",
</span><span class='line'>             os::get_temp_directory(), os::current_process_id());
</span><span class='line'>    RESTARTABLE(::stat64(fn, &st), ret);
</span><span class='line'>  }
</span><span class='line'>  if (ret == 0) {
</span><span class='line'>    // simple check to avoid starting the Attach mechanism when
</span><span class='line'>    // a bogus user creates the file
</span><span class='line'>    if (st.st_uid == geteuid()) {
</span><span class='line'>      init();
</span><span class='line'>      return true;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  return false;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一开始会判断当前进程目录下是否有个.Attach_pid<pid>文件（前面提到了），如果没有就会在/tmp下创建一个/tmp/.Attach_pid<pid>，当那个文件的uid和自己的uid是一致的情况下（为了安全）再调用init方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Starts the Attach Listener thread
</span><span class='line'>void AttachListener::init() {
</span><span class='line'>  EXCEPTION_MARK;
</span><span class='line'>  klassOop k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), true, CHECK);
</span><span class='line'>  instanceKlassHandle klass (THREAD, k);
</span><span class='line'>  instanceHandle thread_oop = klass-&gt;allocate_instance_handle(CHECK);
</span><span class='line'>
</span><span class='line'>  const char thread_name[] = "Attach Listener";
</span><span class='line'>  Handle string = java_lang_String::create_from_str(thread_name, CHECK);
</span><span class='line'>
</span><span class='line'>  // Initialize thread_oop to put it into the system threadGroup
</span><span class='line'>  Handle thread_group (THREAD, Universe::system_thread_group());
</span><span class='line'>  JavaValue result(T_VOID);
</span><span class='line'>  JavaCalls::call_special(&result, thread_oop,
</span><span class='line'>                       klass,
</span><span class='line'>                       vmSymbols::object_initializer_name(),
</span><span class='line'>                       vmSymbols::threadgroup_string_void_signature(),
</span><span class='line'>                       thread_group,
</span><span class='line'>                       string,
</span><span class='line'>                       CHECK);
</span><span class='line'>
</span><span class='line'>  KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
</span><span class='line'>  JavaCalls::call_special(&result,
</span><span class='line'>                        thread_group,
</span><span class='line'>                        group,
</span><span class='line'>                        vmSymbols::add_method_name(),
</span><span class='line'>                        vmSymbols::thread_void_signature(),
</span><span class='line'>                        thread_oop,             // ARG 1
</span><span class='line'>                        CHECK);
</span><span class='line'>
</span><span class='line'>  { MutexLocker mu(Threads_lock);
</span><span class='line'>    JavaThread* listener_thread = new JavaThread(&Attach_listener_thread_entry);
</span><span class='line'>
</span><span class='line'>    // Check that thread and osthread were created
</span><span class='line'>    if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) {
</span><span class='line'>      vm_exit_during_initialization("java.lang.OutOfMemoryError",
</span><span class='line'>                                    "unable to create new native thread");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    java_lang_Thread::set_thread(thread_oop(), listener_thread);
</span><span class='line'>    java_lang_Thread::set_daemon(thread_oop());
</span><span class='line'>
</span><span class='line'>    listener_thread-&gt;set_threadObj(thread_oop());
</span><span class='line'>    Threads::add(listener_thread);
</span><span class='line'>    Thread::start(listener_thread);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>此时水落石出了，看到创建了一个线程，并且取名为Attach Listener。再看看其子类LinuxAttachListener的init方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int LinuxAttachListener::init() {
</span><span class='line'>  char path[UNIX_PATH_MAX];          // socket file
</span><span class='line'>  char initial_path[UNIX_PATH_MAX];  // socket file during setup
</span><span class='line'>  int listener;                      // listener socket (file descriptor)
</span><span class='line'>
</span><span class='line'>  // register function to cleanup
</span><span class='line'>  ::atexit(listener_cleanup);
</span><span class='line'>
</span><span class='line'>  int n = snprintf(path, UNIX_PATH_MAX, "%s/.java_pid%d",
</span><span class='line'>                   os::get_temp_directory(), os::current_process_id());
</span><span class='line'>  if (n &lt; (int)UNIX_PATH_MAX) {
</span><span class='line'>    n = snprintf(initial_path, UNIX_PATH_MAX, "%s.tmp", path);
</span><span class='line'>  }
</span><span class='line'>  if (n &gt;= (int)UNIX_PATH_MAX) {
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // create the listener socket
</span><span class='line'>  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
</span><span class='line'>  if (listener == -1) {
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // bind socket
</span><span class='line'>  struct sockaddr_un addr;
</span><span class='line'>  addr.sun_family = AF_UNIX;
</span><span class='line'>  strcpy(addr.sun_path, initial_path);
</span><span class='line'>  ::unlink(initial_path);
</span><span class='line'>  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
</span><span class='line'>  if (res == -1) {
</span><span class='line'>    RESTARTABLE(::close(listener), res);
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // put in listen mode, set permissions, and rename into place
</span><span class='line'>  res = ::listen(listener, 5);
</span><span class='line'>  if (res == 0) {
</span><span class='line'>      RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);
</span><span class='line'>      if (res == 0) {
</span><span class='line'>          res = ::rename(initial_path, path);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  if (res == -1) {
</span><span class='line'>    RESTARTABLE(::close(listener), res);
</span><span class='line'>    ::unlink(initial_path);
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>  set_path(path);
</span><span class='line'>  set_listener(listener);
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>看到其创建了一个监听套接字，并创建了一个文件/tmp/.java_pid<pid>，这个文件就是客户端之前一直在轮询等待的文件，随着这个文件的生成，意味着Attach的过程圆满结束了。</p>

<h3>Attach listener接收请求</h3>

<p>看看它的entry实现Attach_listener_thread_entry</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void Attach_listener_thread_entry(JavaThread* thread, TRAPS) {
</span><span class='line'>  os::set_priority(thread, NearMaxPriority);
</span><span class='line'>
</span><span class='line'>  thread-&gt;record_stack_base_and_size();
</span><span class='line'>
</span><span class='line'>  if (AttachListener::pd_init() != 0) {
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>  AttachListener::set_initialized();
</span><span class='line'>
</span><span class='line'>  for (;;) {
</span><span class='line'>    AttachOperation* op = AttachListener::dequeue();
</span><span class='line'>    if (op == NULL) {
</span><span class='line'>      return;   // dequeue failed or shutdown
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    ResourceMark rm;
</span><span class='line'>    bufferedStream st;
</span><span class='line'>    jint res = JNI_OK;
</span><span class='line'>
</span><span class='line'>    // handle special detachall operation
</span><span class='line'>    if (strcmp(op-&gt;name(), AttachOperation::detachall_operation_name()) == 0) {
</span><span class='line'>      AttachListener::detachall();
</span><span class='line'>    } else {
</span><span class='line'>      // find the function to dispatch too
</span><span class='line'>      AttachOperationFunctionInfo* info = NULL;
</span><span class='line'>      for (int i=0; funcs[i].name != NULL; i++) {
</span><span class='line'>        const char* name = funcs[i].name;
</span><span class='line'>        assert(strlen(name) &lt;= AttachOperation::name_length_max, "operation &lt;= name_length_max");
</span><span class='line'>        if (strcmp(op-&gt;name(), name) == 0) {
</span><span class='line'>          info = &(funcs[i]);
</span><span class='line'>          break;
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      // check for platform dependent Attach operation
</span><span class='line'>      if (info == NULL) {
</span><span class='line'>        info = AttachListener::pd_find_operation(op-&gt;name());
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      if (info != NULL) {
</span><span class='line'>        // dispatch to the function that implements this operation
</span><span class='line'>        res = (info-&gt;func)(op, &st);
</span><span class='line'>      } else {
</span><span class='line'>        st.print("Operation %s not recognized!", op-&gt;name());
</span><span class='line'>        res = JNI_ERR;
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // operation complete - send result and output to client
</span><span class='line'>    op-&gt;complete(res, &st);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从代码来看就是从队列里不断取AttachOperation，然后找到请求命令对应的方法进行执行，比如我们一开始说的jstack命令，找到 { &#8220;threaddump&#8221;,       thread_dump }的映射关系，然后执行thread_dump方法</p>

<p>再来看看其要调用的AttachListener::dequeue()，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AttachOperation* AttachListener::dequeue() {
</span><span class='line'>  JavaThread* thread = JavaThread::current();
</span><span class='line'>  ThreadBlockInVM tbivm(thread);
</span><span class='line'>
</span><span class='line'>  thread-&gt;set_suspend_equivalent();
</span><span class='line'>  // cleared by handle_special_suspend_equivalent_condition() or
</span><span class='line'>  // java_suspend_self() via check_and_wait_while_suspended()
</span><span class='line'>
</span><span class='line'>  AttachOperation* op = LinuxAttachListener::dequeue();
</span><span class='line'>
</span><span class='line'>  // were we externally suspended while we were waiting?
</span><span class='line'>  thread-&gt;check_and_wait_while_suspended();
</span><span class='line'>
</span><span class='line'>  return op;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最终调用的是LinuxAttachListener::dequeue()，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LinuxAttachOperation* LinuxAttachListener::dequeue() {
</span><span class='line'>  for (;;) {
</span><span class='line'>    int s;
</span><span class='line'>
</span><span class='line'>    // wait for client to connect
</span><span class='line'>    struct sockaddr addr;
</span><span class='line'>    socklen_t len = sizeof(addr);
</span><span class='line'>    RESTARTABLE(::accept(listener(), &addr, &len), s);
</span><span class='line'>    if (s == -1) {
</span><span class='line'>      return NULL;      // log a warning?
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // get the credentials of the peer and check the effective uid/guid
</span><span class='line'>    // - check with jeff on this.
</span><span class='line'>    struct ucred cred_info;
</span><span class='line'>    socklen_t optlen = sizeof(cred_info);
</span><span class='line'>    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
</span><span class='line'>      int res;
</span><span class='line'>      RESTARTABLE(::close(s), res);
</span><span class='line'>      continue;
</span><span class='line'>    }
</span><span class='line'>    uid_t euid = geteuid();
</span><span class='line'>    gid_t egid = getegid();
</span><span class='line'>
</span><span class='line'>    if (cred_info.uid != euid || cred_info.gid != egid) {
</span><span class='line'>      int res;
</span><span class='line'>      RESTARTABLE(::close(s), res);
</span><span class='line'>      continue;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // peer credential look okay so we read the request
</span><span class='line'>    LinuxAttachOperation* op = read_request(s);
</span><span class='line'>    if (op == NULL) {
</span><span class='line'>      int res;
</span><span class='line'>      RESTARTABLE(::close(s), res);
</span><span class='line'>      continue;
</span><span class='line'>    } else {
</span><span class='line'>      return op;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们看到如果没有请求的话，会一直accept在那里，当来了请求，然后就会创建一个套接字，并读取数据，构建出LinuxAttachOperation返回并执行。</p>

<p>整个过程就这样了，从Attach线程创建到接收请求，处理请求。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDK的sql设计不合理导致的驱动类初始化死锁问题]]></title>
    <link href="http://nijiaben.github.io/blog/2014/07/08/jdk-sql-deadlock/"/>
    <updated>2014-07-08T16:39:46+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/07/08/jdk-sql-deadlock</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>当我们一个系统既需要mysql驱动，也需要oracle驱动的时候，在并发加载初始化这些驱动类的过程中产生死锁的可能性非常大，下面是一个模拟的例子，对于Thread2的实现其实是jdk里java.sql.DriverService的逻辑，也是我们第一次调用java.sql.DriverManager.registerDriver注册一个驱动实例要走的逻辑(jdk1.6下)，不过这篇文章是使用我们生产环境的一个系统的线程dump和内存dump为基础进行分析展开的。</p>

<!--more-->




<div>
  <pre><code class='java'>import java.util.Iterator;

import sun.misc.Service;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException {
        Thread1 thread1 = new Thread1();
        Thread2 thread2 = new Thread2();
        thread1.start();
        thread2.start();
    }
}

class Thread1 extends Thread {
    public void run() {
        try {
            Class&lt;?&gt; clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;, true, Thread.currentThread()
                .getContextClassLoader());
            System.out.println(clazz);
        } catch (ClassNotFoundException e) {
        }
    }
}

class Thread2 extends Thread {
    public void run() {
        Iterator ps = Service.providers(java.sql.Driver.class);
        try {
            while (ps.hasNext()) {
                System.out.println(ps.next());
            } 
        } catch (Throwable t) {
           
        }
    }
}</code></pre>
</div>


<p>如果以上代码运行过程中发现有线程一直卡死在Class.forName的调用里，那么说明问题已经重现了。</p>

<p>先上两张图</p>

<p><code>内存态线程堆栈</code></p>

<p><img src="http://nijiaben.github.io/images/2014/07/heap_thread_1.png"></p>

<p><code>线程堆栈</code></p>

<p><img src="http://nijiaben.github.io/images/2014/07/thread_1.png"></p>

<h2>存疑点</h2>

<p>仔细看看上面的线程dump分析和内存dump分析里的线程分析模块，您可能会有如下两个疑惑：</p>

<ul>
<li><p>【为什么线程[Thread-0]一直卡在Class.forName的位置】：这有点出乎意料，做一个类加载要么找不到抛出ClassNotFoundException，要么找到直接返回，为什么会一直卡在这个位置呢？</p></li>
<li><p>【明明[Thread-0]注册的是mysql驱动为什么会去加载Odbc的驱动类】：通过[Thread-0]在栈上看倒数第二帧展开看到传入Class.forName的参数是com.mysql.jdbc.Driver，然后展开栈上顺序第二帧，看到传入的参数是sun.jdbc.odbc.JdbcOdbcDriver，这意味着在对mysql驱动类做加载初始化的过程中又触发了JdbcOdbc驱动类的加载</p></li>
</ul>


<h2>疑惑点解释</h2>

<h3>疑惑二：</h3>

<p>第一个疑惑我们先留着，先解释下第二个疑惑，大家可以对照堆栈通过反编译rt.jar还有ojdbc6-11.2.0.3.0.jar看具体的代码</p>

<p><code>驱动类加载过程简要介绍:</code></p>

<p>当要注册某个sql驱动的时候是通过调用java.sql.DriverManager.registerDriver来实现的(注意这个方法加了synchronized关键字，后面解释第一个疑惑的时候是关键)，而这个方法在第一次执行过程中，会在当前线程classloader的classpath下寻找所有/META-INF/services/java.sql.Driver文件，这个文件在mysql和oracle驱动jar里都有，里面写的是对应的驱动实现类名，这种机制是jdk提供的spi实现，找到这些文件之后，依次使用Class.forName(driverClassName, true, this.loader)来对这些驱动类进行加载，其中第二个参数是true，意味着不仅仅做一次loadClass的动作，还会初始化该类，即调用包含静态块的&lt; clinit >方法，执行完之后才会返回，这样就解释了第二个疑惑，在mysql驱动注册过程中还会对odbc驱动类进行加载并初始化</p>

<p><code>感想:</code></p>

<p>其实我觉得这种设计有点傻，为什么要干和自己不相关的事情呢，画蛇添足的设计，首先类初始化的开销是否放到一起做并没有多大区别，其次正由于这种设计导致了今天这个死锁的发生</p>

<h3>疑惑一：</h3>

<p>现在来说第一个疑惑，为什么会一直卡在Class.forName呢，到底卡在哪里，于是再通过jstack -m <pid>命令将jvm里的堆栈也打印出来，如下所示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>----------------- 5738 -----------------
</span><span class='line'>0x003f67a2      _dl_sysinfo_int80 + 0x2
</span><span class='line'>0xb79a71ae      _ZN2os13PlatformEvent4parkEv + 0xee
</span><span class='line'>0xb7997acb      _ZN13ObjectMonitor4waitExbP6Thread + 0x5fb
</span><span class='line'>0xb7a73c53      _ZN18ObjectSynchronizer19waitUninterruptiblyE6HandlexP6Thread + 0x53
</span><span class='line'>0xb777eb34      _ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread + 0x74
</span><span class='line'>0xb777e288      _ZN13instanceKlass10initializeEP6Thread + 0x58
</span><span class='line'>0xb7821ad9      _Z28find_class_from_class_loaderP7JNIEnv_12symbolHandleh6HandleS2_hP6Thread + 0xb9
</span><span class='line'>0xb7807d99      JVM_FindClassFromClassLoader + 0x269
</span><span class='line'>0xb734c236      Java_java_lang_Class_forName0 + 0x116
</span><span class='line'>0xb433064a      * java.lang.Class.forName0(java.lang.String, boolean, java.lang.ClassLoader) bci:0 (Interpreted frame)
</span><span class='line'>0xb4328fa7      * java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader) bci:32 line:247 (Interpreted frame)
</span><span class='line'>0xb4328fa7      * sun.misc.Service$LazyIterator.next() bci:31 line:271 (Interpreted frame)
</span><span class='line'>0xb4329483      * java.sql.DriverService.run() bci:26 line:664 (Interpreted frame)
</span><span class='line'>0xb43263e6      &lt;StubRoutines&gt;
</span><span class='line'>0xb77a4e31      _ZN9JavaCalls11call_helperEP9JavaValueP12methodHandleP17JavaCallArgumentsP6Thread + 0x1c1
</span><span class='line'>0xb79a6418      _ZN2os20os_exception_wrapperEPFvP9JavaValueP12methodHandleP17JavaCallArgumentsP6ThreadES1_S3_S5_S7_ + 0x18
</span><span class='line'>0xb77a4c5f      _ZN9JavaCalls4callEP9JavaValue12methodHandleP17JavaCallArgumentsP6Thread + 0x2f
</span><span class='line'>0xb780aace      JVM_DoPrivileged + 0x40e
</span><span class='line'>0xb734b95d      Java_java_security_AccessController_doPrivileged__Ljava_security_PrivilegedAction_2 + 0x3d
</span><span class='line'>0xb433064a      * java.security.AccessController.doPrivileged(java.security.PrivilegedAction) bci:0 (Interpreted frame)
</span><span class='line'>0xb4328fa7      * java.sql.DriverManager.loadInitialDrivers() bci:31 line:506 (Interpreted frame)
</span><span class='line'>0xb432910d      * java.sql.DriverManager.initialize() bci:11 line:612 (Interpreted frame)
</span><span class='line'>0xb432910d      * java.sql.DriverManager.registerDriver(java.sql.Driver) bci:6 line:281 (Interpreted frame)
</span><span class='line'>0xb432910d      * com.mysql.jdbc.Driver.&lt;clinit&gt;() bci:7 line:65 (Interpreted frame)
</span><span class='line'>0xb43263e6      &lt;StubRoutines&gt;
</span><span class='line'>0xb77a4e31      _ZN9JavaCalls11call_helperEP9JavaValueP12methodHandleP17JavaCallArgumentsP6Thread + 0x1c1
</span><span class='line'>0xb79a6418      _ZN2os20os_exception_wrapperEPFvP9JavaValueP12methodHandleP17JavaCallArgumentsP6ThreadES1_S3_S5_S7_ + 0x18
</span><span class='line'>0xb77a4c5f      _ZN9JavaCalls4callEP9JavaValue12methodHandleP17JavaCallArgumentsP6Thread + 0x2f
</span><span class='line'>0xb77800c1      _ZN13instanceKlass27call_class_initializer_implE19instanceKlassHandleP6Thread + 0xa1
</span><span class='line'>0xb777ed8e      _ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread + 0x2ce
</span><span class='line'>0xb777e288      _ZN13instanceKlass10initializeEP6Thread + 0x58
</span><span class='line'>0xb7821ad9      _Z28find_class_from_class_loaderP7JNIEnv_12symbolHandleh6HandleS2_hP6Thread + 0xb9
</span><span class='line'>0xb7807d99      JVM_FindClassFromClassLoader + 0x269
</span><span class='line'>0xb734c236      Java_java_lang_Class_forName0 + 0x116
</span><span class='line'>0xb433064a      * java.lang.Class.forName0(java.lang.String, boolean, java.lang.ClassLoader) bci:0 (Interpreted frame)
</span><span class='line'>0xb4328fa7      * java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader) bci:32 line:247 (Interpreted frame)
</span><span class='line'>0xb4328fa7      * Thread1.run() bci:9 line:17 (Interpreted frame)
</span></code></pre></td></tr></table></div></figure>


<p>我们看到其实正在做类的初始化动作，并且线程正在调用ObjectSynchronizer::waitUninterruptibly一直没返回，在看这方法的调用者instanceKlass1::initialize_impl，我们找到源码位置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void instanceKlass::initialize_impl(instanceKlassHandle this_oop, TRAPS) {
</span><span class='line'>  // Make sure klass is linked (verified) before initialization
</span><span class='line'>  // A class could already be verified, since it has been reflected upon.
</span><span class='line'>  this_oop-&gt;link_class(CHECK);
</span><span class='line'>
</span><span class='line'>  DTRACE_CLASSINIT_PROBE(required, instanceKlass::cast(this_oop()), -1);
</span><span class='line'>
</span><span class='line'>  bool wait = false;
</span><span class='line'>
</span><span class='line'>  // refer to the JVM book page 47 for description of steps
</span><span class='line'>  // Step 1
</span><span class='line'>  { ObjectLocker ol(this_oop, THREAD);
</span><span class='line'>
</span><span class='line'>    Thread *self = THREAD; // it's passed the current thread
</span><span class='line'>
</span><span class='line'>    // Step 2
</span><span class='line'>    // If we were to use wait() instead of waitInterruptibly() then
</span><span class='line'>    // we might end up throwing IE from link/symbol resolution sites
</span><span class='line'>    // that aren't expected to throw.  This would wreak havoc.  See 6320309.
</span><span class='line'>    while(this_oop-&gt;is_being_initialized() && !this_oop-&gt;is_reentrant_initialization(self)) {
</span><span class='line'>        wait = true;
</span><span class='line'>      ol.waitUninterruptibly(CHECK);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Step 3
</span><span class='line'>    if (this_oop-&gt;is_being_initialized() && this_oop-&gt;is_reentrant_initialization(self)) {
</span><span class='line'>      DTRACE_CLASSINIT_PROBE_WAIT(recursive, instanceKlass::cast(this_oop()), -1,wait);
</span><span class='line'>      return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Step 4
</span><span class='line'>    if (this_oop-&gt;is_initialized()) {
</span><span class='line'>      DTRACE_CLASSINIT_PROBE_WAIT(concurrent, instanceKlass::cast(this_oop()), -1,wait);
</span><span class='line'>      return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Step 5
</span><span class='line'>    if (this_oop-&gt;is_in_error_state()) {
</span><span class='line'>      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, instanceKlass::cast(this_oop()), -1,wait);
</span><span class='line'>      ResourceMark rm(THREAD);
</span><span class='line'>      const char* desc = "Could not initialize class ";
</span><span class='line'>      const char* className = this_oop-&gt;external_name();
</span><span class='line'>      size_t msglen = strlen(desc) + strlen(className) + 1;
</span><span class='line'>      char* message = NEW_RESOURCE_ARRAY(char, msglen);
</span><span class='line'>      if (NULL == message) {
</span><span class='line'>        // Out of memory: can't create detailed error message
</span><span class='line'>        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);
</span><span class='line'>      } else {
</span><span class='line'>        jio_snprintf(message, msglen, "%s%s", desc, className);
</span><span class='line'>        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Step 6
</span><span class='line'>    this_oop-&gt;set_init_state(being_initialized);
</span><span class='line'>    this_oop-&gt;set_init_thread(self);
</span><span class='line'>  }
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>类的初始化过程:</code></p>

<p>当某个线程获得机会对某个类进行初始化的时候(请看上面的Step 6)，会设置这个类的init_state属性为being_initialized(如果初始化好了会设置为fully_initialized，异常的话会设置为initialization_error)，还会设置init_thread属性为当前线程，在这个设置过程中是有针对这个类提供了一把互斥锁的，因此当有别的线程进来的时候会被拦截在外面，如果设置完了，这把互斥锁也释放了，但是因为这个类的状态被设置了，因此并发问题也得到了解决，当另外一个线程也尝试初始化这个类的时候会判断这个类的状态是不是being_initialized，并且其init_thread不是当前线程，那么就会一直卡在那里，也就是此次线程dump的线程所处的状态，正在初始化类的线程会调用&lt; clinit >方法，如果正常结束了，那么就设置其状态为fully_initialized，并且通知之前卡在那里等待初始化完成的线程，然他们继续往下走(下一个动作就是再判断下状态，发现完成了就直接return了)</p>

<p><code>猜想:</code></p>

<p>在了解了上面的过程之后，于是我们猜测两种可能</p>

<ul>
<li>第一，这个类的状态还是being_intialized，还在while循环里没有跳出来</li>
<li>第二，事件通知机制出现了问题，也就是pthread_cond_wait和pthread_cond_signal之间的通信过程出现了问题。</li>
</ul>


<p>不过第二种可能性非常小，比较linux久经考验了，那接下来我们验证其实是第一个猜想</p>

<p><code>验证：</code></p>

<p>我们通过GDB attach的方式连到了问题机器上(好在机器没有挂)，首先我们要找到具体的问题线程，我们通过上面的jstack -m命令看到了线程ID是5738，然后通过info threads找到对应的线程，并得到它的序号14</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) info threads
</span><span class='line'>  17 process 5724  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  16 process 6878  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  15 process 5739  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  14 process 5738  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  13 process 5737  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  12 process 5736  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  11 process 5735  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  10 process 5734  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  9 process 5733  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  8 process 5732  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  7 process 5731  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  6 process 5730  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  5 process 5729  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  4 process 5728  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  3 process 5727  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  2 process 5726  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>  1 process 5725  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2</span></code></pre></td></tr></table></div></figure>


<p>     <br/>
然后通过thread 14切换到对应的线程，并通过bt看到了如下的堆栈，正如我们想象的那样，正在做类的初始化，一直卡在那里</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) thread 14
</span><span class='line'>[Switching to thread 14 (process 5738)]#0  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>(gdb) bt
</span><span class='line'>#0  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</span><span class='line'>#1  0x005e0d76 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/tls/i686/nosegneg/libpthread.so.0
</span><span class='line'>#2  0x005e13ee in pthread_cond_wait@GLIBC_2.0 () from /lib/tls/i686/nosegneg/libpthread.so.0
</span><span class='line'>#3  0xb79a71ae in os::PlatformEvent::park () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
</span><span class='line'>#4  0xb7997acb in ObjectMonitor::wait () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
</span><span class='line'>#5  0xb7a73c53 in ObjectSynchronizer::waitUninterruptibly () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
</span><span class='line'>#6  0xb777eb34 in instanceKlass::initialize_impl () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
</span><span class='line'>#7  0xb777e288 in instanceKlass::initialize () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
</span><span class='line'>#8  0xb7821ad9 in find_class_from_class_loader () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
</span><span class='line'>#9  0xb7807d99 in JVM_FindClassFromClassLoader () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
</span><span class='line'>#10 0xb734c236 in Java_java_lang_Class_forName0 () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/libjava.so
</span><span class='line'>#11 0xb433064a in ?? ()
</span><span class='line'>#12 0x0813b120 in ?? ()
</span><span class='line'>#13 0x70aaa690 in ?? ()
</span><span class='line'>#14 0x70aaa6a0 in ?? ()
</span><span class='line'>#15 0x00000001 in ?? ()
</span><span class='line'>#16 0x70aaa698 in ?? ()
</span><span class='line'>#17 0x00000000 in ?? ()
</span></code></pre></td></tr></table></div></figure>


<p>我们通过f 6选择第7帧，在通过disassemble反汇编该帧，也就是对instanceKlass::initialize_impl ()这个方法反汇编</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0xb777eaed &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+45&gt;: lea    0xfffffff4(%ebp),%esp    //将%ebp偏移0xfffffff4位置的值存到%esp栈顶，然后下面的pop操作存到%ebx
</span><span class='line'>0xb777eaf0 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+48&gt;:  pop    %ebx
</span><span class='line'>0xb777eaf1 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+49&gt;:  pop    %esi
</span><span class='line'>0xb777eaf2 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+50&gt;:  pop    %edi
</span><span class='line'>0xb777eaf3 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+51&gt;:  pop    %ebp
</span><span class='line'>0xb777eaf4 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+52&gt;:  ret
</span><span class='line'>0xb777eaf5 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+53&gt;:  push   $0x1
</span><span class='line'>0xb777eaf7 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+55&gt;:  lea    0xffffffd8(%ebp),%edx
</span><span class='line'>0xb777eafa &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+58&gt;:  push   %esi
</span><span class='line'>0xb777eafb &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+59&gt;:  push   %ebx
</span><span class='line'>0xb777eafc &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+60&gt;:  push   %edx
</span><span class='line'>0xb777eafd &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+61&gt;:  call   0xb7a73a80 &lt;_ZN12ObjectLockerC1E6HandleP6Threadb&gt;
</span><span class='line'>0xb777eb02 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+66&gt;:  add    $0x10,%esp
</span><span class='line'>0xb777eb05 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+69&gt;:  xor    %eax,%eax
</span><span class='line'>0xb777eb07 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+71&gt;:  test   %ebx,%ebx
</span><span class='line'>0xb777eb09 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+73&gt;:  je     0xb777eb0d &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+77&gt;
</span><span class='line'>0xb777eb0b &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+75&gt;:  mov    (%ebx),%eax      //将%ebx的值移到%eax
</span><span class='line'>0xb777eb0d &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+77&gt;:  cmpl   $0x4,0xe0(%eax)  //对比%eax偏移0xe0位置的值和0x4(这个值其实就是上面提到的being_initialized状态，这就说明了%eax偏移0xe0位置其实存的就是初始化类的初始化状态)
</span><span class='line'>0xb777eb14 &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+84&gt;:  jne    0xb777eb4f &lt;_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+143&gt;</span></code></pre></td></tr></table></div></figure>


<p>
从上面的注释我们其实得出了，我们要看当前类的初始化状态，那就是看eax寄存器偏移0xe0的位置的值，而eax其实就是ebp寄存器偏移0xfffffff4位置的值，于是我们通过如下地址内存查到得到是4</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) x $ebp + 0xfffffff4
</span><span class='line'>0x70aaa45c:   0x71af2180
</span><span class='line'>(gdb) x/3w 0x71af2180 + 0xe0
</span><span class='line'>0x71af2260:   0x00000004  0x0813c800  0x0000001a</span></code></pre></td></tr></table></div></figure>


<p>     <br/>
而4其实代表的就是being_initialized这个状态，代码如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  enum ClassState {
</span><span class='line'>    unparsable_by_gc = 0,               
</span><span class='line'>    allocated,                          
</span><span class='line'>    loaded,                             
</span><span class='line'>    linked,                             
</span><span class='line'>    being_initialized,                  
</span><span class='line'>    fully_initialized,                  
</span><span class='line'>    initialization_error                
</span><span class='line'>  };</span></code></pre></td></tr></table></div></figure>


<p>
从这于是我们验证了第一个猜想，其实是状态一直没有变更，因此一直卡在那里，为了更进一步确认这个问题，要是我们能找到该类的init_thread线程id就更清楚了，拿到这个ID我们就能看到这个线程栈，就知道它在干什么了，但是很遗憾，这个很难获取到，至少我一直没有找到办法，因为线程ID在线程对象里一直没有存，都是调用的os函数来获取的，得换个思路。</p>

<p>突然发现instanceKlass.hpp代码中得知两个属性原来是相邻的(init_state和init_thread)，于是断定下一个地址的值就代表是这个线程对象了，但是其属性何其多，找到想要的太不易了，最主要的是还担心自己看的代码和服务器上的jvm代码不一致，这样更蛋疼了，于是继续查看Thread.hpp中的JavaThread类，找到个关键字0xDEAD-2=0xDEAB,这个有可能是volatile TerminatedTypes _terminated属性的值，于是把线程对象打印出来，果然查到了关键字0xDEAB</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) x/100w 0x0813c800
</span><span class='line'>0x813c800:    0xb7bc06e8  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x813c810:    0x0813c488  0x0813d2c8  0x00000000  0x00000000
</span><span class='line'>0x813c820:    0x080f9bf8  0x080f8b50  0x70a59b60  0x00000000
</span><span class='line'>0x813c830:    0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x813c840:    0x00014148  0x00000505  0x00000000  0x00000000
</span><span class='line'>0x813c850:    0x00000000  0x00000000  0x00000000  0x3f800021
</span><span class='line'>0x813c860:    0x00000001  0x00000023  0x3f800021  0x0001b530
</span><span class='line'>0x813c870:    0x00000000  0x00000000  0x00000000  0x080ffdc0
</span><span class='line'>0x813c880:    0x00000001  0x00000000  0x080ffe24  0x00000014
</span><span class='line'>0x813c890:    0x00000031  0x00000000  0x00000000  0x0813dab0
</span><span class='line'>0x813c8a0:    0x0813c428  0x0813ce98  0x70a5b000  0x00051000
</span><span class='line'>0x813c8b0:    0x00000000  0xffffffff  0x00000000  0x080ffdc0
</span><span class='line'>0x813c8c0:    0x00002bad  0x0813d400  0x0813d500  0x0813d700
</span><span class='line'>0x813c8d0:    0x0813d800  0x00000000  0x00000000  0x104aa1ad
</span><span class='line'>0x813c8e0:    0x544a5ab2  0x32378fc7  0x00008767  0x00000000
</span><span class='line'>0x813c8f0:    0x00000000  0x00000000  0x0ee9547d  0x00000000
</span><span class='line'>0x813c900:    0x00000000  0x00000000  0x0813b000  0x75878760
</span><span class='line'>0x813c910:    0x70a59a94  0x00000000  0x70a59abc  0xb7829020
</span><span class='line'>0x813c920:    0xb7bb7100  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x813c930:    0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x813c940:    0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x813c950:    0x00000000  0x00000000  0x00000000  0x0000000a
</span><span class='line'>0x813c960:    0x0813da98  0x00000000  0x0000deab  0x00000001
</span><span class='line'>0x813c970:    0x00000000  0x00000000  0x00000002  0x00000000
</span><span class='line'>0x813c980:    0x00000000  0x00000000  0x00000000  0x00000000</span></code></pre></td></tr></table></div></figure>


<p>因此顺着这个属性继续往上找，找到了_thread_state表示线程状态的值（向上偏移三个字），0x0000000a，即10，然后查看代码知道原来线程是出于block状态</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> public:                                    
</span><span class='line'>  volatile JavaThreadState _thread_state;
</span><span class='line'> private:
</span><span class='line'>  ThreadSafepointState *_safepoint_state;        
</span><span class='line'>  address               _saved_exception_pc;    
</span><span class='line'>  volatile TerminatedTypes _terminated;</span></code></pre></td></tr></table></div></figure>


<p><code>JavaThreadState</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> enum JavaThreadState {
</span><span class='line'>  _thread_uninitialized     =  0, 
</span><span class='line'>  _thread_new               =  2, 
</span><span class='line'>  _thread_new_trans         =  3, 
</span><span class='line'>  _thread_in_native         =  4, 
</span><span class='line'>  _thread_in_native_trans   =  5, 
</span><span class='line'>  _thread_in_vm             =  6, 
</span><span class='line'>  _thread_in_vm_trans       =  7, 
</span><span class='line'>  _thread_in_Java           =  8, 
</span><span class='line'>  _thread_in_Java_trans     =  9, 
</span><span class='line'>  _thread_blocked           = 10, 
</span><span class='line'>  _thread_blocked_trans     = 11, 
</span><span class='line'>  _thread_max_state         = 12  
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这样一来查看下线程dump，发现<code>Thread-1</code>正好处于BLOCKED状态，也就是说Thread-1就是那个正在对mysql驱动类做初始化的线程，这说明<code>Thread-0</code>和<code>Thread-1</code>成功互锁了</p>

<p>于是我们展开<code>Thread-1</code>，看到<code>- waiting to lock &lt;0x71ae2ec0&gt; (a java.lang.Class for java.sql.DriverManager)</code>，该线程正在等待java.sql.DriverManager类型锁，而blocked在那里，而这个类型锁是被<code>Thread-0</code>线程持有的，从<code>Thread-1</code>这个线程堆栈来看它其实也是在做Class.forName动作，并且通过<code>Thread-1</code>,展开第四帧我们可以看到其正在对加载sun.jdbc.odbc.JdbcOdbcDriver</p>

<p><code>问题现场遐想:</code></p>

<p>于是我们大胆设想一个场景，<code>Thread-1</code>先获取到初始化sun.jdbc.odbc.JdbcOdbcDriver的机会，然后在执行sun.jdbc.odbc.JdbcOdbcDriver这个类的静态块的时候调用DriverManager.registerDriver(new Driver());，而该方法之前已经提到了是会加同步锁的，再想象一下，在这个这个静态块之前，并且设置了sun.jdbc.odbc.JdbcOdbcDriver类的初始化状态为being_initialized之后，<code>Thread-0</code>这个线程执行到了卡在的那个位置，并且我们从其堆栈可以看出它已经持有了java.sql.DriverManager这个类型的锁，因此这两个线程陷入了互锁状态</p>

<h3>解决方案</h3>

<p>解决方案目前想到的是将驱动类的加载过程变成单线程加载，不存在并发情况就没问题了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress新纪元]]></title>
    <link href="http://nijiaben.github.io/blog/2014/04/23/new-begin/"/>
    <updated>2014-04-23T23:47:00+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/04/23/new-begin</id>
    <content type="html"><![CDATA[<p><img src="http://nijiaben.github.io/images/2014/04/github_page_and-octopress.png"></p>

<pre><code>    今天又做了一个尝试，从wordpress换到了octopress，放弃了pcduino，选择了免费的github。
</code></pre>

<ul>
<li>octopress界面的清爽简洁</li>
<li>octopress对markdown语法的天然支持

<ul>
<li>虽然wordpress也有markdown的插件，但是还是喜欢正统</li>
<li>公司周报都用markdown写了，主要是排版非常舒服</li>
</ul>
</li>
<li>octopress有程序员的思维，用官方话说“Octopress is a blogging framework for hackers”</li>
<li>pcduino

<ul>
<li>于己写文章/发布都比较蛋疼，毕竟是一块价值仅300多的开发板，性能有限，有时间真的会影响写文章的心情</li>
<li>于人访问速度犹如龟速，甚至有时候还经常打不开，实在对不住看客们</li>
<li>域名访问不稳定，主要还是自己不想成为域名代理服务商付费用户，只得路由器上做端口映射，路由器重启域名还会重新指定A记录，实在是屌丝至极</li>
</ul>
</li>
<li>转向github，大势所趋，公司内部都慢慢放弃svn，投入github托管，自己目前开发的项目也使用git，之前记得微博上有人招聘，提了几个要求，如果你连github账户都没一个，请不要投简历给我，可见github的未来非常美好啊

<ul>
<li>主要还是免费的，哈哈， 访问速度还可以，虽然偶尔会被墙一下，不过貌似问题不大</li>
<li>还支持域名绑定</li>
</ul>
</li>
</ul>


<p>之前的部分博文请访问<a href="http://alipaymiddleware.com/">支付宝中间件官方博客</a></p>
]]></content>
  </entry>
  
</feed>
