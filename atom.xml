<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[你假笨]]></title>
  <link href="http://nijiaben.github.io/atom.xml" rel="self"/>
  <link href="http://nijiaben.github.io/"/>
  <updated>2015-10-21T20:45:09+08:00</updated>
  <id>http://nijiaben.github.io/</id>
  <author>
    <name><![CDATA[你假笨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[消失的死锁]]></title>
    <link href="http://nijiaben.github.io/blog/2015/10/21/deadlock/"/>
    <updated>2015-10-21T18:54:01+08:00</updated>
    <id>http://nijiaben.github.io/blog/2015/10/21/deadlock</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>如果java层面发生了死锁，当我们使用<code>jstack</code>命令的时候其实是可以将死锁的信息给dump出来的，在dump结果的最后会有类似<code>Found one Java-level deadlock:</code>的关键字，接着会把发生死锁的线程的堆栈及对应的同步锁给打印出来，这次碰到一个系统就发生类似的问题，不过这个dump文档里虽然提到了如下的死锁信息：</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Found one Java-level deadlock:
</span><span class='line'>=============================
</span><span class='line'>"worker-1-thread-121":
</span><span class='line'>  waiting to lock monitor 0x00007f3758209dc8 (object 0x0000000764cd2b20, a java.util.concurrent.ConcurrentHashMap),
</span><span class='line'>  which is held by "HSFBizProcessor-4-thread-4"
</span><span class='line'>"HSFBizProcessor-4-thread-4":
</span><span class='line'>  waiting to lock monitor 0x00007f3758289260 (object 0x000000076073ddc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
</span><span class='line'>  which is held by "HSFBizProcessor-4-thread-5"
</span><span class='line'>"HSFBizProcessor-4-thread-5":
</span><span class='line'>  waiting to lock monitor 0x00007f3758253420 (object 0x00000007608e6fc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
</span><span class='line'>  which is held by "HSFBizProcessor-4-thread-4"</span></code></pre></td></tr></table></div></figure>


<p>但是我们在堆栈里搜索对应的锁的时候并没发现，也就是上面提到的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>object 0x00000007608e6fc8 which is held by "HSFBizProcessor-4-thread-4"</span></code></pre></td></tr></table></div></figure>


<p>我们在<code>HSFBizProcessor-4-thread-4</code>这个线程的堆栈里并没有看到对应的持锁信息。</p>

<p>附上线程dump详情</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Found one Java-level deadlock:
</span><span class='line'>=============================
</span><span class='line'>"worker-1-thread-121":
</span><span class='line'>  waiting to lock monitor 0x00007f3758209dc8 (object 0x0000000764cd2b20, a java.util.concurrent.ConcurrentHashMap),
</span><span class='line'>  which is held by "HSFBizProcessor-4-thread-4"
</span><span class='line'>"HSFBizProcessor-4-thread-4":
</span><span class='line'>  waiting to lock monitor 0x00007f3758289260 (object 0x000000076073ddc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
</span><span class='line'>  which is held by "HSFBizProcessor-4-thread-5"
</span><span class='line'>"HSFBizProcessor-4-thread-5":
</span><span class='line'>  waiting to lock monitor 0x00007f3758253420 (object 0x00000007608e6fc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
</span><span class='line'>  which is held by "HSFBizProcessor-4-thread-4"
</span><span class='line'>
</span><span class='line'>Java stack information for the threads listed above:
</span><span class='line'>===================================================
</span><span class='line'>"worker-1-thread-121":
</span><span class='line'>  at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:180)
</span><span class='line'>  - waiting to lock &lt;0x0000000764cd2b20&gt; (a java.util.concurrent.ConcurrentHashMap)
</span><span class='line'>  at org.springframework.beans.factory.support.AbstractBeanFactory.isTypeMatch(AbstractBeanFactory.java:455)
</span><span class='line'>  at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:317)
</span><span class='line'>  ......
</span><span class='line'>  at java.util.concurrent.FutureTask.run(FutureTask.java:138)
</span><span class='line'>  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>  at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>"HSFBizProcessor-4-thread-4":
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
</span><span class='line'>  - waiting to lock &lt;0x000000076073ddc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.SingleSourcePackage.loadClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
</span><span class='line'>  at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
</span><span class='line'>  at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
</span><span class='line'>  at org.springframework.scripting.groovy.GroovyScriptFactory.executeScript(GroovyScriptFactory.java:238)
</span><span class='line'>  ......
</span><span class='line'>  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>  at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>"HSFBizProcessor-4-thread-5":
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
</span><span class='line'>  - waiting to lock &lt;0x00000007608e6fc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.buddy.DependentPolicy.loadClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.buddy.PolicyHandler.doBuddyClassLoading(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
</span><span class='line'>  at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
</span><span class='line'>  at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
</span><span class='line'>  at java.lang.Class.forName0(Native Method)
</span><span class='line'>  at java.lang.Class.forName(Class.java:169)
</span><span class='line'>  at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:127)
</span><span class='line'>  at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:122)
</span><span class='line'>    ......
</span><span class='line'>  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
</span><span class='line'>  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
</span><span class='line'>  at java.lang.Thread.run(Thread.java:662)
</span><span class='line'>
</span><span class='line'>Found 1 deadlock.</span></code></pre></td></tr></table></div></figure>


<h2>类加载的问题？</h2>

<p>首先应该怀疑类加载的问题，因为我们看到导致死锁的对象是一个classloader对象：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>waiting to lock monitor 0x00007f3758289260 (object 0x000000076073ddc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)</span></code></pre></td></tr></table></div></figure>


<p>然后我们再来分析下堆栈</p>

<h3>HSFBizProcessor-4-thread-4</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"HSFBizProcessor-4-thread-4":
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
</span><span class='line'>  - waiting to lock &lt;0x000000076073ddc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.SingleSourcePackage.loadClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
</span><span class='line'>  at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
</span><span class='line'>  at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
</span><span class='line'>  at org.springframework.scripting.groovy.GroovyScriptFactory.executeScript(GroovyScriptFactory.java:238)
</span><span class='line'>  at org.springframework.scripting.groovy.GroovyScriptFactory.getScriptedObject(GroovyScriptFactory.java:185)</span></code></pre></td></tr></table></div></figure>


<p>我这里只把关键的线程栈贴出来，从栈顶知道正在等一把锁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- waiting to lock &lt;0x000000076073ddc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
</span></code></pre></td></tr></table></div></figure>


<p>这把锁的对象是一个ClassLoader对象，我们找到对应的代码，确实存在synchronized的操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private Class&lt;?&gt; findLoadedClass(String classname) {
</span><span class='line'>    if ((LOCK_CLASSNAME) || (this.isParallelClassLoader)) {
</span><span class='line'>      boolean initialLock = lockClassName(classname);
</span><span class='line'>      try {
</span><span class='line'>        return this.classloader.publicFindLoaded(classname);
</span><span class='line'>      } finally {
</span><span class='line'>        if (initialLock)
</span><span class='line'>          unlockClassName(classname);
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    synchronized (this.classloader) {
</span><span class='line'>      return this.classloader.publicFindLoaded(classname);
</span><span class='line'>    }
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>


<p>另外我们还知道它正在执行loadClass的动作，并且是从groovy调用来的，同样找到对应的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protected Object executeScript(ScriptSource scriptSource, Class scriptClass)
</span><span class='line'>    throws ScriptCompilationException
</span><span class='line'>  {
</span><span class='line'>    try
</span><span class='line'>    {
</span><span class='line'>      GroovyObject goo = (GroovyObject)scriptClass.newInstance();//line 238
</span><span class='line'>
</span><span class='line'>      if (this.groovyObjectCustomizer != null)
</span><span class='line'>      {
</span><span class='line'>        this.groovyObjectCustomizer.customize(goo);
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      if ((goo instanceof Script))
</span><span class='line'>      {
</span><span class='line'>        return ((Script)goo).run();
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      return goo;
</span><span class='line'>    }
</span><span class='line'>    catch (InstantiationException ex)
</span><span class='line'>    {
</span><span class='line'>      throw new ScriptCompilationException(
</span><span class='line'>        scriptSource, "Could not instantiate Groovy script class: " + scriptClass.getName(), ex);
</span><span class='line'>    }
</span><span class='line'>    catch (IllegalAccessException ex) {
</span><span class='line'>      throw new ScriptCompilationException(
</span><span class='line'>        scriptSource, "Could not access Groovy script constructor: " + scriptClass.getName(), ex);
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>执行到第238行的时候</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GroovyObject goo = (GroovyObject)scriptClass.newInstance();//line 238</span></code></pre></td></tr></table></div></figure>


<p>突然发现调用了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>java.lang.ClassLoader.loadClass(ClassLoader.java:247)</span></code></pre></td></tr></table></div></figure>


<p>而我们看到上面第238行的逻辑其实就是实例化一个对象，然后进行强转，我们看看对应的字节码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 0: aload_2
</span><span class='line'> 1: invokevirtual #164                // Method java/lang/Class.newInstance:()Ljava/lang/Object;
</span><span class='line'> 4: checkcast     #168                // class groovy/lang/GroovyObject
</span><span class='line'> 7: astore_3</span></code></pre></td></tr></table></div></figure>


<p>其实就对应这么几条字节码指令，其实在jvm里当我们执行checkcast指令的时候会触发类加载的动作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void TemplateTable::checkcast() {
</span><span class='line'>  ...
</span><span class='line'>  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
</span><span class='line'>  ...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>IRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))
</span><span class='line'>  // Force resolving; quicken the bytecode
</span><span class='line'>  int which = get_index_u2(thread, Bytecodes::_checkcast);
</span><span class='line'>  constantPoolOop cpool = method(thread)-&gt;constants();
</span><span class='line'>  // We'd expect to assert that we're only here to quicken bytecodes, but in a multithreaded
</span><span class='line'>  // program we might have seen an unquick'd bytecode in the interpreter but have another
</span><span class='line'>  // thread quicken the bytecode before we get here.
</span><span class='line'>  // assert( cpool-&gt;tag_at(which).is_unresolved_klass(), "should only come here to quicken bytecodes" );
</span><span class='line'>  klassOop klass = cpool-&gt;klass_at(which, CHECK);
</span><span class='line'>  thread-&gt;set_vm_result(klass);
</span><span class='line'>IRT_END
</span><span class='line'>
</span><span class='line'>klassOop klass_at(int which, TRAPS) {
</span><span class='line'>    constantPoolHandle h_this(THREAD, this);
</span><span class='line'>    return klass_at_impl(h_this, which, CHECK_NULL);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>klassOop constantPoolOopDesc::klass_at_impl(constantPoolHandle this_oop, int which, TRAPS) {
</span><span class='line'>  ...
</span><span class='line'>    klassOop k_oop = SystemDictionary::resolve_or_fail(name, loader, h_prot, true, THREAD);
</span><span class='line'>  ...
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>//SystemDictionary::resolve_or_fail最终会调用到下面这个方法
</span><span class='line'>klassOop SystemDictionary::resolve_instance_class_or_null(Symbol* name, Handle class_loader, Handle protection_domain, TRAPS) {
</span><span class='line'>  ...
</span><span class='line'>  // Class is not in SystemDictionary so we have to do loading.
</span><span class='line'>  // Make sure we are synchronized on the class loader before we proceed
</span><span class='line'>  Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
</span><span class='line'>  check_loader_lock_contention(lockObject, THREAD);
</span><span class='line'>  ObjectLocker ol(lockObject, THREAD, DoObjectLock);
</span><span class='line'>  ...
</span><span class='line'>  //此时会调用ClassLoader.loadClass来加载类了
</span><span class='line'>  ...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
</span><span class='line'>  // If class_loader is NULL we synchronize on _system_loader_lock_obj
</span><span class='line'>  if (class_loader.is_null()) {
</span><span class='line'>    return Handle(THREAD, _system_loader_lock_obj);
</span><span class='line'>  } else {
</span><span class='line'>    return class_loader;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>SystemDictionary::resolve_instance_class_or_null</code>这个方法非常关键了，在里面我们看到会获取一把锁ObjectLocker，其相当于我们java代码里的<code>synchronized</code>关键字，而对象对应的是lockObject，这个对象是上面的<code>SystemDictionary::compute_loader_lock_object</code>方法返回的，从代码可知只要不是bootstrapClassloader加载的类就会返回当前classloader对象，也就是说当我们在加载一个类的时候其实是会持有当前类加载对象的锁的，在获取了这把锁之后就会调用ClassLoader.loadClass来加载类了。这其实就解释了<code>HSFBizProcessor-4-thread-4</code>这个线程为什么持有了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>object 0x00000007608e6fc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader</span></code></pre></td></tr></table></div></figure>


<p>这个类加载的锁，不过遗憾的是因为这把锁不是java层面来显示加载的，因此我们在<code>jstack</code>线程dump的输出里居然看不到这把锁的存在.</p>

<h3>HSFBizProcessor-4-thread-5</h3>

<p>先上堆栈：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"HSFBizProcessor-4-thread-5":
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
</span><span class='line'>  - waiting to lock &lt;0x00000007608e6fc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
</span><span class='line'>  at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.buddy.DependentPolicy.loadClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.buddy.PolicyHandler.doBuddyClassLoading(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
</span><span class='line'>  at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
</span><span class='line'>  at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
</span><span class='line'>  at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
</span><span class='line'>  at java.lang.Class.forName0(Native Method)
</span><span class='line'>  at java.lang.Class.forName(Class.java:169)</span></code></pre></td></tr></table></div></figure>


<p>这个线程栈其实和之前那个线程差不多，只是等的锁不一样，另外触发类加载的动作是<code>Class.forName</code>，获取大家也猜到了，其实是在下面两行堆栈之间同样获取了一把类加载器的锁</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
</span><span class='line'>at java.lang.Class.forName0(Native Method)</span></code></pre></td></tr></table></div></figure>


<p>这里的代码我也不细贴了，最终调用的jvm里的方法都是一样的，获取锁的逻辑也是一样的</p>

<h2>总结</h2>

<p>想象下这种场景，两个线程分别使用不同的classloader对两个类进行类加载，然而由于osgi类加载机制的缘故，在loadClass过程中可能会委托给别的classloader去加载，而正巧，这两个线程在获取当前classloader的锁之后，然后分别委托对方的classloader去加载，可以看到文章开头列的那个findLoadedClass方法，而synchronized的那个classloader正好是对方的classloader，从而导致了死锁</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之javaagent原理完全解读]]></title>
    <link href="http://nijiaben.github.io/blog/2015/09/14/javaagent/"/>
    <updated>2015-09-14T13:17:50+08:00</updated>
    <id>http://nijiaben.github.io/blog/2015/09/14/javaagent</id>
    <content type="html"><![CDATA[<p><code>注:文章首发于InfoQ：</code><a href="http://www.infoq.com/cn/articles/javaagent-illustrated">JVM源码分析之javaagent原理完全解读</a></p>

<h2>概述</h2>

<p>本文重点讲述javaagent的具体实现，因为它面向的是我们java程序员，而且agent都是用java编写的，不需要太多的c/c++编程基础，不过这篇文章里也会讲到JVMTIAgent(c实现的)，因为javaagent的运行还是依赖于一个特殊的JVMTIAgent。</p>

<!-- more -->


<p>对于javaagent或许大家都听过，甚至使用过，常见的用法大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>java -javaagent:myagent.jar=mode=test Test</span></code></pre></td></tr></table></div></figure>


<p>我们通过-javaagent来指定我们编写的agent的jar路径（./myagent.jar）及要传给agent的参数（mode=test），这样在启动的时候这个agent就可以做一些我们想要它做的事了。</p>

<p>javaagent的主要的功能如下：</p>

<ul>
<li>可以在加载class文件之前做拦截把字节码做修改</li>
<li>可以在运行期将已经加载的类的字节码做变更，但是这种情况下会有很多的限制，后面会详细说</li>
<li>还有其他的一些小众的功能

<ul>
<li>获取所有已经被加载过的类</li>
<li>获取所有已经被初始化过了的类（执行过了clinit方法，是上面的一个子集）</li>
<li>获取某个对象的大小</li>
<li>将某个jar加入到bootstrapclasspath里作为高优先级被bootstrapClassloader加载</li>
<li>将某个jar加入到classpath里供AppClassloard去加载</li>
<li>设置某些native方法的前缀，主要在查找native方法的时候做规则匹配</li>
</ul>
</li>
</ul>


<p>想象一下可以让程序按照我们预期的逻辑去执行，听起来是不是挺酷的。</p>

<h2>JVMTI</h2>

<p><a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">JVMTI</a>全称JVM Tool Interface，是jvm暴露出来的一些供用户扩展的接口集合，JVMTI是基于事件驱动的，JVM每执行到一定的逻辑就会调用一些事件的回调接口（如果有的话），这些接口可以供开发者去扩展自己的逻辑。</p>

<p>比如说我们最常见的想在某个类的字节码文件读取之后类定义之前能修改相关的字节码，从而使创建的class对象是我们修改之后的字节码内容，那我们就可以实现一个回调函数赋给JvmtiEnv（JVMTI的运行时，通常一个JVMTIAgent对应一个jvmtiEnv，但是也可以对应多个）的回调方法集合里的ClassFileLoadHook，这样在接下来的类文件加载过程中都会调用到这个函数里来了，大致实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jvmtiEventCallbacks callbacks;
</span><span class='line'>jvmtiEnv *          jvmtienv = jvmti(agent);
</span><span class='line'>jvmtiError          jvmtierror;
</span><span class='line'>memset(&callbacks, 0, sizeof(callbacks));
</span><span class='line'>callbacks.ClassFileLoadHook = &eventHandlerClassFileLoadHook;
</span><span class='line'>jvmtierror = (*jvmtienv)-&gt;SetEventCallbacks( jvmtienv,
</span><span class='line'>                                             &callbacks,
</span><span class='line'>                                             sizeof(callbacks));</span></code></pre></td></tr></table></div></figure>


<h2>JVMTIAgent</h2>

<p>JVMTIAgent其实就是一个动态库，利用JVMTI暴露出来的一些接口来干一些我们想做但是正常情况下又做不到的事情，不过为了和普通的动态库进行区分，它一般会实现如下的一个或者多个函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JNIEXPORT jint JNICALL
</span><span class='line'>Agent_OnLoad(JavaVM *vm, char *options, void *reserved);
</span><span class='line'>
</span><span class='line'>JNIEXPORT jint JNICALL
</span><span class='line'>Agent_OnAttach(JavaVM* vm, char* options, void* reserved);
</span><span class='line'>
</span><span class='line'>JNIEXPORT void JNICALL
</span><span class='line'>Agent_OnUnload(JavaVM *vm); 
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>Agent_OnLoad</code>函数，如果agent是在启动的时候加载的，也就是在vm参数里通过-agentlib来指定，那在启动过程中就会去执行这个agent里的<code>Agent_OnLoad</code>函数。</li>
<li><code>Agent_OnAttach</code>函数，如果agent不是在启动的时候加载的，是我们先attach到目标进程上，然后给对应的目标进程发送load命令来加载agent，在加载过程中就会调用<code>Agent_OnAttach</code>函数。</li>
<li><code>Agent_OnUnload</code>函数，在agent做卸载的时候调用，不过貌似基本上很少实现它。</li>
</ul>


<p>其实我们每天都在和JVMTIAgent打交道，只是你可能没有意识到而已，比如我们经常使用eclipse等工具对java代码做调试，其实就利用了jre自带的jdwp agent来实现的，只是由于eclipse等工具在没让你察觉的情况下将相关参数(类似<code>-agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:61349</code>)给自动加到程序启动参数列表里了，其中agentlib参数就是用来跟要加载的agent的名字，比如这里的jdwp(不过这不是动态库的名字，而JVM是会做一些名称上的扩展，比如在linux下会去找<code>libjdwp.so</code>的动态库进行加载，也就是在名字的基础上加前缀<code>lib</code>,再加后缀<code>.so</code>)，接下来会跟一堆相关的参数，会将这些参数传给<code>Agent_OnLoad</code>或者<code>Agent_OnAttach</code>函数里对应的<code>options</code>参数。</p>

<h2>javaagent</h2>

<p>说到javaagent必须要讲的是一个叫做instrument的JVMTIAgent（linux下对应的动态库是libinstrument.so），因为就是它来实现javaagent的功能的，另外instrument agent还有个别名叫JPLISAgent(Java Programming Language Instrumentation Services Agent)，从这名字里也完全体现了其最本质的功能：就是专门为java语言编写的插桩服务提供支持的。</p>

<h3>instrument agent</h3>

<p>instrument agent实现了<code>Agent_OnLoad</code>和<code>Agent_OnAttach</code>两方法，也就是说我们在用它的时候既支持启动的时候来加载agent，也支持在运行期来动态来加载这个agent，其中启动时加载agent还可以通过类似<code>-javaagent:myagent.jar</code>的方式来间接加载instrument agent，运行期动态加载agent依赖的是jvm的attach机制<a href="http://lovestblog.cn/blog/2014/06/18/jvm-attach/">JVM Attach机制实现</a>，通过发送load命令来加载agent。</p>

<p>instrument agent的核心数据结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct _JPLISAgent {
</span><span class='line'>    JavaVM *                mJVM;                   /* handle to the JVM */
</span><span class='line'>    JPLISEnvironment        mNormalEnvironment;     /* for every thing but retransform stuff */
</span><span class='line'>    JPLISEnvironment        mRetransformEnvironment;/* for retransform stuff only */
</span><span class='line'>    jobject                 mInstrumentationImpl;   /* handle to the Instrumentation instance */
</span><span class='line'>    jmethodID               mPremainCaller;         /* method on the InstrumentationImpl that does the premain stuff (cached to save lots of lookups) */
</span><span class='line'>    jmethodID               mAgentmainCaller;       /* method on the InstrumentationImpl for agents loaded via attach mechanism */
</span><span class='line'>    jmethodID               mTransform;             /* method on the InstrumentationImpl that does the class file transform */
</span><span class='line'>    jboolean                mRedefineAvailable;     /* cached answer to "does this agent support redefine" */
</span><span class='line'>    jboolean                mRedefineAdded;         /* indicates if can_redefine_classes capability has been added */
</span><span class='line'>    jboolean                mNativeMethodPrefixAvailable; /* cached answer to "does this agent support prefixing" */
</span><span class='line'>    jboolean                mNativeMethodPrefixAdded;     /* indicates if can_set_native_method_prefix capability has been added */
</span><span class='line'>    char const *            mAgentClassName;        /* agent class name */
</span><span class='line'>    char const *            mOptionsString;         /* -javaagent options string */
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct _JPLISEnvironment {
</span><span class='line'>    jvmtiEnv *              mJVMTIEnv;              /* the JVM TI environment */
</span><span class='line'>    JPLISAgent *            mAgent;                 /* corresponding agent */
</span><span class='line'>    jboolean                mIsRetransformer;       /* indicates if special environment */
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<p>这里解释下几个重要项：
* mNormalEnvironment：主要提供正常的类transform及redefine功能的。
* mRetransformEnvironment：主要提供类retransform功能的。
* mInstrumentationImpl：这个对象非常重要，也是我们java agent和JVM进行交互的入口，或许写过javaagent的人在写<code>premain</code>以及<code>agentmain</code>方法的时候注意到了有个Instrumentation的参数，这个参数其实就是这里的对象。
* mPremainCaller：指向<code>sun.instrument.InstrumentationImpl.loadClassAndCallPremain</code>方法，如果agent是在启动的时候加载的，那该方法会被调用。
* mAgentmainCaller：指向<code>sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain</code>方法，该方法在通过attach的方式动态加载agent的时候调用。
* mTransform：指向<code>sun.instrument.InstrumentationImpl.transform</code>方法。
* mAgentClassName：在我们javaagent的MANIFEST.MF里指定的<code>Agent-Class</code>。
* mOptionsString：传给agent的一些参数。
* mRedefineAvailable：是否开启了redefine功能，在javaagent的MANIFEST.MF里设置<code>Can-Redefine-Classes:true</code>。
* mNativeMethodPrefixAvailable：是否支持native方法前缀设置，通样在javaagent的MANIFEST.MF里设置<code>Can-Set-Native-Method-Prefix:true</code>。
* mIsRetransformer：如果在javaagent的MANIFEST.MF文件里定义了<code>Can-Retransform-Classes:true</code>，那将会设置mRetransformEnvironment的mIsRetransformer为true。</p>

<h3>启动时加载instrument agent</h3>

<p>正如『概述』里提到的方式，就是启动的时候加载instrument agent，具体过程都在<code>InvocationAdapter.c</code>的<code>Agent_OnLoad</code>方法里，简单描述下过程：</p>

<ul>
<li>创建并初始化JPLISAgent</li>
<li>监听VMInit事件，在vm初始化完成之后做下面的事情：

<ul>
<li>创建InstrumentationImpl对象</li>
<li>监听ClassFileLoadHook事件</li>
<li>调用InstrumentationImpl的<code>loadClassAndCallPremain</code>方法，在这个方法里会去调用javaagent里MANIFEST.MF里指定的<code>Premain-Class</code>类的premain方法</li>
</ul>
</li>
<li>解析javaagent里MANIFEST.MF里的参数，并根据这些参数来设置JPLISAgent里的一些内容</li>
</ul>


<h3>运行时加载instrument agent</h3>

<p>运行时加载的方式，大致按照下面的方式来操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>VirtualMachine vm = VirtualMachine.attach(pid);
</span><span class='line'>vm.loadAgent(agentPath, agentArgs);</span></code></pre></td></tr></table></div></figure>


<p>上面会通过jvm的attach机制来请求目标jvm加载对应的agent，过程大致如下：</p>

<ul>
<li>创建并初始化JPLISAgent</li>
<li>解析javaagent里MANIFEST.MF里的参数</li>
<li>创建InstrumentationImpl对象</li>
<li>监听ClassFileLoadHook事件</li>
<li>调用InstrumentationImpl的<code>loadClassAndCallAgentmain</code>方法，在这个方法里会去调用javaagent里MANIFEST.MF里指定的<code>Agent-Class</code>类的<code>agentmain</code>方法</li>
</ul>


<h3>instrument agent的ClassFileLoadHook回调实现</h3>

<p>不管是启动时还是运行时加载的instrument agent都关注着同一个jvmti事件&#8212;<code>ClassFileLoadHook</code>，这个事件是在读取字节码文件之后回调时用的，这样可以对原来的字节码做修改，那这里面究竟是怎样实现的呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void JNICALL
</span><span class='line'>eventHandlerClassFileLoadHook(  jvmtiEnv *              jvmtienv,
</span><span class='line'>                                JNIEnv *                jnienv,
</span><span class='line'>                                jclass                  class_being_redefined,
</span><span class='line'>                                jobject                 loader,
</span><span class='line'>                                const char*             name,
</span><span class='line'>                                jobject                 protectionDomain,
</span><span class='line'>                                jint                    class_data_len,
</span><span class='line'>                                const unsigned char*    class_data,
</span><span class='line'>                                jint*                   new_class_data_len,
</span><span class='line'>                                unsigned char**         new_class_data) {
</span><span class='line'>    JPLISEnvironment * environment  = NULL;
</span><span class='line'>
</span><span class='line'>    environment = getJPLISEnvironment(jvmtienv);
</span><span class='line'>
</span><span class='line'>    /* if something is internally inconsistent (no agent), just silently return without touching the buffer */
</span><span class='line'>    if ( environment != NULL ) {
</span><span class='line'>        jthrowable outstandingException = preserveThrowable(jnienv);
</span><span class='line'>        transformClassFile( environment-&gt;mAgent,
</span><span class='line'>                            jnienv,
</span><span class='line'>                            loader,
</span><span class='line'>                            name,
</span><span class='line'>                            class_being_redefined,
</span><span class='line'>                            protectionDomain,
</span><span class='line'>                            class_data_len,
</span><span class='line'>                            class_data,
</span><span class='line'>                            new_class_data_len,
</span><span class='line'>                            new_class_data,
</span><span class='line'>                            environment-&gt;mIsRetransformer);
</span><span class='line'>        restoreThrowable(jnienv, outstandingException);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>先根据jvmtiEnv取得对应的JPLISEnvironment，因为上面我已经说到其实有两个JPLISEnvironment（并且有两个jvmtiEnv），其中一个专门做retransform的，而另外一个用来做其他的事情，根据不同的用途我们在注册具体的ClassFileTransformer的时候也是分开的，对于作为retransform用的ClassFileTransformer我们会注册到一个单独的TransformerManager里。</p>

<p>接着调用transformClassFile方法，由于函数实现比较长，我这里就不贴代码了，大致意思就是调用InstrumentationImpl对象的transform方法，根据最后那个参数来决定选哪个TransformerManager里的ClassFileTransformer对象们做transform操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> private byte[]
</span><span class='line'>    transform(  ClassLoader         loader,
</span><span class='line'>                String              classname,
</span><span class='line'>                Class               classBeingRedefined,
</span><span class='line'>                ProtectionDomain    protectionDomain,
</span><span class='line'>                byte[]              classfileBuffer,
</span><span class='line'>                boolean             isRetransformer) {
</span><span class='line'>        TransformerManager mgr = isRetransformer?
</span><span class='line'>                                        mRetransfomableTransformerManager :
</span><span class='line'>                                        mTransformerManager;
</span><span class='line'>        if (mgr == null) {
</span><span class='line'>            return null; // no manager, no transform
</span><span class='line'>        } else {
</span><span class='line'>            return mgr.transform(   loader,
</span><span class='line'>                                    classname,
</span><span class='line'>                                    classBeingRedefined,
</span><span class='line'>                                    protectionDomain,
</span><span class='line'>                                    classfileBuffer);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>  public byte[]
</span><span class='line'>    transform(  ClassLoader         loader,
</span><span class='line'>                String              classname,
</span><span class='line'>                Class               classBeingRedefined,
</span><span class='line'>                ProtectionDomain    protectionDomain,
</span><span class='line'>                byte[]              classfileBuffer) {
</span><span class='line'>        boolean someoneTouchedTheBytecode = false;
</span><span class='line'>
</span><span class='line'>        TransformerInfo[]  transformerList = getSnapshotTransformerList();
</span><span class='line'>
</span><span class='line'>        byte[]  bufferToUse = classfileBuffer;
</span><span class='line'>
</span><span class='line'>        // order matters, gotta run 'em in the order they were added
</span><span class='line'>        for ( int x = 0; x &lt; transformerList.length; x++ ) {
</span><span class='line'>            TransformerInfo         transformerInfo = transformerList[x];
</span><span class='line'>            ClassFileTransformer    transformer = transformerInfo.transformer();
</span><span class='line'>            byte[]                  transformedBytes = null;
</span><span class='line'>
</span><span class='line'>            try {
</span><span class='line'>                transformedBytes = transformer.transform(   loader,
</span><span class='line'>                                                            classname,
</span><span class='line'>                                                            classBeingRedefined,
</span><span class='line'>                                                            protectionDomain,
</span><span class='line'>                                                            bufferToUse);
</span><span class='line'>            }
</span><span class='line'>            catch (Throwable t) {
</span><span class='line'>                // don't let any one transformer mess it up for the others.
</span><span class='line'>                // This is where we need to put some logging. What should go here? FIXME
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            if ( transformedBytes != null ) {
</span><span class='line'>                someoneTouchedTheBytecode = true;
</span><span class='line'>                bufferToUse = transformedBytes;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // if someone modified it, return the modified buffer.
</span><span class='line'>        // otherwise return null to mean "no transforms occurred"
</span><span class='line'>        byte [] result;
</span><span class='line'>        if ( someoneTouchedTheBytecode ) {
</span><span class='line'>            result = bufferToUse;
</span><span class='line'>        }
</span><span class='line'>        else {
</span><span class='line'>            result = null;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        return result;
</span><span class='line'>    }   </span></code></pre></td></tr></table></div></figure>


<p>以上是最终调到的java代码，可以看到已经调用到我们自己编写的javaagent代码里了，我们一般是实现一个ClassFileTransformer类，然后创建一个对象注册了对应的TransformerManager里。</p>

<h2>Class Transform的实现</h2>

<p>这里说的class transform其实是狭义的，主要是针对第一次类文件加载的时候就要求被transform的场景，在加载类文件的时候发出ClassFileLoad的事件，然后交给instrumenat agent来调用javaagent里注册的ClassFileTransformer实现字节码的修改。</p>

<h2>Class Redefine的实现</h2>

<p>类重新定义，这是Instrumentation提供的基础功能之一，主要用在已经被加载过的类上，想对其进行修改，要做这件事，我们必须要知道两个东西，一个是要修改哪个类，另外一个是那个类你想修改成怎样的结构，有了这两信息之后于是你就可以通过InstrumentationImpl的下面的redefineClasses方法去操作了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void
</span><span class='line'>    redefineClasses(ClassDefinition[]   definitions)
</span><span class='line'>            throws  ClassNotFoundException {
</span><span class='line'>        if (!isRedefineClassesSupported()) {
</span><span class='line'>            throw new UnsupportedOperationException("redefineClasses is not supported in this environment");
</span><span class='line'>        }
</span><span class='line'>        if (definitions == null) {
</span><span class='line'>            throw new NullPointerException("null passed as 'definitions' in redefineClasses");
</span><span class='line'>        }
</span><span class='line'>        for (int i = 0; i &lt; definitions.length; ++i) {
</span><span class='line'>            if (definitions[i] == null) {
</span><span class='line'>                throw new NullPointerException("element of 'definitions' is null in redefineClasses");
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        if (definitions.length == 0) {
</span><span class='line'>            return; // short-circuit if there are no changes requested
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        redefineClasses0(mNativeAgent, definitions);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>在JVM里对应的实现是创建一个<code>VM_RedefineClasses</code>的<code>VM_Operation</code>，注意执行它的时候会stop the world的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jvmtiError
</span><span class='line'>JvmtiEnv::RedefineClasses(jint class_count, const jvmtiClassDefinition* class_definitions) {
</span><span class='line'>//TODO: add locking
</span><span class='line'>  VM_RedefineClasses op(class_count, class_definitions, jvmti_class_load_kind_redefine);
</span><span class='line'>  VMThread::execute(&op);
</span><span class='line'>  return (op.check_error());
</span><span class='line'>} /* end RedefineClasses */</span></code></pre></td></tr></table></div></figure>


<p>这个过程我尽量用语言来描述清楚，不详细贴代码了，因为代码量实在有点大：</p>

<ul>
<li>挨个遍历要批量重定义的jvmtiClassDefinition</li>
<li>然后读取新的字节码，如果有关注ClassFileLoadHook事件的，还会走对应的transform来对新的字节码再做修改</li>
<li>字节码解析好，创建一个klassOop对象</li>
<li>对比新老类，并要求如下：

<ul>
<li>父类是同一个</li>
<li>实现的接口数也要相同，并且是相同的接口</li>
<li>类访问符必须一致</li>
<li>字段数和字段名要一致</li>
<li>新增或删除的方法必须是private static/final的</li>
<li>可以修改方法</li>
</ul>
</li>
<li>对新类做字节码校验</li>
<li>合并新老类的常量池</li>
<li>如果老类上有断点，那都清除掉</li>
<li>对老类做jit去优化</li>
<li>对新老方法匹配的方法的jmethodid做更新，将老的jmethodId更新到新的method上</li>
<li>新类的常量池的holer指向老的类</li>
<li>将新类和老类的一些属性做交换，比如常量池，methods，内部类</li>
<li>初始化新的vtable和itable</li>
<li>交换annotation的method,field,paramenter</li>
<li>遍历所有当前类的子类，修改他们的vtable及itable</li>
</ul>


<p>上面是基本的过程，总的来说就是只更新了类里内容，相当于只更新了指针指向的内容，并没有更新指针，避免了遍历大量已有类对象对它们进行更新带来的开销。</p>

<h2>Class Retransform的实现</h2>

<p>retransform class可以简单理解为回滚操作，具体回滚到哪个版本，这个需要看情况而定，下面不管那种情况都有一个前提，那就是javaagent已经要求要有retransform的能力了：</p>

<ul>
<li>如果类是在第一次加载的的时候就做了transform，那么做retransform的时候会将代码回滚到transform之后的代码</li>
<li>如果类是在第一次加载的的时候没有任何变化，那么做retransform的时候会将代码回滚到最原始的类文件里的字节码</li>
<li>如果类已经被加载了，期间类可能做过多次redefine(比如被另外一个agent做过)，但是接下来加载一个新的agent要求有retransform的能力了，然后对类做redefine的动作，那么retransform的时候会将代码回滚到上一个agent最后一次做redefine后的字节码</li>
</ul>


<p>我们从InstrumentationImpl的<code>retransformClasses</code>方法参数看猜到应该是做回滚操作，因为我们只指定了class</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void
</span><span class='line'>retransformClasses(Class&lt;?&gt;[] classes) {
</span><span class='line'>    if (!isRetransformClassesSupported()) {
</span><span class='line'>        throw new UnsupportedOperationException(
</span><span class='line'>          "retransformClasses is not supported in this environment");
</span><span class='line'>    }
</span><span class='line'>    retransformClasses0(mNativeAgent, classes);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>不过retransform的实现其实也是通过redefine的功能来实现，在类加载的时候有比较小的差别，主要体现在究竟会走哪些transform上，如果当前是做retransform的话，那将忽略那些注册到正常的TransformerManager里的ClassFileTransformer，而只会走专门为retransform而准备的TransformerManager的ClassFileTransformer，不然想象一下字节码又被无声无息改成某个中间态了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private:
</span><span class='line'>  void post_all_envs() {
</span><span class='line'>    if (_load_kind != jvmti_class_load_kind_retransform) {
</span><span class='line'>      // for class load and redefine,
</span><span class='line'>      // call the non-retransformable agents
</span><span class='line'>      JvmtiEnvIterator it;
</span><span class='line'>      for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
</span><span class='line'>        if (!env-&gt;is_retransformable() && env-&gt;is_enabled(JVMTI_EVENT_CLASS_FILE_LOAD_HOOK)) {
</span><span class='line'>          // non-retransformable agents cannot retransform back,
</span><span class='line'>          // so no need to cache the original class file bytes
</span><span class='line'>          post_to_env(env, false);
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    JvmtiEnvIterator it;
</span><span class='line'>    for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {
</span><span class='line'>      // retransformable agents get all events
</span><span class='line'>      if (env-&gt;is_retransformable() && env-&gt;is_enabled(JVMTI_EVENT_CLASS_FILE_LOAD_HOOK)) {
</span><span class='line'>        // retransformable agents need to cache the original class file
</span><span class='line'>        // bytes if changes are made via the ClassFileLoadHook
</span><span class='line'>        post_to_env(env, true);
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h2>javaagent的其他小众功能</h2>

<p>javaagent除了做字节码上面的修改之外，其实还有一些小功能，有时候还是挺有用的</p>

<ul>
<li>获取所有已经被加载的类</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     Class[] getAllLoadedClasses();</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取所有已经被初始化过了的类</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Class[] getInitiatedClasses(ClassLoader loader);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取某个对象的大小</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  long getObjectSize(Object objectToSize);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将某个jar加入到bootstrapclasspath里优先其他jar被加载</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void appendToBootstrapClassLoaderSearch(JarFile jarfile);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将某个jar加入到classpath里供appclassloard去加载</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void appendToSystemClassLoaderSearch(JarFile jarfile);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置某些native方法的前缀，主要在找native方法的时候做规则匹配</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进程物理内存远大于Xmx的问题分析]]></title>
    <link href="http://nijiaben.github.io/blog/2015/08/21/rssxmx/"/>
    <updated>2015-08-21T18:58:53+08:00</updated>
    <id>http://nijiaben.github.io/blog/2015/08/21/rssxmx</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>最近经常被问到一个问题，&#8221;为什么我们系统进程占用的物理内存(Res/Rss)会远远大于设置的Xmx值&#8221;，比如Xmx设置1.7G，但是top看到的Res的值却达到了3.0G，随着进程的运行，Res的值还在递增，直到达到某个值，被OS当做bad process直接被kill掉了。</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>top - 16:57:47 up 73 days,  4:12,  8 users,  load average: 6.78, 9.68, 13.31
</span><span class='line'>Tasks: 130 total,   1 running, 123 sleeping,   6 stopped,   0 zombie
</span><span class='line'>Cpu(s): 89.9%us,  5.6%sy,  0.0%ni,  2.0%id,  0.7%wa,  0.7%hi,  1.2%si,  0.0%st
</span><span class='line'>  ...
</span><span class='line'>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
</span><span class='line'>22753 admin     20   0 4252m 3.0g  17m S 192.8 52.7 151:47.59 /opt/taobao/java/bin/java -server -Xms1700m -Xmx1700m -Xmn680m -Xss256k -XX:PermSize=128m -XX:MaxPermSize=128m -XX:+UseStringCache -XX:+
</span><span class='line'>   40 root      20   0     0    0    0 D  0.3  0.0   5:53.07 [kswapd0]</span></code></pre></td></tr></table></div></figure>


<h2>物理内存大于Xmx可能吗</h2>

<p>先说下Xmx，这个vm配置只包括我们熟悉的新生代和老生代的最大值，不包括持久代，也不包括CodeCache，还有我们常听说的堆外内存从名字上一看也知道没有包括在内，当然还有其他内存也不会算在内等，因此理论上我们看到物理内存大于Xmx也是可能的，不过超过太多估计就可能有问题了。</p>

<h2>物理内存和虚拟内存间的映射关系</h2>

<p>我们知道os在内存上面的设计是花了心思的，为了让资源得到最大合理利用，在物理内存之上搞一层虚拟地址，同一台机器上每个进程可访问的虚拟地址空间大小都是一样的，为了屏蔽掉复杂的到物理内存的映射，该工作os直接做了，当需要物理内存的时候，当前虚拟地址又没有映射到物理内存上的时候，就会发生缺页中断，由内核去为之准备一块物理内存，所以即使我们分配了一块1G的虚拟内存，物理内存上不一定有一块1G的空间与之对应，那到底这块虚拟内存块到底映射了多少物理内存呢，这个我们在linux下可以通过<code>/proc/&lt;pid&gt;/smaps</code>这个文件看到，其中的Size表示虚拟内存大小，而Rss表示的是物理内存，所以从这层意义上来说和虚拟内存块对应的物理内存块不应该超过此虚拟内存块的空间范围</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>8dc00000-100000000 rwxp 00000000 00:00 0
</span><span class='line'>Size:            1871872 kB
</span><span class='line'>Rss:             1798444 kB
</span><span class='line'>Pss:             1798444 kB
</span><span class='line'>Shared_Clean:          0 kB
</span><span class='line'>Shared_Dirty:          0 kB
</span><span class='line'>Private_Clean:         0 kB
</span><span class='line'>Private_Dirty:   1798444 kB
</span><span class='line'>Referenced:      1798392 kB
</span><span class='line'>Anonymous:       1798444 kB
</span><span class='line'>AnonHugePages:         0 kB
</span><span class='line'>Swap:                  0 kB
</span><span class='line'>KernelPageSize:        4 kB
</span><span class='line'>MMUPageSize:           4 kB</span></code></pre></td></tr></table></div></figure>


<p>此次为了排查这个问题，我特地写了个简单的分析工具来分析这个问题，将连续的虚拟内存块合并做统计，一般来说连续分配的内存块还是有一定关系的，当然也不能完全肯定这种关系，得到的效果大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from-&gt;to  vs rss rss_percentage(rss/total_rss) merge_block_count
</span><span class='line'>
</span><span class='line'>0x8dc00000-&gt;0x30c9a20000      1871872      1487480      53.77%     1
</span><span class='line'>0x7faf7a4c5000-&gt;0x7fffa7dd9000      1069464      735996      26.60%     440
</span><span class='line'>0x7faf50c75000-&gt;0x7faf6c02a000      445996      226860      8.20%     418
</span><span class='line'>0x7faf6c027000-&gt;0x7faf78010000      196452      140640      5.08%     492
</span><span class='line'>0x418e8000-&gt;0x100000000      90968      90904      3.29%     1
</span><span class='line'>0x7faf48000000-&gt;0x7faf50c78000      131072      35120      1.27%     4
</span><span class='line'>0x7faf28000000-&gt;0x7faf3905e000      196608      20708      0.75%     6
</span><span class='line'>0x7faf38000000-&gt;0x7faf4ad83000      196608      17036      0.62%     6
</span><span class='line'>0x7faf78009000-&gt;0x7faf7a4c6000      37612      10440      0.38%     465
</span><span class='line'>0x30c9e00000-&gt;0x30ca202000      3656      716      0.03%     5
</span><span class='line'>0x7faf20000000-&gt;0x7faf289c7000      65536      132      0.00%     2
</span><span class='line'>0x30c9a00000-&gt;0x30c9c20000      128      108      0.00%     1
</span><span class='line'>0x30ca600000-&gt;0x30cae83000      2164      76      0.00%     5
</span><span class='line'>0x30cbe00000-&gt;0x30cca16000      2152      68      0.00%     5
</span><span class='line'>0x7fffa7dc3000-&gt;0x7fffa7e00000      92      48      0.00%     1
</span><span class='line'>0x30cca00000-&gt;0x7faf21dba000      2148      32      0.00%     5
</span><span class='line'>0x30cb200000-&gt;0x30cbe16000      2080      28      0.00%     4
</span><span class='line'>0x30cae00000-&gt;0x30cb207000      2576      20      0.00%     4
</span><span class='line'>0x30ca200000-&gt;0x30ca617000      2064      16      0.00%     4
</span><span class='line'>0x40000000-&gt;0x4010a000      36      12      0.00%     2
</span><span class='line'>0x30c9c1f000-&gt;0x30c9f89000      12      12      0.00%     3
</span><span class='line'>0x40108000-&gt;0x471be000      8      8      0.00%     1
</span><span class='line'>0x7fffa7dff000-&gt;0x0      4      4      0.00%     0</span></code></pre></td></tr></table></div></figure>


<p>当然这只是一个简单的分析，如果更有价值需要我们挖掘更多的点出来，比如每个内存块是属于哪块memory pool，到底是什么地方分配的等，不过需要jvm支持(<code>注：上面的第一条，其实就是new+old+perm对应的虚拟内存及其物理内存映射情况</code>)。</p>

<h2>进程满足什么条件会被os因为oom而被kill</h2>

<p>当一个进程无故消失的时候，我们一般看<code>/var/log/message</code>里是否有<code>Out of memory: Kill process</code>关键字(如果是java进程我们先看是否有crash日志)，如果有就说明是被os因为oom而被kill了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238016] java invoked oom-killer: gfp_mask=0x201da, order=0, oom_adj=0, oom_score_adj=0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238022] java cpuset=/ mems_allowed=0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238024] Pid: 25371, comm: java Not tainted 2.6.32-220.23.2.ali878.el6.x86_64 #1
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238026] Call Trace:
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238039]  [&lt;ffffffff810c35e1&gt;] ? cpuset_print_task_mems_allowed+0x91/0xb0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238068]  [&lt;ffffffff81114d70&gt;] ? dump_header+0x90/0x1b0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238074]  [&lt;ffffffff810e1b2e&gt;] ? __delayacct_freepages_end+0x2e/0x30
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238079]  [&lt;ffffffff81213ffc&gt;] ? security_real_capable_noaudit+0x3c/0x70
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238082]  [&lt;ffffffff811151fa&gt;] ? oom_kill_process+0x8a/0x2c0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238084]  [&lt;ffffffff81115131&gt;] ? select_bad_process+0xe1/0x120
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238087]  [&lt;ffffffff81115650&gt;] ? out_of_memory+0x220/0x3c0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238093]  [&lt;ffffffff81125929&gt;] ? __alloc_pages_nodemask+0x899/0x930
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238099]  [&lt;ffffffff81159b6a&gt;] ? alloc_pages_current+0xaa/0x110
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238102]  [&lt;ffffffff81111ea7&gt;] ? __page_cache_alloc+0x87/0x90
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238105]  [&lt;ffffffff81127f4b&gt;] ? __do_page_cache_readahead+0xdb/0x270
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238108]  [&lt;ffffffff81128101&gt;] ? ra_submit+0x21/0x30
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238110]  [&lt;ffffffff81113e17&gt;] ? filemap_fault+0x5b7/0x600
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238113]  [&lt;ffffffff8113ca64&gt;] ? __do_fault+0x54/0x510
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238116]  [&lt;ffffffff811140a0&gt;] ? __generic_file_aio_write+0x240/0x470
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238118]  [&lt;ffffffff8113d017&gt;] ? handle_pte_fault+0xf7/0xb50
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238121]  [&lt;ffffffff8111438e&gt;] ? generic_file_aio_write+0xbe/0xe0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238133]  [&lt;ffffffffa008a171&gt;] ? ext4_file_write+0x61/0x1e0 [ext4]
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238135]  [&lt;ffffffff8113dc54&gt;] ? handle_mm_fault+0x1e4/0x2b0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238138]  [&lt;ffffffff81177c7a&gt;] ? do_sync_write+0xfa/0x140
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238143]  [&lt;ffffffff81042c69&gt;] ? __do_page_fault+0x139/0x480
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238147]  [&lt;ffffffff8118ad22&gt;] ? vfs_ioctl+0x22/0xa0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238151]  [&lt;ffffffff814e4f8e&gt;] ? do_page_fault+0x3e/0xa0
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.238154]  [&lt;ffffffff814e2345&gt;] ? page_fault+0x25/0x30
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247969] [24673]  1801 24673  1280126   926068   1       0             0 java
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247971] [25084]  1801 25084     3756      101   0       0             0 top
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247973] [25094]  1801 25094    25233       30   1       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247975] [25098]  1801 25098    25233       31   0       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247977] [25100]  1801 25100    25233       30   1       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247979] [25485]  1801 25485    25233       30   1       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247981] [26055]  1801 26055    25233       30   0       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247984] [26069]  1801 26069    25233       30   0       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247986] [26081]  1801 26081    25233       30   0       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247988] [26147]  1801 26147    25233       32   0       0             0 tail
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.247990] Out of memory: Kill process 24673 (java) score 946 or sacrifice child
</span><span class='line'>Aug 19 08:32:38 mybank-ant kernel: : [6176841.249016] Killed process 24673, UID 1801, (java) total-vm:5120504kB, anon-rss:3703788kB, file-rss:484kB</span></code></pre></td></tr></table></div></figure>


<p>从上面我们看到了一个堆栈，也就是内核里选择被kill进程的过程，这个过程会对进程进行一系列的计算，每个进程都会给它们计算一个score，这个分数会记录在<code>/proc/&lt;pid&gt;/oom_score</code>里，通常这个分数越高，就越危险，被kill的可能性就越大，下面将内核相关的代码贴出来，有兴趣的可以看看，其中代码注释上也写了挺多相关的东西了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*
</span><span class='line'> * Simple selection loop. We chose the process with the highest
</span><span class='line'> * number of 'points'. We expect the caller will lock the tasklist.
</span><span class='line'> *
</span><span class='line'> * (not docbooked, we don't want this one cluttering up the manual)
</span><span class='line'> */
</span><span class='line'>static struct task_struct *select_bad_process(unsigned long *ppoints,
</span><span class='line'>                      struct mem_cgroup *mem)
</span><span class='line'>{
</span><span class='line'>  struct task_struct *p;
</span><span class='line'>  struct task_struct *chosen = NULL;
</span><span class='line'>  struct timespec uptime;
</span><span class='line'>  *ppoints = 0;
</span><span class='line'>
</span><span class='line'>  do_posix_clock_monotonic_gettime(&uptime);
</span><span class='line'>  for_each_process(p) {
</span><span class='line'>      unsigned long points;
</span><span class='line'>
</span><span class='line'>      /*
</span><span class='line'>       * skip kernel threads and tasks which have already released
</span><span class='line'>       * their mm.
</span><span class='line'>       */
</span><span class='line'>      if (!p-&gt;mm)
</span><span class='line'>          continue;
</span><span class='line'>      /* skip the init task */
</span><span class='line'>      if (is_global_init(p))
</span><span class='line'>          continue;
</span><span class='line'>      if (mem && !task_in_mem_cgroup(p, mem))
</span><span class='line'>          continue;
</span><span class='line'>
</span><span class='line'>      /*
</span><span class='line'>       * This task already has access to memory reserves and is
</span><span class='line'>       * being killed. Don't allow any other task access to the
</span><span class='line'>       * memory reserve.
</span><span class='line'>       *
</span><span class='line'>       * Note: this may have a chance of deadlock if it gets
</span><span class='line'>       * blocked waiting for another task which itself is waiting
</span><span class='line'>       * for memory. Is there a better alternative?
</span><span class='line'>       */
</span><span class='line'>      if (test_tsk_thread_flag(p, TIF_MEMDIE))
</span><span class='line'>          return ERR_PTR(-1UL);
</span><span class='line'>
</span><span class='line'>      /*
</span><span class='line'>       * This is in the process of releasing memory so wait for it
</span><span class='line'>       * to finish before killing some other task by mistake.
</span><span class='line'>       *
</span><span class='line'>       * However, if p is the current task, we allow the 'kill' to
</span><span class='line'>       * go ahead if it is exiting: this will simply set TIF_MEMDIE,
</span><span class='line'>       * which will allow it to gain access to memory reserves in
</span><span class='line'>       * the process of exiting and releasing its resources.
</span><span class='line'>       * Otherwise we could get an easy OOM deadlock.
</span><span class='line'>       */
</span><span class='line'>      if (p-&gt;flags & PF_EXITING) {
</span><span class='line'>          if (p != current)
</span><span class='line'>              return ERR_PTR(-1UL);
</span><span class='line'>
</span><span class='line'>          chosen = p;
</span><span class='line'>          *ppoints = ULONG_MAX;
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      if (p-&gt;signal-&gt;oom_adj == OOM_DISABLE)
</span><span class='line'>          continue;
</span><span class='line'>
</span><span class='line'>      points = badness(p, uptime.tv_sec);
</span><span class='line'>      if (points &gt; *ppoints || !chosen) {
</span><span class='line'>          chosen = p;
</span><span class='line'>          *ppoints = points;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return chosen;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * badness - calculate a numeric value for how bad this task has been
</span><span class='line'> * @p: task struct of which task we should calculate
</span><span class='line'> * @uptime: current uptime in seconds
</span><span class='line'> *
</span><span class='line'> * The formula used is relatively simple and documented inline in the
</span><span class='line'> * function. The main rationale is that we want to select a good task
</span><span class='line'> * to kill when we run out of memory.
</span><span class='line'> *
</span><span class='line'> * Good in this context means that:
</span><span class='line'> * 1) we lose the minimum amount of work done
</span><span class='line'> * 2) we recover a large amount of memory
</span><span class='line'> * 3) we don't kill anything innocent of eating tons of memory
</span><span class='line'> * 4) we want to kill the minimum amount of processes (one)
</span><span class='line'> * 5) we try to kill the process the user expects us to kill, this
</span><span class='line'> *    algorithm has been meticulously tuned to meet the principle
</span><span class='line'> *    of least surprise ... (be careful when you change it)
</span><span class='line'> */
</span><span class='line'>
</span><span class='line'>unsigned long badness(struct task_struct *p, unsigned long uptime)
</span><span class='line'>{
</span><span class='line'>  unsigned long points, cpu_time, run_time;
</span><span class='line'>  struct mm_struct *mm;
</span><span class='line'>  struct task_struct *child;
</span><span class='line'>  int oom_adj = p-&gt;signal-&gt;oom_adj;
</span><span class='line'>  struct task_cputime task_time;
</span><span class='line'>  unsigned long utime;
</span><span class='line'>  unsigned long stime;
</span><span class='line'>
</span><span class='line'>  if (oom_adj == OOM_DISABLE)
</span><span class='line'>      return 0;
</span><span class='line'>
</span><span class='line'>  task_lock(p);
</span><span class='line'>  mm = p-&gt;mm;
</span><span class='line'>  if (!mm) {
</span><span class='line'>      task_unlock(p);
</span><span class='line'>      return 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * The memory size of the process is the basis for the badness.
</span><span class='line'>   */
</span><span class='line'>  points = mm-&gt;total_vm;
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * After this unlock we can no longer dereference local variable `mm'
</span><span class='line'>   */
</span><span class='line'>  task_unlock(p);
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * swapoff can easily use up all memory, so kill those first.
</span><span class='line'>   */
</span><span class='line'>  if (p-&gt;flags & PF_OOM_ORIGIN)
</span><span class='line'>      return ULONG_MAX;
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * Processes which fork a lot of child processes are likely
</span><span class='line'>   * a good choice. We add half the vmsize of the children if they
</span><span class='line'>   * have an own mm. This prevents forking servers to flood the
</span><span class='line'>   * machine with an endless amount of children. In case a single
</span><span class='line'>   * child is eating the vast majority of memory, adding only half
</span><span class='line'>   * to the parents will make the child our kill candidate of choice.
</span><span class='line'>   */
</span><span class='line'>  list_for_each_entry(child, &p-&gt;children, sibling) {
</span><span class='line'>      task_lock(child);
</span><span class='line'>      if (child-&gt;mm != mm && child-&gt;mm)
</span><span class='line'>          points += child-&gt;mm-&gt;total_vm/2 + 1;
</span><span class='line'>      task_unlock(child);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * CPU time is in tens of seconds and run time is in thousands
</span><span class='line'>         * of seconds. There is no particular reason for this other than
</span><span class='line'>         * that it turned out to work very well in practice.
</span><span class='line'>   */
</span><span class='line'>  thread_group_cputime(p, &task_time);
</span><span class='line'>  utime = cputime_to_jiffies(task_time.utime);
</span><span class='line'>  stime = cputime_to_jiffies(task_time.stime);
</span><span class='line'>  cpu_time = (utime + stime) &gt;&gt; (SHIFT_HZ + 3);
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  if (uptime &gt;= p-&gt;start_time.tv_sec)
</span><span class='line'>      run_time = (uptime - p-&gt;start_time.tv_sec) &gt;&gt; 10;
</span><span class='line'>  else
</span><span class='line'>      run_time = 0;
</span><span class='line'>
</span><span class='line'>  if (cpu_time)
</span><span class='line'>      points /= int_sqrt(cpu_time);
</span><span class='line'>  if (run_time)
</span><span class='line'>      points /= int_sqrt(int_sqrt(run_time));
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * Niced processes are most likely less important, so double
</span><span class='line'>   * their badness points.
</span><span class='line'>   */
</span><span class='line'>  if (task_nice(p) &gt; 0)
</span><span class='line'>      points *= 2;
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * Superuser processes are usually more important, so we make it
</span><span class='line'>   * less likely that we kill those.
</span><span class='line'>   */
</span><span class='line'>  if (has_capability_noaudit(p, CAP_SYS_ADMIN) ||
</span><span class='line'>      has_capability_noaudit(p, CAP_SYS_RESOURCE))
</span><span class='line'>      points /= 4;
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * We don't want to kill a process with direct hardware access.
</span><span class='line'>   * Not only could that mess up the hardware, but usually users
</span><span class='line'>   * tend to only have this flag set on applications they think
</span><span class='line'>   * of as important.
</span><span class='line'>   */
</span><span class='line'>  if (has_capability_noaudit(p, CAP_SYS_RAWIO))
</span><span class='line'>      points /= 4;
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * If p's nodes don't overlap ours, it may still help to kill p
</span><span class='line'>   * because p may have allocated or otherwise mapped memory on
</span><span class='line'>   * this node before. However it will be less likely.
</span><span class='line'>   */
</span><span class='line'>  if (!has_intersects_mems_allowed(p))
</span><span class='line'>      points /= 8;
</span><span class='line'>
</span><span class='line'>  /*
</span><span class='line'>   * Adjust the score by oom_adj.
</span><span class='line'>   */
</span><span class='line'>  if (oom_adj) {
</span><span class='line'>      if (oom_adj &gt; 0) {
</span><span class='line'>          if (!points)
</span><span class='line'>              points = 1;
</span><span class='line'>          points &lt;&lt;= oom_adj;
</span><span class='line'>      } else
</span><span class='line'>          points &gt;&gt;= -(oom_adj);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>  printk(KERN_DEBUG "OOMkill: task %d (%s) got %lu points\n",
</span><span class='line'>  p-&gt;pid, p-&gt;comm, points);
</span><span class='line'>#endif
</span><span class='line'>  return points;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>物理内存到底去哪了？</h2>

<h3>DirectByteBuffer冰山对象？</h3>

<p>这是我们查这个问题首先要想到的一个地方，是否是因为什么地方不断创建DirectByteBuffer对象，但是由于没有被回收导致了内存泄露呢，之前有篇文章已经详细介绍了这种特殊对象<a href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/">JVM源码分析之堆外内存完全解读</a>，对阿里内部的童鞋，可以直接使用zprofiler的heap视图里的堆外内存分析功能拿到统计结果，知道后台到底绑定了多少堆外内存还没有被回收：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>object   position    limit   capacity
</span><span class='line'> java.nio.DirectByteBuffer @ 0x760afaed0  133 133 6380562
</span><span class='line'> java.nio.DirectByteBuffer @ 0x790d51ae0  0   262144  262144
</span><span class='line'> java.nio.DirectByteBuffer @ 0x790d20b80  133934  133934  262144
</span><span class='line'> java.nio.DirectByteBuffer @ 0x790d20b40  0   262144  262144
</span><span class='line'> java.nio.DirectByteBuffer @ 0x790d20b00  133934  133934  262144
</span><span class='line'> java.nio.DirectByteBuffer @ 0x771ba3608  0   262144  262144
</span><span class='line'> java.nio.DirectByteBuffer @ 0x771ba35c8  133934  133934  262144
</span><span class='line'> java.nio.DirectByteBuffer @ 0x7c5c9e250  0   131072  131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x7c5c9e210  74670   74670   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x7c185cd10  0   131072  131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x7c185ccd0  98965   98965   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x7b181c980  65627   65627   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x7a40d6e40  0   131072  131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x794ac3320  0   131072  131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x794a7a418  80490   80490   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x77279e1d8  0   131072  131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x77279dde8  65627   65627   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x76ea84000  0   131072  131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x76ea83fc0  82549   82549   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x764d8d678  0   0   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x764d8d638  0   0   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x764d8d5f8  0   0   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x761a76340  0   131072  131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x761a76300  74369   74369   131072
</span><span class='line'> java.nio.DirectByteBuffer @ 0x7607423d0  0   131072  131072
</span><span class='line'> 总共: 25 / 875 条目; 还有850条,双击展开   1267762 3826551 12083282</span></code></pre></td></tr></table></div></figure>


<h3>某个动态库里频繁分配？</h3>

<p>对于动态库里频繁分配的问题，主要得使用google的perftools工具了，该工具网上介绍挺多的，就不对其用法做详细介绍了，通过该工具我们能得到native方法分配内存的情况，该工具主要利用了unix的一个环境变量LD_PRELOAD，它允许你要加载的动态库优先加载起来，相当于一个Hook了，于是可以针对同一个函数可以选择不同的动态库里的实现了，比如googleperftools就是将malloc方法替换成了tcmalloc的实现，这样就可以跟踪内存分配路径了，得到的效果类似如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Total: 1670.0 MB
</span><span class='line'>  1616.3  96.8%  96.8%   1616.3  96.8% zcalloc
</span><span class='line'>    40.3   2.4%  99.2%     40.3   2.4% os::malloc
</span><span class='line'>     9.4   0.6%  99.8%      9.4   0.6% init
</span><span class='line'>     1.6   0.1%  99.9%      1.7   0.1% readCEN
</span><span class='line'>     1.3   0.1%  99.9%      1.3   0.1% ObjectSynchronizer::omAlloc
</span><span class='line'>     0.5   0.0% 100.0%   1591.0  95.3% Java_java_util_zip_Deflater_init
</span><span class='line'>     0.1   0.0% 100.0%      0.1   0.0% _dl_allocate_tls
</span><span class='line'>     0.1   0.0% 100.0%      0.2   0.0% addMetaName
</span><span class='line'>     0.1   0.0% 100.0%      0.2   0.0% allocZip
</span><span class='line'>     0.1   0.0% 100.0%      0.1   0.0% instanceKlass::add_dependent_nmethod
</span><span class='line'>     0.1   0.0% 100.0%      0.1   0.0% newEntry
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% strdup
</span><span class='line'>     0.0   0.0% 100.0%     25.8   1.5% Java_java_util_zip_Inflater_init
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% growMetaNames
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% _dl_new_object
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% pthread_cond_wait@GLIBC_2.2.5
</span><span class='line'>     0.0   0.0% 100.0%      1.4   0.1% Thread::Thread
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% pthread_cond_timedwait@GLIBC_2.2.5
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% JLI_MemAlloc
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% read_alias_file
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% _nl_intern_locale_data
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% nss_parse_service_list
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% getprotobyname
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% getpwuid
</span><span class='line'>     0.0   0.0% 100.0%      0.0   0.0% _dl_check_map_versions
</span><span class='line'>     0.0   0.0% 100.0%   1590.5  95.2% deflateInit2_</span></code></pre></td></tr></table></div></figure>


<p>从上面的输出中我们看到了<code>zcalloc</code>函数总共分配了1616.3M的内存，还有<code>Java_java_util_zip_Deflater_init</code>分配了1591.0M内存，<code>deflateInit2_</code>分配了1590.5M，然而总共才分配了1670.0M内存，所以这几个函数肯定是调用者和被调用者的关系：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JNIEXPORT jlong JNICALL
</span><span class='line'>Java_java_util_zip_Deflater_init(JNIEnv *env, jclass cls, jint level,
</span><span class='line'>                                 jint strategy, jboolean nowrap)
</span><span class='line'>{
</span><span class='line'>    z_stream *strm = calloc(1, sizeof(z_stream));
</span><span class='line'>
</span><span class='line'>    if (strm == 0) {
</span><span class='line'>        JNU_ThrowOutOfMemoryError(env, 0);
</span><span class='line'>        return jlong_zero;
</span><span class='line'>    } else {
</span><span class='line'>        char *msg;
</span><span class='line'>        switch (deflateInit2(strm, level, Z_DEFLATED,
</span><span class='line'>                             nowrap ? -MAX_WBITS : MAX_WBITS,
</span><span class='line'>                             DEF_MEM_LEVEL, strategy)) {
</span><span class='line'>          case Z_OK:
</span><span class='line'>            return ptr_to_jlong(strm);
</span><span class='line'>          case Z_MEM_ERROR:
</span><span class='line'>            free(strm);
</span><span class='line'>            JNU_ThrowOutOfMemoryError(env, 0);
</span><span class='line'>            return jlong_zero;
</span><span class='line'>          case Z_STREAM_ERROR:
</span><span class='line'>            free(strm);
</span><span class='line'>            JNU_ThrowIllegalArgumentException(env, 0);
</span><span class='line'>            return jlong_zero;
</span><span class='line'>          default:
</span><span class='line'>            msg = strm-&gt;msg;
</span><span class='line'>            free(strm);
</span><span class='line'>            JNU_ThrowInternalError(env, msg);
</span><span class='line'>            return jlong_zero;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
</span><span class='line'>                  version, stream_size)
</span><span class='line'>    z_streamp strm;
</span><span class='line'>    int  level;
</span><span class='line'>    int  method;
</span><span class='line'>    int  windowBits;
</span><span class='line'>    int  memLevel;
</span><span class='line'>    int  strategy;
</span><span class='line'>    const char *version;
</span><span class='line'>    int stream_size;
</span><span class='line'>{
</span><span class='line'>    deflate_state *s;
</span><span class='line'>    int wrap = 1;
</span><span class='line'>    static const char my_version[] = ZLIB_VERSION;
</span><span class='line'>
</span><span class='line'>    ushf *overlay;
</span><span class='line'>    /* We overlay pending_buf and d_buf+l_buf. This works since the average
</span><span class='line'>     * output size for (length,distance) codes is &lt;= 24 bits.
</span><span class='line'>     */
</span><span class='line'>
</span><span class='line'>    if (version == Z_NULL || version[0] != my_version[0] ||
</span><span class='line'>        stream_size != sizeof(z_stream)) {
</span><span class='line'>        return Z_VERSION_ERROR;
</span><span class='line'>    }
</span><span class='line'>    if (strm == Z_NULL) return Z_STREAM_ERROR;
</span><span class='line'>
</span><span class='line'>    strm-&gt;msg = Z_NULL;
</span><span class='line'>    if (strm-&gt;zalloc == (alloc_func)0) {
</span><span class='line'>        strm-&gt;zalloc = zcalloc;
</span><span class='line'>        strm-&gt;opaque = (voidpf)0;
</span><span class='line'>    }
</span><span class='line'>    if (strm-&gt;zfree == (free_func)0) strm-&gt;zfree = zcfree;
</span><span class='line'>
</span><span class='line'>#ifdef FASTEST
</span><span class='line'>    if (level != 0) level = 1;
</span><span class='line'>#else
</span><span class='line'>    if (level == Z_DEFAULT_COMPRESSION) level = 6;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>    if (windowBits &lt; 0) { /* suppress zlib wrapper */
</span><span class='line'>        wrap = 0;
</span><span class='line'>        windowBits = -windowBits;
</span><span class='line'>    }
</span><span class='line'>#ifdef GZIP
</span><span class='line'>    else if (windowBits &gt; 15) {
</span><span class='line'>        wrap = 2;       /* write gzip wrapper instead */
</span><span class='line'>        windowBits -= 16;
</span><span class='line'>    }
</span><span class='line'>#endif
</span><span class='line'>    if (memLevel &lt; 1 || memLevel &gt; MAX_MEM_LEVEL || method != Z_DEFLATED ||
</span><span class='line'>        windowBits &lt; 8 || windowBits &gt; 15 || level &lt; 0 || level &gt; 9 ||
</span><span class='line'>        strategy &lt; 0 || strategy &gt; Z_FIXED) {
</span><span class='line'>        return Z_STREAM_ERROR;
</span><span class='line'>    }
</span><span class='line'>    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
</span><span class='line'>    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
</span><span class='line'>    if (s == Z_NULL) return Z_MEM_ERROR;
</span><span class='line'>    strm-&gt;state = (struct internal_state FAR *)s;
</span><span class='line'>    s-&gt;strm = strm;
</span><span class='line'>
</span><span class='line'>    s-&gt;wrap = wrap;
</span><span class='line'>    s-&gt;gzhead = Z_NULL;
</span><span class='line'>    s-&gt;w_bits = windowBits;
</span><span class='line'>    s-&gt;w_size = 1 &lt;&lt; s-&gt;w_bits;
</span><span class='line'>    s-&gt;w_mask = s-&gt;w_size - 1;
</span><span class='line'>
</span><span class='line'>    s-&gt;hash_bits = memLevel + 7;
</span><span class='line'>    s-&gt;hash_size = 1 &lt;&lt; s-&gt;hash_bits;
</span><span class='line'>    s-&gt;hash_mask = s-&gt;hash_size - 1;
</span><span class='line'>    s-&gt;hash_shift =  ((s-&gt;hash_bits+MIN_MATCH-1)/MIN_MATCH);
</span><span class='line'>
</span><span class='line'>    s-&gt;window = (Bytef *) ZALLOC(strm, s-&gt;w_size, 2*sizeof(Byte));
</span><span class='line'>    s-&gt;prev   = (Posf *)  ZALLOC(strm, s-&gt;w_size, sizeof(Pos));
</span><span class='line'>    s-&gt;head   = (Posf *)  ZALLOC(strm, s-&gt;hash_size, sizeof(Pos));
</span><span class='line'>
</span><span class='line'>    s-&gt;lit_bufsize = 1 &lt;&lt; (memLevel + 6); /* 16K elements by default */
</span><span class='line'>
</span><span class='line'>    overlay = (ushf *) ZALLOC(strm, s-&gt;lit_bufsize, sizeof(ush)+2);
</span><span class='line'>    s-&gt;pending_buf = (uchf *) overlay;
</span><span class='line'>    s-&gt;pending_buf_size = (ulg)s-&gt;lit_bufsize * (sizeof(ush)+2L);
</span><span class='line'>
</span><span class='line'>    if (s-&gt;window == Z_NULL || s-&gt;prev == Z_NULL || s-&gt;head == Z_NULL ||
</span><span class='line'>        s-&gt;pending_buf == Z_NULL) {
</span><span class='line'>        s-&gt;status = FINISH_STATE;
</span><span class='line'>        strm-&gt;msg = (char*)ERR_MSG(Z_MEM_ERROR);
</span><span class='line'>        deflateEnd (strm);
</span><span class='line'>        return Z_MEM_ERROR;
</span><span class='line'>    }
</span><span class='line'>    s-&gt;d_buf = overlay + s-&gt;lit_bufsize/sizeof(ush);
</span><span class='line'>    s-&gt;l_buf = s-&gt;pending_buf + (1+sizeof(ush))*s-&gt;lit_bufsize;
</span><span class='line'>
</span><span class='line'>    s-&gt;level = level;
</span><span class='line'>    s-&gt;strategy = strategy;
</span><span class='line'>    s-&gt;method = (Byte)method;
</span><span class='line'>
</span><span class='line'>    return deflateReset(strm);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上述代码也验证了他们这种关系。</p>

<p>那现在的问题就是找出哪里调用<code>Java_java_util_zip_Deflater_init</code>了，从这方法的命名上知道它是一个java的native方法实现，对应的是<code>java.util.zip.Deflater</code>这个类的<code>init</code>方法，所以要知道<code>init</code>方法哪里被调用了，跟踪调用栈我们会想到btrace工具，但是btrace是通过插桩的方式来实现的，对于native方法是无法插桩的，于是我们看调用它的地方，找到对应的方法，然后进行btrace脚本编写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import com.sun.btrace.annotations.*;
</span><span class='line'>import static com.sun.btrace.BTraceUtils.*;
</span><span class='line'>
</span><span class='line'>@BTrace public class Test {
</span><span class='line'>    @OnMethod(
</span><span class='line'>        clazz="java.util.zip.Deflater",
</span><span class='line'>        method="&lt;init&gt;"
</span><span class='line'>    )
</span><span class='line'>    public static void onnewThread(int i,boolean b) {
</span><span class='line'>        jstack();
</span><span class='line'>     }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>于是跟踪对应的进程，我们能抓到调用Deflater构造函数的堆栈</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>org.apache.commons.compress.compressors.deflate.DeflateCompressorOutputStream.&lt;init&gt;(DeflateCompressorOutputStream.java:47)
</span><span class='line'>com.xxx.unimsg.parse.util.CompressUtil.deflateCompressAndEncode(CompressUtil.java:199)
</span><span class='line'>com.xxx.unimsg.parse.util.CompressUtil.compress(CompressUtil.java:80)
</span><span class='line'>com.xxx.unimsg.UnifyMessageHelper.compressXml(UnifyMessageHelper.java:65)
</span><span class='line'>com.xxx.core.model.utils.UnifyMessageUtil.compressXml(UnifyMessageUtil.java:56)
</span><span class='line'>com.xxx.repository.convert.BatchInDetailConvert.convertDO(BatchInDetailConvert.java:57)
</span><span class='line'>com.xxx.repository.impl.IncomingDetailRepositoryImpl$1.store(IncomingDetailRepositoryImpl.java:43)
</span><span class='line'>com.xxx.repository.helper.IdempotenceHelper.store(IdempotenceHelper.java:27)
</span><span class='line'>com.xxx.repository.impl.IncomingDetailRepositoryImpl.store(IncomingDetailRepositoryImpl.java:40)
</span><span class='line'>sun.reflect.GeneratedMethodAccessor274.invoke(Unknown Source)
</span><span class='line'>sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
</span><span class='line'>java.lang.reflect.Method.invoke(Method.java:597)
</span><span class='line'>org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:309)
</span><span class='line'>org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:183)
</span><span class='line'>org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)
</span><span class='line'>com.alipay.finsupport.component.monitor.MethodMonitorInterceptor.invoke(MethodMonitorInterceptor.java:45)
</span><span class='line'>org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
</span><span class='line'>org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>从上面的堆栈我们找出了调用<code>java.util.zip.Deflate.init()</code>的地方</p>

<h2>问题解决</h2>

<p>上面已经定位了具体的代码了，于是再细致跟踪了下对应的代码，其实并不是代码实现上的问题，而是代码设计上没有考虑到流量很大的场景，当流量很大的时候，不管自己系统是否能承受这么大的压力，都来者不拒，拿到数据就做deflate，而这个过程是需要分配堆外内存的，当量达到一定程度的时候此时会发生oom killer，另外我们在分析过程中发现其实物理内存是有下降的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>30071.txt:     0.0   0.0% 100.0%     96.7  57.0% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.1   0.0%  99.9%    196.0  72.6% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.1   0.0%  99.9%    290.3  78.5% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.1   0.0%  99.9%    392.7  83.6% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.2   0.0%  99.9%    592.8  88.5% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.2   0.0%  99.9%    700.7  91.0% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    799.1  91.9% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    893.9  92.2% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.0   0.0%  99.9%    114.2  63.7% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.0   0.0% 100.0%    105.1  52.1% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.2   0.0%  99.9%    479.7  87.4% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    782.2  90.1% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    986.9  92.3% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.4   0.0%  99.9%   1086.3  92.9% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.4   0.0%  99.9%   1185.1  93.3% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    941.5  92.1% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.4   0.0% 100.0%   1288.8  94.1% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.5   0.0% 100.0%   1394.8  94.9% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.5   0.0% 100.0%   1492.5  95.1% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.5   0.0% 100.0%   1591.0  95.3% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    874.6  90.0% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    950.7  92.8% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    858.4  92.3% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    818.4  91.9% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    858.7  91.2% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.1   0.0%  99.9%    271.5  77.9% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.4   0.0%  99.9%   1260.4  93.1% Java_java_util_zip_Deflater_init
</span><span class='line'>30071.txt:     0.3   0.0%  99.9%    976.4  90.6% Java_java_util_zip_Deflater_init</span></code></pre></td></tr></table></div></figure>


<p>这也就说明了其实代码使用上并没有错，因此建议将deflate放到队列里去做，比如限制队列大小是100，每次最多100个数据可以被deflate，处理一个放进一个，以至于不会被活活撑死。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之FinalReference完全解读]]></title>
    <link href="http://nijiaben.github.io/blog/2015/07/09/final-reference/"/>
    <updated>2015-07-09T14:35:31+08:00</updated>
    <id>http://nijiaben.github.io/blog/2015/07/09/final-reference</id>
    <content type="html"><![CDATA[<p><code>注:文章首发于InfoQ：</code><a href="" title="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference">JVM源码分析之FinalReference</a></p>

<h2>概述</h2>

<p>JAVA对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了四种其他引用：SoftReference、WeakReference、PhantomReference、FinalReference，本文主要想讲的是FinalReference，因为我们在使用内存分析工具比如zprofiler、mat等在分析一些oom的heap的时候，经常能看到 <code>java.lang.ref.Finalizer</code>占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角<code>FinalReference</code>有着密不可分的关系。</p>

<!--more-->


<p>对于FinalReference及关联的内容，我们可能有如下印象：
* 自己代码里从没有使用过
* 线程dump之后，我们能看到一个叫做<code>Finalizer</code>的java线程
* 偶尔能注意到<code>java.lang.ref.Finalizer</code>的存在
* 我们在类里可能会写finalize方法</p>

<p>那FinalReference到底存在的意义是什么，以怎样的形式和我们的代码相关联呢，这是本文要理清的问题。</p>

<h2>JDK中的FinalReference</h2>

<p>首先我们看看FinalReference在JDK里的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class FinalReference&lt;T&gt; extends Reference&lt;T&gt; {
</span><span class='line'>
</span><span class='line'>    public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) {
</span><span class='line'>        super(referent, q);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现<code>java.lang.ref.Finalizer</code>，这个类也是我们在概述里提到的，而此类的访问权限也是package的，并且是final的，意味着真的不能被扩展了，接下来的重点我们围绕<code>java.lang.ref.Finalizer</code>展开(PS：后续讲Finalizer相关的其实也就是在说FinalReference)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>final class Finalizer extends FinalReference { /* Package-private; must be in
</span><span class='line'>                                                  same package as the Reference
</span><span class='line'>                                                  class */
</span><span class='line'>
</span><span class='line'>    /* A native method that invokes an arbitrary object's finalize method is
</span><span class='line'>       required since the finalize method is protected
</span><span class='line'>     */
</span><span class='line'>    static native void invokeFinalizeMethod(Object o) throws Throwable;
</span><span class='line'>
</span><span class='line'>    private static ReferenceQueue queue = new ReferenceQueue();
</span><span class='line'>    private static Finalizer unfinalized = null;
</span><span class='line'>    private static final Object lock = new Object();
</span><span class='line'>
</span><span class='line'>    private Finalizer
</span><span class='line'>        next = null,
</span><span class='line'>        prev = null;
</span><span class='line'>        
</span><span class='line'>    private Finalizer(Object finalizee) {
</span><span class='line'>        super(finalizee, queue);
</span><span class='line'>        add();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Invoked by VM */
</span><span class='line'>    static void register(Object finalizee) {
</span><span class='line'>        new Finalizer(finalizee);
</span><span class='line'>    }  
</span><span class='line'>    
</span><span class='line'>    private void add() {
</span><span class='line'>        synchronized (lock) {
</span><span class='line'>            if (unfinalized != null) {
</span><span class='line'>                this.next = unfinalized;
</span><span class='line'>                unfinalized.prev = this;
</span><span class='line'>            }
</span><span class='line'>            unfinalized = this;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>      
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>   }    
</span></code></pre></td></tr></table></div></figure>


<h3>Finalizer的构造函数</h3>

<p>从构造函数上我们获得下面的几个关键信息
* private：意味着我们在外面无法自己构建这类对象
* finalizee参数：FinalReference指向的对象引用
* 调用add方法：将当前对象插入到Finalizer对象链里，链里的对象和Finalizer类静态相关联，言外之意是在这个链里的对象都无法被gc掉，除非将这种引用关系剥离掉（因为Finalizer类无法被unload）</p>

<p>虽然外面无法创建Finalizer对象，但是注意到有一个register的静态方法，在方法里会创建这种对象，同时将这个对象加入到Finalizer对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p>

<h2>Finalizer对象何时被注册到Finalizer对象链里</h2>

<p>类其实有挺多的修饰，比如final，abstract，public等等，如果一个类有final修饰，我们就说这个类是一个final类，上面列的都是语法层面我们可以显示标记的，在jvm里其实还给类标记其他一些符号，比如finalizer，表示这个类是一个finalizer类（为了和java.lang.ref.Fianlizer类进行区分，下文要提到的finalizer类的地方都说成f类），gc在处理这种类的对象的时候要做一些特殊的处理，如在这个对象被回收之前会调用一下它的finalize方法。</p>

<h3>如何判断一个类是不是一个f类</h3>

<p>在讲这个问题之前，我们先来看下<code>java.lang.Object</code>里的一个方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protected void finalize() throws Throwable { }</span></code></pre></td></tr></table></div></figure>


<p>在Object类里定义了一个名为finalize的空方法，这意味着Java世界里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限都是至少是protected级别的，这样其子类就算没有覆写此方法也会继承此方法。</p>

<p>而判断当前类是否是一个f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的名为finalize的方法，而另外一个要求是<code>finalize方法必须非空</code>，因此我们的Object类虽然含有一个finalize方法，但是并不是一个f类，Object的对象在被gc回收的时候其实并不会去调用它的finalize方法。</p>

<p>需要注意的是我们的类在被加载过程中其实就已经被标记为是否为f类了（遍历所有方法，包括父类的方法，只要有一个非空的参数为空返回void的finalize方法就认为是一个f类）。</p>

<h3>f类的对象何时传到Finalizer.register方法</h3>

<p>对象的创建其实是被拆分成多个步骤的，比如<code>A a=new A(2)</code>这样一条语句对应的字节码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0: new           #1                  // class A
</span><span class='line'>3: dup
</span><span class='line'>4: iconst_2
</span><span class='line'>5: invokespecial #11                 // Method "&lt;init&gt;":(I)V</span></code></pre></td></tr></table></div></figure>


<p>先执行new分配好对象空间，然后再执行invokespecial调用构造函数，jvm里其实可以让用户选择在这两个时机中的任意一个将当前对象传递给Finalizer.register方法来注册到Finalizer对象链里，这个选择依赖于RegisterFinalizersAtInit这个vm参数是否被设置，默认值为true，也就是在调用构造函数返回之前调用Finalizer.register方法，如果通过-XX:-RegisterFinalizersAtInit关闭了该参数，那将在对象空间分配好之后就将这个对象注册进去。</p>

<p>另外需要提一点的是当我们通过clone的方式复制一个对象的时候，如果当前类是一个f类，那么在clone完成的时候将调用Finalizer.register方法进行注册。</p>

<h3>hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</h3>

<p>这个实现比较有意思，在这里简单提一下，我们知道一个构造函数执行的时候，会去调用父类的构造函数，主要是为了能对继承自父类的属性也能做初始化，那么任何一个对象的初始化最终都会调用到Object的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有的类的构造函数都做埋点调用Finalizer.register方法，hotspot的实现是在Object这个类在做初始化的时候将构造函数里的<code>return</code>指令替换为<code>_return_register_finalizer</code>指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令的时候调用Finalizer.register方法，这样就在侵入性很小的情况下完美地解决了这个问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0: aload_0
</span><span class='line'>1: invokespecial #21                 // Method java/lang/Object."&lt;init&gt;":()V
</span><span class='line'>4: return</span></code></pre></td></tr></table></div></figure>


<h2>f类对象的GC回收</h2>

<h3>FinalizerThread线程</h3>

<p>在Finalizer类的clinit方法（静态块）里我们看到它会创建了一个FinalizerThread的守护线程，这个线程的优先级并不是最高的，意味着在cpu很紧张的情况下其被调度的优先级可能会受到影响</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private static class FinalizerThread extends Thread {
</span><span class='line'>        private volatile boolean running;
</span><span class='line'>        FinalizerThread(ThreadGroup g) {
</span><span class='line'>            super(g, "Finalizer");
</span><span class='line'>        }
</span><span class='line'>        public void run() {
</span><span class='line'>            if (running)
</span><span class='line'>                return;
</span><span class='line'>            running = true;
</span><span class='line'>            for (;;) {
</span><span class='line'>                try {
</span><span class='line'>                    Finalizer f = (Finalizer)queue.remove();
</span><span class='line'>                    f.runFinalizer();
</span><span class='line'>                } catch (InterruptedException x) {
</span><span class='line'>                    continue;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    static {
</span><span class='line'>        ThreadGroup tg = Thread.currentThread().getThreadGroup();
</span><span class='line'>        for (ThreadGroup tgn = tg;
</span><span class='line'>             tgn != null;
</span><span class='line'>             tg = tgn, tgn = tg.getParent());
</span><span class='line'>        Thread finalizer = new FinalizerThread(tg);
</span><span class='line'>        finalizer.setPriority(Thread.MAX_PRIORITY - 2);
</span><span class='line'>        finalizer.setDaemon(true);
</span><span class='line'>        finalizer.start();
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>这个线程主要就是从queue里取Finalizer对象，然后执行该对象的runFinalizer方法，这个方法主要是将Finalizer对象从Finalizer对象链里剥离出来，这样意味着下次gc发生的时候就可能将其关联的f对象gc掉了，最后将这个Finalizer对象关联的f对象传给了一个native方法invokeFinalizeMethod</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void runFinalizer() {
</span><span class='line'>        synchronized (this) {
</span><span class='line'>            if (hasBeenFinalized()) return;
</span><span class='line'>            remove();
</span><span class='line'>        }
</span><span class='line'>        try {
</span><span class='line'>            Object finalizee = this.get();
</span><span class='line'>            if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {
</span><span class='line'>                invokeFinalizeMethod(finalizee);
</span><span class='line'>                /* Clear stack slot containing this variable, to decrease
</span><span class='line'>                   the chances of false retention with a conservative GC */
</span><span class='line'>                finalizee = null;
</span><span class='line'>            }
</span><span class='line'>        } catch (Throwable x) { }
</span><span class='line'>        super.clear();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'> static native void invokeFinalizeMethod(Object o) throws Throwable;
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>其实invokeFinalizeMethod方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JNIEXPORT void JNICALL
</span><span class='line'>Java_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,
</span><span class='line'>                                                  jobject ob)
</span><span class='line'>{
</span><span class='line'>    jclass cls;
</span><span class='line'>    jmethodID mid;
</span><span class='line'>
</span><span class='line'>    cls = (*env)-&gt;GetObjectClass(env, ob);
</span><span class='line'>    if (cls == NULL) return;
</span><span class='line'>    mid = (*env)-&gt;GetMethodID(env, cls, "finalize", "()V");
</span><span class='line'>    if (mid == NULL) return;
</span><span class='line'>    (*env)-&gt;CallVoidMethod(env, ob, mid);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>f对象的finalize方法抛出异常会导致FinalizeThread退出吗</h3>

<p>不知道大家有没有想过如果f对象的finalize方法抛了一个没捕获的异常，这个FinalizerThread会不会退出呢，细心的读者看上面的代码其实就可以找到答案，在runFinalizer方法里对Throwable的异常都进行了捕获，因此不可能出现FinalizerThread因异常未捕获而退出的情况。</p>

<h3>f对象的finalize方法会执行多次吗</h3>

<p>如果我们在f对象的finalize方法里重新将当前对象赋值出去，变成可达对象，当这个f对象再次变成不可达的时候还会被执行finalize方法吗？答案是否定的，因为在执行完第一次finalize方法之后，这个f对象已经和之前的Finalizer对象关系剥离了，也就是下次gc的时候不会再发现Finalizer对象指向该f对象了，自然也就不会调用这个f对象的finalize方法了。</p>

<h3>Finalizer对象何时被放到ReferenceQueue里</h3>

<p>除了这里要说的环节之外，整个过程大家应该都比较清楚了。</p>

<p>当gc发生的时候，gc算法会判断f类对象是不是只被Finalizer类引用（f类对象被Finalizer对象引用，然后放到Finalizer对象链里），如果这个类仅仅被Finalizer对象引用的时候，说明这个对象在不久的将来会被回收了现在可以执行它的finalize方法了，于是会将这个Finalizer对象放到Finalizer类的ReferenceQueue里，但是这个f类对象其实并没有被回收，因为Finalizer这个类还对他们持有引用，在gc完成之前，jvm会调用ReferenceQueue里的lock对象的notify方法（当ReferenceQueue为空的时候，FinalizerThread线程会调用ReferenceQueue的lock对象的wait方法直到被jvm唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。</p>

<h2>Finalizer导致的内存泄露</h2>

<p>这里举一个简单的例子，我们使用挺广的socket通信，SocksSocketImpl的父类其实就实现了finalize方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Cleans up if the user forgets to close it.
</span><span class='line'> */
</span><span class='line'>protected void finalize() throws IOException {
</span><span class='line'>      close();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其实这么做的主要目的是万一用户忘记关闭socket了，那么在这个对象被回收的时候能主动关闭socket来释放一些系统资源，但是如果真的是用户忘记关闭了，那这些socket对象可能因为FinalizeThread迟迟没有执行到这些socket对象的finalize方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.</p>

<h2>Finalizer的客观评价</h2>

<p>上面的过程基本对Finalizer的实现细节进行完整剖析了，java里我们看到有构造函数，但是并没有看到析构函数一说，Finalizer其实是实现了析构函数的概念，我们在对象被回收前可以执行一些『收拾性』的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给我们的f对象生命周期以及gc等带来了一些影响：
* f对象因为Finalizer的引用而变成了一个临时的强引用，即使没有其他的强引用了，还是无法立即被回收
* f对象至少经历两次GC才能被回收，因为只有在FinalizerThread执行完了f对象的finalize方法的情况下才有可能被下次gc回收，而有可能期间已经经历过多次gc了，但是一直还没执行f对象的finalize方法
* cpu资源比较稀缺的情况下FinalizerThread线程有可能因为优先级比较低而延迟执行f对象的finalize方法
* 因为f对象的finalize方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的gc，甚至fullgc，gc暂停时间明显变长
* f对象的finalize方法被调用了，但是这个对象其实还并没有被回收，虽然可能在不久的将来会被回收</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之堆外内存完全解读]]></title>
    <link href="http://nijiaben.github.io/blog/2015/05/12/direct-buffer/"/>
    <updated>2015-05-12T13:49:57+08:00</updated>
    <id>http://nijiaben.github.io/blog/2015/05/12/direct-buffer</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<h3>广义的堆外内存</h3>

<p>说到堆外内存，那大家肯定想到堆内内存，这也是我们大家接触最多的，我们在jvm参数里通常设置-Xmx来指定我们的堆的最大值，不过这还不是我们理解的Java堆，-Xmx的值是新生代和老生代的和的最大值，我们在jvm参数里通常还会加一个参数-XX:MaxPermSize来指定持久代的最大值，那么我们认识的Java堆的最大值其实是-Xmx和-XX:MaxPermSize的总和，在分代算法下，新生代，老生代和持久代是连续的虚拟地址，因为它们是一起分配的，那么剩下的都可以认为是堆外内存(广义的)了，这些包括了jvm本身在运行过程中分配的内存，codecache，jni里分配的内存，DirectByteBuffer分配的内存等等</p>

<h3>狭义的堆外内存</h3>

<p>而作为java开发者，我们常说的堆外内存溢出了，其实是狭义的堆外内存，这个主要是指java.nio.DirectByteBuffer在创建的时候分配内存，我们这篇文章里也主要是讲狭义的堆外内存，因为它和我们平时碰到的问题比较密切</p>

<!--more-->


<h2>JDK/JVM里DirectByteBuffer的实现</h2>

<p>DirectByteBuffer通常用在通信过程中做缓冲池，在mina，netty等nio框架中屡见不鲜，先来看看JDK里的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DirectByteBuffer(int cap) {                   // package-private
</span><span class='line'>
</span><span class='line'>    super(-1, 0, cap, cap);
</span><span class='line'>    boolean pa = VM.isDirectMemoryPageAligned();
</span><span class='line'>    int ps = Bits.pageSize();
</span><span class='line'>    long size = Math.max(1L, (long)cap + (pa ? ps : 0));
</span><span class='line'>    Bits.reserveMemory(size, cap);
</span><span class='line'>
</span><span class='line'>    long base = 0;
</span><span class='line'>    try {
</span><span class='line'>        base = unsafe.allocateMemory(size);
</span><span class='line'>    } catch (OutOfMemoryError x) {
</span><span class='line'>        Bits.unreserveMemory(size, cap);
</span><span class='line'>        throw x;
</span><span class='line'>    }
</span><span class='line'>    unsafe.setMemory(base, size, (byte) 0);
</span><span class='line'>    if (pa && (base % ps != 0)) {
</span><span class='line'>        // Round up to page boundary
</span><span class='line'>        address = base + ps - (base & (ps - 1));
</span><span class='line'>    } else {
</span><span class='line'>        address = base;
</span><span class='line'>    }
</span><span class='line'>    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
</span><span class='line'>    att = null;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过上面的构造函数我们知道，真正的内存分配是使用的Bits.reserveMemory方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     static void reserveMemory(long size, int cap) {
</span><span class='line'>        synchronized (Bits.class) {
</span><span class='line'>            if (!memoryLimitSet && VM.isBooted()) {
</span><span class='line'>                maxMemory = VM.maxDirectMemory();
</span><span class='line'>                memoryLimitSet = true;
</span><span class='line'>            }
</span><span class='line'>            // -XX:MaxDirectMemorySize limits the total capacity rather than the
</span><span class='line'>            // actual memory usage, which will differ when buffers are page
</span><span class='line'>            // aligned.
</span><span class='line'>            if (cap &lt;= maxMemory - totalCapacity) {
</span><span class='line'>                reservedMemory += size;
</span><span class='line'>                totalCapacity += cap;
</span><span class='line'>                count++;
</span><span class='line'>                return;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        System.gc();
</span><span class='line'>        try {
</span><span class='line'>            Thread.sleep(100);
</span><span class='line'>        } catch (InterruptedException x) {
</span><span class='line'>            // Restore interrupt status
</span><span class='line'>            Thread.currentThread().interrupt();
</span><span class='line'>        }
</span><span class='line'>        synchronized (Bits.class) {
</span><span class='line'>            if (totalCapacity + cap &gt; maxMemory)
</span><span class='line'>                throw new OutOfMemoryError("Direct buffer memory");
</span><span class='line'>            reservedMemory += size;
</span><span class='line'>            totalCapacity += cap;
</span><span class='line'>            count++;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>通过上面的代码我们知道可以通过-XX:MaxDirectMemorySize来指定最大的堆外内存，那么我们首先引入两个问题</p>

<ul>
<li>堆外内存默认是多大</li>
<li>为什么要主动调用System.gc()</li>
</ul>


<h3>堆外内存默认是多大</h3>

<p>如果我们没有通过-XX:MaxDirectMemorySize来指定最大的堆外内存，那么默认的最大堆外内存是多少呢，我们还是通过代码来分析</p>

<p>上面的代码里我们看到调用了sun.misc.VM.maxDirectMemory()</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> private static long directMemory = 64 * 1024 * 1024;
</span><span class='line'>
</span><span class='line'>    // Returns the maximum amount of allocatable direct buffer memory.
</span><span class='line'>    // The directMemory variable is initialized during system initialization
</span><span class='line'>    // in the saveAndRemoveProperties method.
</span><span class='line'>    //
</span><span class='line'>    public static long maxDirectMemory() {
</span><span class='line'>        return directMemory;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>看到上面的代码之后是不是误以为默认的最大值是64M？其实不是的，说到这个值得从java.lang.System这个类的初始化说起</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> /**
</span><span class='line'>     * Initialize the system class.  Called after thread initialization.
</span><span class='line'>     */
</span><span class='line'>    private static void initializeSystemClass() {
</span><span class='line'>
</span><span class='line'>        // VM might invoke JNU_NewStringPlatform() to set those encoding
</span><span class='line'>        // sensitive properties (user.home, user.name, boot.class.path, etc.)
</span><span class='line'>        // during "props" initialization, in which it may need access, via
</span><span class='line'>        // System.getProperty(), to the related system encoding property that
</span><span class='line'>        // have been initialized (put into "props") at early stage of the
</span><span class='line'>        // initialization. So make sure the "props" is available at the
</span><span class='line'>        // very beginning of the initialization and all system properties to
</span><span class='line'>        // be put into it directly.
</span><span class='line'>        props = new Properties();
</span><span class='line'>        initProperties(props);  // initialized by the VM
</span><span class='line'>
</span><span class='line'>        // There are certain system configurations that may be controlled by
</span><span class='line'>        // VM options such as the maximum amount of direct memory and
</span><span class='line'>        // Integer cache size used to support the object identity semantics
</span><span class='line'>        // of autoboxing.  Typically, the library will obtain these values
</span><span class='line'>        // from the properties set by the VM.  If the properties are for
</span><span class='line'>        // internal implementation use only, these properties should be
</span><span class='line'>        // removed from the system properties.
</span><span class='line'>        //
</span><span class='line'>        // See java.lang.Integer.IntegerCache and the
</span><span class='line'>        // sun.misc.VM.saveAndRemoveProperties method for example.
</span><span class='line'>        //
</span><span class='line'>        // Save a private copy of the system properties object that
</span><span class='line'>        // can only be accessed by the internal implementation.  Remove
</span><span class='line'>        // certain system properties that are not intended for public access.
</span><span class='line'>        sun.misc.VM.saveAndRemoveProperties(props);
</span><span class='line'>
</span><span class='line'>       ......
</span><span class='line'>       
</span><span class='line'>        sun.misc.VM.booted();
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>上面这个方法在jvm启动的时候对System这个类做初始化的时候执行的，因此执行时间非常早，我们看到里面调用了<code>sun.misc.VM.saveAndRemoveProperties(props)</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>     public static void saveAndRemoveProperties(Properties props) {
</span><span class='line'>        if (booted)
</span><span class='line'>            throw new IllegalStateException("System initialization has completed");
</span><span class='line'>
</span><span class='line'>        savedProps.putAll(props);
</span><span class='line'>
</span><span class='line'>        // Set the maximum amount of direct memory.  This value is controlled
</span><span class='line'>        // by the vm option -XX:MaxDirectMemorySize=&lt;size&gt;.
</span><span class='line'>        // The maximum amount of allocatable direct buffer memory (in bytes)
</span><span class='line'>        // from the system property sun.nio.MaxDirectMemorySize set by the VM.
</span><span class='line'>        // The system property will be removed.
</span><span class='line'>        String s = (String)props.remove("sun.nio.MaxDirectMemorySize");
</span><span class='line'>        if (s != null) {
</span><span class='line'>            if (s.equals("-1")) {
</span><span class='line'>                // -XX:MaxDirectMemorySize not given, take default
</span><span class='line'>                directMemory = Runtime.getRuntime().maxMemory();
</span><span class='line'>            } else {
</span><span class='line'>                long l = Long.parseLong(s);
</span><span class='line'>                if (l &gt; -1)
</span><span class='line'>                    directMemory = l;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Check if direct buffers should be page aligned
</span><span class='line'>        s = (String)props.remove("sun.nio.PageAlignDirectMemory");
</span><span class='line'>        if ("true".equals(s))
</span><span class='line'>            pageAlignDirectMemory = true;
</span><span class='line'>
</span><span class='line'>        // Set a boolean to determine whether ClassLoader.loadClass accepts
</span><span class='line'>        // array syntax.  This value is controlled by the system property
</span><span class='line'>        // "sun.lang.ClassLoader.allowArraySyntax".
</span><span class='line'>        s = props.getProperty("sun.lang.ClassLoader.allowArraySyntax");
</span><span class='line'>        allowArraySyntax = (s == null
</span><span class='line'>                               ? defaultAllowArraySyntax
</span><span class='line'>                               : Boolean.parseBoolean(s));
</span><span class='line'>
</span><span class='line'>        // Remove other private system properties
</span><span class='line'>        // used by java.lang.Integer.IntegerCache
</span><span class='line'>        props.remove("java.lang.Integer.IntegerCache.high");
</span><span class='line'>
</span><span class='line'>        // used by java.util.zip.ZipFile
</span><span class='line'>        props.remove("sun.zip.disableMemoryMapping");
</span><span class='line'>
</span><span class='line'>        // used by sun.launcher.LauncherHelper
</span><span class='line'>        props.remove("sun.java.launcher.diag");
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>如果我们通过-Dsun.nio.MaxDirectMemorySize指定了这个属性，只要它不等于-1，那效果和加了-XX:MaxDirectMemorySize一样的，如果两个参数都没指定，那么最大堆外内存的值来自于<code>directMemory = Runtime.getRuntime().maxMemory()</code>，这是一个native方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JNIEXPORT jlong JNICALL
</span><span class='line'>Java_java_lang_Runtime_maxMemory(JNIEnv *env, jobject this)
</span><span class='line'>{
</span><span class='line'>    return JVM_MaxMemory();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
</span><span class='line'>  JVMWrapper("JVM_MaxMemory");
</span><span class='line'>  size_t n = Universe::heap()-&gt;max_capacity();
</span><span class='line'>  return convert_size_t_to_jlong(n);
</span><span class='line'>JVM_END
</span></code></pre></td></tr></table></div></figure>


<p>其中在我们使用CMS GC的情况下的实现如下，其实是新生代的最大值-一个survivor的大小+老生代的最大值，也就是我们设置的-Xmx的值里除去一个survivor的大小就是默认的堆外内存的大小了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>size_t GenCollectedHeap::max_capacity() const {
</span><span class='line'>  size_t res = 0;
</span><span class='line'>  for (int i = 0; i &lt; _n_gens; i++) {
</span><span class='line'>    res += _gens[i]-&gt;max_capacity();
</span><span class='line'>  }
</span><span class='line'>  return res;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>size_t DefNewGeneration::max_capacity() const {
</span><span class='line'>  const size_t alignment = GenCollectedHeap::heap()-&gt;collector_policy()-&gt;min_alignment();
</span><span class='line'>  const size_t reserved_bytes = reserved().byte_size();
</span><span class='line'>  return reserved_bytes - compute_survivor_size(reserved_bytes, alignment);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>size_t Generation::max_capacity() const {
</span><span class='line'>  return reserved().byte_size();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>为什么要主动调用System.gc</h3>

<p>既然要调用System.gc，那肯定是想通过触发一次gc操作来回收堆外内存，不过我想先说的是堆外内存不会对gc造成什么影响(这里的System.gc除外)，但是堆外内存的回收其实依赖于我们的gc机制，首先我们要知道在java层面和我们在堆外分配的这块内存关联的只有与之关联的DirectByteBuffer对象了，它记录了这块内存的基地址以及大小，那么既然和gc也有关，那就是gc能通过操作DirectByteBuffer对象来间接操作对应的堆外内存了。DirectByteBuffer对象在创建的时候关联了一个PhantomReference，说到PhantomReference它其实主要是用来跟踪对象何时被回收的，它不能影响gc决策，但是gc过程中如果发现某个对象除了只有PhantomReference引用它之外，并没有其他的地方引用它了，那将会把这个引用放到java.lang.ref.Reference.pending队列里，在gc完毕的时候通知ReferenceHandler这个守护线程去执行一些后置处理，而DirectByteBuffer关联的PhantomReference是PhantomReference的一个子类，在最终的处理里会通过Unsafe的free接口来释放DirectByteBuffer对应的堆外内存块</p>

<p>JDK里ReferenceHandler的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> private static class ReferenceHandler extends Thread {
</span><span class='line'>
</span><span class='line'>        ReferenceHandler(ThreadGroup g, String name) {
</span><span class='line'>            super(g, name);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public void run() {
</span><span class='line'>            for (;;) {
</span><span class='line'>
</span><span class='line'>                Reference r;
</span><span class='line'>                synchronized (lock) {
</span><span class='line'>                    if (pending != null) {
</span><span class='line'>                        r = pending;
</span><span class='line'>                        Reference rn = r.next;
</span><span class='line'>                        pending = (rn == r) ? null : rn;
</span><span class='line'>                        r.next = r;
</span><span class='line'>                    } else {
</span><span class='line'>                        try {
</span><span class='line'>                            lock.wait();
</span><span class='line'>                        } catch (InterruptedException x) { }
</span><span class='line'>                        continue;
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>
</span><span class='line'>                // Fast path for cleaners
</span><span class='line'>                if (r instanceof Cleaner) {
</span><span class='line'>                    ((Cleaner)r).clean();
</span><span class='line'>                    continue;
</span><span class='line'>                }
</span><span class='line'>
</span><span class='line'>                ReferenceQueue q = r.queue;
</span><span class='line'>                if (q != ReferenceQueue.NULL) q.enqueue(r);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>可见如果pending为空的时候，会通过lock.wait()一直等在那里，其中唤醒的动作是在jvm里做的，当gc完成之后会调用如下的方法VM_GC_Operation::doit_epilogue()，在方法末尾会调用lock的notify操作，至于pending队列什么时候将引用放进去的，其实是在gc的引用处理逻辑中放进去的，针对引用的处理后面可以专门写篇文章来介绍</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void VM_GC_Operation::doit_epilogue() {
</span><span class='line'>  assert(Thread::current()-&gt;is_Java_thread(), "just checking");
</span><span class='line'>  // Release the Heap_lock first.
</span><span class='line'>  SharedHeap* sh = SharedHeap::heap();
</span><span class='line'>  if (sh != NULL) sh-&gt;_thread_holds_heap_lock_for_gc = false;
</span><span class='line'>  Heap_lock-&gt;unlock();
</span><span class='line'>  release_and_notify_pending_list_lock();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void VM_GC_Operation::release_and_notify_pending_list_lock() {
</span><span class='line'>instanceRefKlass::release_and_notify_pending_list_lock(&_pending_list_basic_lock);
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>对于System.gc的实现，之前写了一篇文章来重点介绍，<a href="http://lovestblog.cn/blog/2015/05/07/system-gc/">JVM源码分析之SystemGC完全解读</a>，它会对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存，我们dump内存发现DirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为『冰山对象』，我们做ygc的时候会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收了，但是无法对old里的DirectByteBuffer对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题，如果有大量的DirectByteBuffer对象移到了old，但是又一直没有做cms gc或者full gc，而只进行ygc，那么我们的物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多(前提是我们禁用了System.gc)。</p>

<h2>为什么要使用堆外内存</h2>

<p>DirectByteBuffer在创建的时候会通过Unsafe的native方法来直接使用malloc分配一块内存，这块内存是heap之外的，那么自然也不会对gc造成什么影响(System.gc除外)，因为gc耗时的操作主要是操作heap之内的对象，对这块内存的操作也是直接通过Unsafe的native方法来操作的，相当于DirectByteBuffer仅仅是一个壳，还有我们通信过程中如果数据是在Heap里的，最终也还是会copy一份到堆外，然后再进行发送，所以为什么不直接使用堆外内存呢。对于需要频繁操作的内存，并且仅仅是临时存在一会的，都建议使用堆外内存，并且做成缓冲池，不断循环利用这块内存。</p>

<h2>为什么不能大面积使用堆外内存</h2>

<p>如果我们大面积使用堆外内存并且没有限制，那迟早会导致内存溢出，毕竟程序是跑在一台资源受限的机器上，因为这块内存的回收不是你直接能控制的，当然你可以通过别的一些途径，比如反射，直接使用Unsafe接口等，但是这些务必给你带来了一些烦恼，Java与生俱来的优势被你完全抛弃了&#8212;开发不需要关注内存的回收，由gc算法自动去实现。另外上面的gc机制与堆外内存的关系也说了，如果一直触发不了cms gc或者full gc，那么后果可能很严重。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之SystemGC完全解读]]></title>
    <link href="http://nijiaben.github.io/blog/2015/05/07/system-gc/"/>
    <updated>2015-05-07T20:02:51+08:00</updated>
    <id>http://nijiaben.github.io/blog/2015/05/07/system-gc</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>JVM的GC一般情况下是JVM本身根据一定的条件触发的，不过我们还是可以做一些人为的触发，比如通过jvmti做强制GC，通过System.gc触发，还可以通过jmap来触发等，针对每个场景其实我们都可以写篇文章来做一个介绍，本文重点介绍下System.gc的原理</p>

<!--more-->


<p>或许大家已经知道如下相关的知识</p>

<ul>
<li>system.gc其实是做一次full gc</li>
<li>system.gc会暂停整个进程</li>
<li>system.gc一般情况下我们要禁掉，使用-XX:+DisableExplicitGC</li>
<li>system.gc在cms gc下我们通过-XX:+ExplicitGCInvokesConcurrent来做一次稍微高效点的GC(效果比Full GC要好些)</li>
<li>system.gc最常见的场景是RMI/NIO下的堆外内存分配等</li>
</ul>


<p>如果你已经知道上面这些了其实也说明你对System.gc有过一定的了解，至少踩过一些坑，但是你是否更深层次地了解过它，比如</p>

<ul>
<li>为什么CMS GC下-XX:+ExplicitGCInvokesConcurrent这个参数加了之后会比真正的Full GC好？</li>
<li>它如何做到暂停整个进程？</li>
<li>堆外内存分配为什么有时候要配合System.gc？</li>
</ul>


<p>如果你上面这些疑惑也都知道，那说明你很懂System.gc了，那么接下来的文字你可以不用看啦</p>

<h2>JDK里的System.gc的实现</h2>

<p>先贴段代码吧（java.lang.System）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Runs the garbage collector.
</span><span class='line'> * &lt;p&gt;
</span><span class='line'> * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual
</span><span class='line'> * Machine expend effort toward recycling unused objects in order to
</span><span class='line'> * make the memory they currently occupy available for quick reuse.
</span><span class='line'> * When control returns from the method call, the Java Virtual
</span><span class='line'> * Machine has made a best effort to reclaim space from all discarded
</span><span class='line'> * objects.
</span><span class='line'> * &lt;p&gt;
</span><span class='line'> * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the
</span><span class='line'> * call:
</span><span class='line'> * &lt;blockquote&gt;&lt;pre&gt;
</span><span class='line'> * Runtime.getRuntime().gc()
</span><span class='line'> * &lt;/pre&gt;&lt;/blockquote&gt;
</span><span class='line'> *
</span><span class='line'> * @see     java.lang.Runtime#gc()
</span><span class='line'> */
</span><span class='line'>public static void gc() {
</span><span class='line'>    Runtime.getRuntime().gc();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>发现主要调用的是Runtime里的gc方法（java.lang.Runtime）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Runs the garbage collector.
</span><span class='line'> * Calling this method suggests that the Java virtual machine expend
</span><span class='line'> * effort toward recycling unused objects in order to make the memory
</span><span class='line'> * they currently occupy available for quick reuse. When control
</span><span class='line'> * returns from the method call, the virtual machine has made
</span><span class='line'> * its best effort to recycle all discarded objects.
</span><span class='line'> * &lt;p&gt;
</span><span class='line'> * The name &lt;code&gt;gc&lt;/code&gt; stands for "garbage
</span><span class='line'> * collector". The virtual machine performs this recycling
</span><span class='line'> * process automatically as needed, in a separate thread, even if the
</span><span class='line'> * &lt;code&gt;gc&lt;/code&gt; method is not invoked explicitly.
</span><span class='line'> * &lt;p&gt;
</span><span class='line'> * The method {@link System#gc()} is the conventional and convenient
</span><span class='line'> * means of invoking this method.
</span><span class='line'> */
</span><span class='line'>public native void gc();</span></code></pre></td></tr></table></div></figure>


<p>这里看到gc方法是native的，在java层面只能到此结束了，代码只有这么多，要了解更多，可以看方法上面的注释，不过我们需要更深层次地来了解其实现，那还是准备好进入到jvm里去看看</p>

<h2>Hotspot里System.gc的实现</h2>

<h3>如何找到native里的实现</h3>

<p>上面提到了Runtime.gc是一个本地方法，那需要先在jvm里找到对应的实现，这里稍微提一下jvm里native方法最常见的也是最简单的查找，jdk里一般含有native方法的类，一般都会有一个对应的c文件，比如上面的java.lang.Runtime这个类，会有一个Runtime.c的文件和它对应，native方法的具体实现都在里面了，如果你有source，可能会猜到和下面的方法对应</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JNIEXPORT void JNICALL
</span><span class='line'>Java_java_lang_Runtime_gc(JNIEnv *env, jobject this)
</span><span class='line'>{
</span><span class='line'>    JVM_GC();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其实没错的，就是这个方法，jvm要查找到这个native方法其实很简单的，看方法名可能也猜到规则了，Java_pkgName_className_methodName，其中pkgName里的&#8221;.&#8221;替换成&#8221;_&#8221;，这样就能找到了，当然规则不仅仅只有这么一个，还有其他的，这里不细说了，有机会写篇文章详细介绍下其中细节</p>

<h3>DisableExplicitGC参数</h3>

<p>上面的方法里是调用JVM_GC()，实现如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JVM_ENTRY_NO_ENV(void, JVM_GC(void))
</span><span class='line'>  JVMWrapper("JVM_GC");
</span><span class='line'>  if (!DisableExplicitGC) {
</span><span class='line'>    Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
</span><span class='line'>  }
</span><span class='line'>JVM_END</span></code></pre></td></tr></table></div></figure>


<p>看到这里我们已经解释其中一个疑惑了，就是<code>DisableExplicitGC</code>这个参数是在哪里生效的，起的什么作用，如果这个参数设置为true的话，那么将直接跳过下面的逻辑，我们通过-XX:+ DisableExplicitGC就是将这个属性设置为true，而这个属性默认情况下是true还是false呢</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>product(bool, DisableExplicitGC, false,                                   \
</span><span class='line'>          "Tells whether calling System.gc() does a full GC")    </span></code></pre></td></tr></table></div></figure>


<h3>ExplicitGCInvokesConcurrent参数</h3>

<p>这里主要针对CMSGC下来做分析，所以我们上面看到调用了heap的collect方法，我们找到对应的逻辑</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void GenCollectedHeap::collect(GCCause::Cause cause) {
</span><span class='line'>  if (should_do_concurrent_full_gc(cause)) {
</span><span class='line'>#ifndef SERIALGC
</span><span class='line'>    // mostly concurrent full collection
</span><span class='line'>    collect_mostly_concurrent(cause);
</span><span class='line'>#else  // SERIALGC
</span><span class='line'>    ShouldNotReachHere();
</span><span class='line'>#endif // SERIALGC
</span><span class='line'>  } else {
</span><span class='line'>#ifdef ASSERT
</span><span class='line'>    if (cause == GCCause::_scavenge_alot) {
</span><span class='line'>      // minor collection only
</span><span class='line'>      collect(cause, 0);
</span><span class='line'>    } else {
</span><span class='line'>      // Stop-the-world full collection
</span><span class='line'>      collect(cause, n_gens() - 1);
</span><span class='line'>    }
</span><span class='line'>#else
</span><span class='line'>    // Stop-the-world full collection
</span><span class='line'>    collect(cause, n_gens() - 1);
</span><span class='line'>#endif
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>bool GenCollectedHeap::should_do_concurrent_full_gc(GCCause::Cause cause) {
</span><span class='line'>  return UseConcMarkSweepGC &&
</span><span class='line'>         ((cause == GCCause::_gc_locker && GCLockerInvokesConcurrent) ||
</span><span class='line'>          (cause == GCCause::_java_lang_system_gc && ExplicitGCInvokesConcurrent));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>collect里一开头就有个判断，如果should_do_concurrent_full_gc返回true，那会执行collect_mostly_concurrent做并行的回收</p>

<p>其中should_do_concurrent_full_gc中的逻辑是如果使用CMS GC，并且是system gc且ExplicitGCInvokesConcurrent==true，那就做并行full gc，当我们设置-XX:+ ExplicitGCInvokesConcurrent的时候，就意味着应该做并行Full GC了，不过要注意千万不要设置-XX:+DisableExplicitGC，不然走不到这个逻辑里来了</p>

<h2>并行Full GC相对正常的Full GC效率高在哪里</h2>

<h3>stop the world</h3>

<p>说到GC，这里要先提到VMThread，在jvm里有这么一个线程不断轮询它的队列，这个队列里主要是存一些VM_operation的动作，比如最常见的就是内存分配失败要求做GC操作的请求等，在对gc这些操作执行的时候会先将其他业务线程都进入到安全点，也就是这些线程从此不再执行任何字节码指令，只有当出了安全点的时候才让他们继续执行原来的指令，因此这其实就是我们说的stop the world(STW)，整个进程相当于静止了</p>

<h3>CMS GC</h3>

<p>这里必须提到CMS GC，因为这是解释并行Full GC和正常Full GC的关键所在，CMS GC我们分为两种模式background和foreground，其中background顾名思义是在后台做的，也就是可以不影响正常的业务线程跑，触发条件比如说old的内存占比超过多少的时候就可能触发一次background式的cms gc，这个过程会经历CMS GC的所有阶段，该暂停的暂停，该并行的并行，效率相对来说还比较高，毕竟有和业务线程并行的gc阶段；而foreground则不然，它发生的场景比如业务线程请求分配内存，但是内存不够了，于是可能触发一次cms gc，这个过程就必须是要等内存分配到了线程才能继续往下面走的，因此整个过程必须是STW的，因此CMS GC整个过程都是暂停应用的，但是为了提高效率，它并不是每个阶段都会走的，只走其中一些阶段，这些省下来的阶段主要是并行阶段，Precleaning、AbortablePreclean，Resizing这几个阶段都不会经历，其中sweep阶段是同步的，但不管怎么说如果走了类似foreground的cms gc，那么整个过程业务线程都是不可用的，效率会影响挺大。CMS GC具体的过程后面再写文章详细说，其过程确实非常复杂的</p>

<h3>正常的Full GC</h3>

<p>正常的Full GC其实是整个gc过程包括ygc和cms gc(这里说的是真正意义上的Full GC，还有些场景虽然调用Full GC的接口，但是并不会都做，有些时候只做ygc，有些时候只做cms gc)都是由VMThread来执行的，因此整个时间是ygc+cms gc的时间之和，其中CMS GC是上面提到的foreground式的，因此整个过程会比较长，也是我们要避免的</p>

<h3>并行的Full GC</h3>

<p>并行Full GC也通样会做YGC和CMS GC，但是效率高就搞在CMS GC是走的background的，整个暂停的过程主要是YGC+CMS_initMark+CMS_remark几个阶段</p>

<h2>堆外内存常配合使用System GC</h2>

<p>这里说的堆外内存主要针对java.nio.DirectByteBuffer，这些对象的创建过程会通过Unsafe接口直接通过os::malloc来分配内存，然后将内存的起始地址和大小存到java.nio.DirectByteBuffer对象里，这样就可以直接操作这些内存。这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，因此如果这些对象大部分都移到了old，但是一直没有触发CMS GC或者Full GC，那么悲剧将会发生，因为你的物理内存被他们耗尽了，因此为了避免这种悲剧的发生，通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存，具体堆外内存是如何回收的，其原理机制又是怎样的，还是后面写篇详细的文章吧</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM Bug:多个线程持有一把锁?]]></title>
    <link href="http://nijiaben.github.io/blog/2014/07/24/jvm-thread-dump-bug/"/>
    <updated>2014-07-24T14:10:26+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/07/24/jvm-thread-dump-bug</id>
    <content type="html"><![CDATA[<p><code>注:文章首发于InfoQ，</code><a href="http://www.infoq.com/cn/articles/jvm-bug-thread">http://www.infoq.com/cn/articles/jvm-bug-thread</a></p>

<h2>JVM线程dump Bug描述</h2>

<p>&#8195;&#8195;在JAVA语言中，当同步块(<code>Synchronized</code>)被多个线程并发访问时，JVM中会采用基于互斥实现的重量级锁。JVM最多只允许一个线程持有这把锁，如果其它线程想要获得这把锁就必须处于等待状态，也就是说在同步块被并发访问时，最多只会有一个处于<code>RUNNABLE</code>状态的线程持有某把锁，而另外的线程因为竞争不到这把锁而都处于<code>BLOCKED</code>状态。然而有些时候我们会发现处于<code>BLOCKED</code>状态的线程，它的最上面那一帧在打印其正在等待的锁对象时，居然也会出现-locked的信息，这个信息和持有该锁的线程打印出来的结果是一样的(请看下图)，但是对比其他<code>BLOCKED</code>态的线程却并没有都出现这种情况。当我们再次dump线程时又可能出现不一样的结果。测试表明这可能是一个偶发的情况，本文就是针对这种情况对JVM内部的实现做了一个研究以寻找其根源。</p>

<!--more-->


<p><img src="http://nijiaben.github.io/images/2014/07/thread_dump_bug.jpg"></p>

<h2>JStack命令的整个过程</h2>

<p>&#8195;&#8195;上面提到了线程dump，那么就不得不提执行线程dump的工具&#8212;jstack，这个工具是Java自带的工具，和Java处于同一个目录下，主要是用来dump线程的，或许大家也有使用kill -3的命令来dump线程，但这两者最明显的一个区别是，前者的dump内容是由jstack这个进程来输出的，目标JVM进程将dump内容发给jstack进程(注意这是没有加-m参数的场景，指定-m参数就有点不一样了，它使用的是serviceability agent的api来实现的，底层通过ptrace的方式来获取目标进程的内容，执行过程可能会比正常模式更长点)，这意味着可以做文件重定向，将线程dump内容输出到指定文件里；而后者是由目标进程输出的，只会产生在目标进程的标准输出文件里，如果正巧标准输出里本身就有内容的话，看起来会比较乱，比如想通过一些分析工具去分析的话，要是该工具没有做过滤操作，很可能无法分析。因此一般情况我们尽量使用jstack，另外jstack还有很多实用的参数，比如<code>jstack pid &gt;thread_dump.log</code>，该命令会将指定pid的进程的线程dump到当前目录的thread_dump.log文件里。</p>

<p>&#8195;&#8195;jstack是使用Java实现的，它通过给目标JVM进程发送一个threaddump的命令，目标JVM的监听线程（<code>attachListener</code>）会实时监听传过来的命令(其实attachListener线程并不是一启动就创建的，它是lazy创建启动的)，当attachListener收到threaddump命令时会调用thread_dump的方法来处理dump操作(方法在attachListener.cpp里)。</p>

<pre class="prettyPrint">
static jint thread_dump(AttachOperation* op, outputStream* out) {
  bool print_concurrent_locks = false;
  if (op->arg(0) != NULL && strcmp(op->arg(0), "-l") == 0) {
    print_concurrent_locks = true;
  }

  // thread stacks
  VM_PrintThreads op1(out, print_concurrent_locks);
  VMThread::execute(&op1);

  // JNI global handles
  VM_PrintJNI op2(out);
  VMThread::execute(&op2);

  // Deadlock detection
  VM_FindDeadlocks op3(out);
  VMThread::execute(&op3);

  return JNI_OK;
}
</pre>


<p>&#8195;&#8195;从上面的方法可以看到，jstack命令执行了三个操作：</p>

<ul>
<li><code>VM_PrintThreads</code>：打印线程栈</li>
<li><code>VM_PrintJNI</code>：打印JNI</li>
<li><code>VM_FindDeadlocks</code>：打印死锁</li>
</ul>


<p>&#8195;&#8195;三个操作都是交给VMThread线程去执行的，VMThread线程在整个JAVA进程有且只会有一个。可以想象一下VMThread线程的简单执行过程：不断地轮询某个任务列表并在有任务时依次执行任务。任务执行时，它会根据具体的任务决定是否会暂停整个应用，也就是stop the world，这是不是让我们联想到了我们熟悉的GC过程？是的，我们的ygc以及cmsgc的两个暂停应用的阶段(init_mark和remark)都是由这个线程来执行的，并且都要求暂停整个应用。其实上面的三个操作都是要求暂停整个应用的，也就是说jstack触发的线程dump过程也是会暂停应用的，只是这个过程一般很快就结束，不会有明显的感觉。另外内存dump的jmap命令，也是会暂停整个应用的，如果使用了-F的参数，其底层也是使用serviceability agent的api来dump的，但是dump内存的速度会明显慢很多。</p>

<h2>VMThread执行任务的过程</h2>

<p>&#8195;&#8195;VMThread执行的任务称为vm_opration，在JVM中存在两种vm_opration，一种是需要在安全点内执行的(所谓安全点，就是系统处于一个安全的状态，除了VMThread这个线程可以正常运行之外，其他的线程都必须暂停执行，在这种情况下就可以放心执行当前的一系列vm_opration了)，另外一种是不需要在安全点内执行的。而这次我们讨论的线程dump是需要在安全点内执行的。</p>

<p>&#8195;&#8195;以下是VMThread轮询的逻辑:</p>

<pre class="prettyPrint">
void VMThread::loop() {
  assert(_cur_vm_operation == NULL, "no current one should be executing");

  while(true) {
    ...
    //已经获取了一个vm_operation
    if (_cur_vm_operation->evaluate_at_safepoint()) {
        //如果该vm_operation需要在安全点内执行
        _vm_queue->set_drain_list(safepoint_ops); 
        SafepointSynchronize::begin();//进入安全点
        evaluate_operation(_cur_vm_operation);
        do {
          _cur_vm_operation = safepoint_ops;
          if (_cur_vm_operation != NULL) {
            do {
              VM_Operation* next = _cur_vm_operation->next();
              _vm_queue->set_drain_list(next);
              evaluate_operation(_cur_vm_operation);
              _cur_vm_operation = next;
              if (PrintSafepointStatistics) {
                SafepointSynchronize::inc_vmop_coalesced_count();
              }
            } while (_cur_vm_operation != NULL);
          }
          if (_vm_queue->peek_at_safepoint_priority()) {
            MutexLockerEx mu_queue(VMOperationQueue_lock,
                                     Mutex::_no_safepoint_check_flag);
            safepoint_ops = _vm_queue->drain_at_safepoint_priority();
          } else {
            safepoint_ops = NULL;
          }
        } while(safepoint_ops != NULL);
        _vm_queue->set_drain_list(NULL);
        SafepointSynchronize::end();//退出安全点
      } else {  // not a safepoint operation
        if (TraceLongCompiles) {
          elapsedTimer t;
          t.start();
          evaluate_operation(_cur_vm_operation);
          t.stop();
          double secs = t.seconds();
          if (secs * 1e3 > LongCompileThreshold) {
            tty->print_cr("vm %s: %3.7f secs]", _cur_vm_operation->name(), secs);
          }
        } else {
            evaluate_operation(_cur_vm_operation);
        }
        _cur_vm_operation = NULL;
      }
    }
    ...
  }
</pre>


<p></p>

<p>&#8195;&#8195;在这里重点解释下在安全点内执行的vm_opration的过程，VMThread通过不断循环从_vm_queue中获取一个或者几个需要在安全点内执行的vm_opertion，然后在准备执行这些vm_opration之前先通过调用<code>SafepointSynchronize::begin()</code>进入到安全点状态，在执行完这些vm_opration之后，调用<code>SafepointSynchronize::end()</code>，退出安全点模式，恢复之前暂停的所有线程让他们继续运行。对于安全点这块的逻辑挺复杂的，仅仅需要记住在进入安全点模式的时候会持有Threads_lock这把线程互斥锁，对线程的操作都需要获取到这把锁才能继续执行，并且还会设置安全点的状态，如果正在进入安全点过程中设置_state为_synchronizing，当所有线程都完全进入了安全点之后设置_state为_synchronized状态，退出的时候设置为_not_synchronized状态。</p>

<pre class="prettyPrint">
void SafepointSynchronize::begin() {
  ...
  Threads_lock->lock();
  ...
  _state            = _synchronizing;
  ...
   _state = _synchronized;
...
}

void SafepointSynchronize::end() {
    assert(Threads_lock->owned_by_self(), "must hold Threads_lock");
    ...
    _state = _not_synchronized;
    ...
    Threads_lock->unlock();
}
</pre>


<h2>线程Dump中的VM_PrintThreads过程</h2>

<p>&#8195;&#8195;回到开头提到的JVM线程Dump时的Bug，从我们打印的结果来看也基本猜到了这个过程：遍历每个Java线程，然后再遍历每一帧，打印该帧的一些信息(包括类，方法名，行数等)，在打印完每一帧之后然后打印这帧已经关联了的锁信息，下面代码就是打印每个线程的过程:</p>

<pre class="prettyPrint">
void JavaThread::print_stack_on(outputStream* st) {
  if (!has_last_Java_frame()) return;
  ResourceMark rm;
  HandleMark   hm;

  RegisterMap reg_map(this);
  vframe* start_vf = last_java_vframe(®_map);
  int count = 0;
  for (vframe* f = start_vf; f; f = f->sender() ) {
    if (f->is_java_frame()) {
      javaVFrame* jvf = javaVFrame::cast(f);
      java_lang_Throwable::print_stack_element(st, jvf->method(), jvf->bci());
      if (JavaMonitorsInStackTrace) {
        jvf->print_lock_info_on(st, count);
      }
    } else {
      // Ignore non-Java frames
    }
    count++;
    if (MaxJavaStackTraceDepth == count) return;
  }
}
</pre>


<p>&#8195;&#8195;和我们这次问题相关的逻辑，也就是打印<code>"-locked"</code>的信息是正好是在<code>jvf-&gt;print_lock_info_on(st, count)</code>这行里面，请看具体实现:</p>

<pre class="prettyPrint">
void javaVFrame::print_lock_info_on(outputStream* st, int frame_count) {
  ResourceMark rm;
  if (frame_count == 0) {
    if (method()->name() == vmSymbols::wait_name() &&
        instanceKlass::cast(method()->method_holder())->name() == vmSymbols::java_lang_Object()) {
      StackValueCollection* locs = locals();
      if (!locs->is_empty()) {
        StackValue* sv = locs->at(0);
        if (sv->type() == T_OBJECT) {
          Handle o = locs->at(0)->get_obj();
          print_locked_object_class_name(st, o, "waiting on");
        }
      }
    } else if (thread()->current_park_blocker() != NULL) {
      oop obj = thread()->current_park_blocker();
      Klass* k = Klass::cast(obj->klass());
      st->print_cr("\t- %s <" INTPTR_FORMAT "> (a %s)", "parking to wait for ", (address)obj, k->external_name());
    }
  }

  GrowableArray<MonitorInfo*>* mons = monitors();
  if (!mons->is_empty()) {
    bool found_first_monitor = false;
    for (int index = (mons->length()-1); index >= 0; index--) {
      MonitorInfo* monitor = mons->at(index);
      if (monitor->eliminated() && is_compiled_frame()) {
        if (monitor->owner_is_scalar_replaced()) {
          Klass* k = Klass::cast(monitor->owner_klass());
          st->print("\t- eliminated <owner is scalar replaced> (a %s)", k->external_name());
        } else {
          oop obj = monitor->owner();
          if (obj != NULL) {
            print_locked_object_class_name(st, obj, "eliminated");
          }
        }
        continue;
      }
      if (monitor->owner() != NULL) {
        const char *lock_state = "locked";
        if (!found_first_monitor && frame_count == 0) {
          markOop mark = monitor->owner()->mark();
          if (mark->has_monitor() &&
              mark->monitor() == thread()->current_pending_monitor()) {
            lock_state = "waiting to lock";
          }
        }
        found_first_monitor = true;
        print_locked_object_class_name(st, monitor->owner(), lock_state);
      }
    }
  }
}
</pre>


<p>&#8195;&#8195;看到上面的方法，再对比线程dump的结果，我们会发现很多熟悉的东西，比如<code>waiting on</code>，<code>parking to wait for</code>，<code>locked</code>，<code>waiting to lock</code>，而且也清楚了它们分别是在什么情况下会打印的。</p>

<p>&#8195;&#8195;那为什么我们的例子中BLOCKED状态的线程本应该打印<code>waiting to lock</code>,但是为什么却打印了<code>locked</code>呢，那说明<code>if (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor() == thread()-&gt;current_pending_monitor())</code> 这个条件肯定不成立，那这个在什么情况下不成立呢？在验证此问题前，有必要先了解下markOop是什么东西，它是用来干什么的？</p>

<h2>markOop是什么</h2>

<p>&#8195;&#8195;markOop描述了一个对象(也包括了Class)的状态信息，Java语法层面的每个对象或者Class在JVM的结构表示中都会包含一个markOop作为Header，当然还有一些其他的JVM数据结构也用它做Header。markOop由32位或者64位构成，具体位数根据运行环境而定。</p>

<p>&#8195;&#8195;下面的结构图包含markOop每一位所代表的含义，markOop的值根据所描述的对象的类型(比如是锁对象还是正常的对象)以及作用的不同而不同。就算在同一个对象里，它的值也是可能会不断变化的，比如锁对象，在一开始创建的时候其实并不知道是锁对象，会当成一个正常对象来创建(在对象的类型并没有设置偏向锁的情况下，其markOop值可能是0x1)，但是随着我们执行到synchronized的代码逻辑时，就知道其实它是一个锁对象了，它的值就不再是0x1了，而是一个新的值，该值是对应栈帧结构里的监控对象列表里的某一个内存地址。</p>

<pre class="prettyPrint">
//  32 bits:
//  --------
//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
//             size:32 ------------------------------------------>| (CMS free block)
//             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)
//
//  64 bits:
//  --------
//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)
//  size:64 ----------------------------------------------------->| (CMS free block)
//
//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)
//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)
//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)
//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)
</pre>


<p>&#8195;&#8195;就最后的3位而言，其不同的值代表不同的含义：</p>

<pre class="prettyPrint">
 enum { locked_value             = 0,//00
         unlocked_value           = 1,//01
         monitor_value            = 2,//10
         marked_value             = 3,//11      
         biased_lock_pattern      = 5 //101
  };
</pre>


<p></p>

<p>&#8195;&#8195;上面的判断条件<code>“mark-&gt;has_monitor()”</code>其实就是判断最后的2位是不是10，如果是，则说明这个对象是一个监控对象，可以通过<code>mark-&gt;monitor()</code>方法获取到对应的结构体：</p>

<pre class="prettyPrint">
bool has_monitor() const {
    return ((value() & monitor_value) != 0);
  }
  ObjectMonitor* monitor() const {
    assert(has_monitor(), "check");
    // Use xor instead of &~ to provide one extra tag-bit check.
    return (ObjectMonitor*) (value() ^ monitor_value);
  }
</pre>


<p></p>

<p>&#8195;&#8195;将一个普通对象转换为一个monitor对象的过程(就是替换markOop的值)请参考为<code>ObjectSynchronizer::inflate</code>方法，能进入到该方法说明该锁为重量级锁，也就是说这把锁其实是被多个线程竞争的。</p>

<p>&#8195;&#8195;了解了markOop之后，还要了解下上面那个条件里的<code>thread()-&gt;current_pending_monitor()</code>，也就是这个值是什么时候设置进去的呢?</p>

<h2>线程设置等待的监控对象的时机</h2>

<p>&#8195;&#8195;设置的逻辑在<code>ObjectMonitor::enter</code>里，关键代码如下：</p>

<pre class="prettyPrint">
...
{
    JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);
    DTRACE_MONITOR_PROBE(contended__enter, this, object(), jt);
    if (JvmtiExport::should_post_monitor_contended_enter()) {
      JvmtiExport::post_monitor_contended_enter(jt, this);
    }
    OSThreadContendState osts(Self->osthread());
    ThreadBlockInVM tbivm(jt);
    Self->set_current_pending_monitor(this);//设置当前monitor对象为当前线程等待的monitor对象
    for (;;) {
      jt->set_suspend_equivalent();
      EnterI (THREAD) ;
      if (!ExitSuspendEquivalent(jt)) break ;
          _recursions = 0 ;
      _succ = NULL ;
      exit (false, Self) ;

      jt->java_suspend_self();
    }
    Self->set_current_pending_monitor(NULL);
  }
 ... 
</pre>


<p></p>

<p>&#8195;&#8195;设置当前线程等待的monitorObject是在有中文注释的那一行设置的，那么出现Bug的原因是不是正好在设置之前进行了线程dump呢？</p>

<h2>水落石出</h2>

<p>&#8195;&#8195;在JVM中只会有一个处于RUNNBALE状态的线程，也就是说另外一个打印<code>"-locked"</code>信息的线程是处于BLOCKED状态的。上面的第一行代码：</p>

<pre class="prettyPrint">
JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);
</pre>


<p>&#8195;&#8195;找到其实现位置：</p>

<pre class="prettyPrint">
 JavaThreadBlockedOnMonitorEnterState(JavaThread *java_thread, ObjectMonitor *obj_m) :
    JavaThreadStatusChanger(java_thread) {
    assert((java_thread != NULL), "Java thread should not be null here");
    _active = false;
    if (is_alive() && ServiceUtil::visible_oop((oop)obj_m->object()) && obj_m->contentions() > 0) {
      _stat = java_thread->get_thread_stat();
      _active = contended_enter_begin(java_thread);//关键处
    }
  }

 static bool contended_enter_begin(JavaThread *java_thread) {
    set_thread_status(java_thread, java_lang_Thread::BLOCKED_ON_MONITOR_ENTER);//关键处
    ThreadStatistics* stat = java_thread->get_thread_stat();
    stat->contended_enter();
    bool active = ThreadService::is_thread_monitoring_contention();
    if (active) {
      stat->contended_enter_begin();
    }
    return active;
  } 
</pre>


<p></p>

<p>&#8195;&#8195;上面的contended_enter_begin方法会设置java线程的状态为<code>java_lang_Thread::BLOCKED_ON_MONITOR_ENTER</code>，而线程dump时根据这个状态打印的结果如下：</p>

<pre class="prettyPrint">
const char* java_lang_Thread::thread_status_name(oop java_thread) {
  assert(JDK_Version::is_gte_jdk15x_version() && _thread_status_offset != 0, "Must have thread status");
  ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread->int_field(_thread_status_offset);
  switch (status) {
    case NEW                      : return "NEW";
    case RUNNABLE                 : return "RUNNABLE";
    case SLEEPING                 : return "TIMED_WAITING (sleeping)";
    case IN_OBJECT_WAIT           : return "WAITING (on object monitor)";
    case IN_OBJECT_WAIT_TIMED     : return "TIMED_WAITING (on object monitor)";
    case PARKED                   : return "WAITING (parking)";
    case PARKED_TIMED             : return "TIMED_WAITING (parking)";
    case BLOCKED_ON_MONITOR_ENTER : return "BLOCKED (on object monitor)";
    case TERMINATED               : return "TERMINATED";
    default                       : return "UNKNOWN";
  };
}
</pre>


<p>&#8195;&#8195;正好对应我们dump日志中的信息<code>"BLOCKED (on object monitor)"</code>也就是说这行代码被正常执行了，那问题就可能出在<code>JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this)</code>和<code>Self-&gt;set_current_pending_monitor(this)</code>这两行代码之间的逻辑里了：</p>

<pre class="prettyPrint">
    JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);
    DTRACE_MONITOR_PROBE(contended__enter, this, object(), jt);
    if (JvmtiExport::should_post_monitor_contended_enter()) {
      JvmtiExport::post_monitor_contended_enter(jt, this);
    }
    OSThreadContendState osts(Self->osthread());
    ThreadBlockInVM tbivm(jt);
    Self->set_current_pending_monitor(this);//设置当前monitor对象为当前线程等待的monitor对象
</pre>


<p>&#8195;&#8195;于是检查每一行的实现，前面几行都基本可以排除了，因为它们都是很简单的操作，下面来分析下<code>ThreadBlockInVM tbivm(jt)</code>这一行的实现：</p>

<pre class="prettyPrint">
ThreadBlockInVM(JavaThread *thread)
  : ThreadStateTransition(thread) {
    thread->frame_anchor()->make_walkable(thread);
    trans_and_fence(_thread_in_vm, _thread_blocked);
  }

 void trans_and_fence(JavaThreadState from, JavaThreadState to) { 
    transition_and_fence(_thread, from, to); 
 }

 static inline void transition_and_fence(JavaThread *thread, JavaThreadState from, JavaThreadState to) {
    assert(thread->thread_state() == from, "coming from wrong thread state");
    assert((from & 1) == 0 && (to & 1) == 0, "odd numbers are transitions states");
    thread->set_thread_state((JavaThreadState)(from + 1));
    if (os::is_MP()) {
      if (UseMembar) {
        OrderAccess::fence();
      } else {
        InterfaceSupport::serialize_memory(thread);
      }
    }

    if (SafepointSynchronize::do_call_back()) {
      SafepointSynchronize::block(thread);
    }
    thread->set_thread_state(to);
    CHECK_UNHANDLED_OOPS_ONLY(thread->clear_unhandled_oops();)
  }
 ...
 } 
 </pre>


<p>&#8195;&#8195;也许我们看到可能造成问题的代码了：</p>

<pre class="prettyPrint">
if (SafepointSynchronize::do_call_back()) {
      SafepointSynchronize::block(thread);
}
</pre>


<p>  <br/>
&#8195;&#8195;想象一下，当这个线程正好执行到这个条件判断，然后进去了，从方法名上来说是不是意味着这个线程会block住，并且不往后走了呢？这样一来设置当前线程的pending_monitor对象的操作就不会被执行了，从而在打印这个线程栈的时候就会打印&#8221;-locked&#8221;信息了，那么纠结是否正如我们想的那样呢？</p>

<p>首先来看条件<code>SafepointSynchronize::do_call_back()</code>是否一定会成立：</p>

<pre class="prettyPrint">
inline static bool do_call_back() {
    return (_state != _not_synchronized);
}
</pre>


<p>&#8195;&#8195;上面的VMThread执行任务的过程中说到了这个状态，当vmThread执行完了<code>SafepointSynchronize::begin()</code>之后，这个状态是设置为_synchronized的。如果正在执行，那么状态是_synchronizing，因此，当我们触发了jvm的线程dump之后，VMThread执行该操作，而且还在执行线程dump过程前，但是还只是_synchronizing的状态，那么do_call_back()将会返回true，那么将执行接下来的SafepointSynchronize::block(thread)方法：</p>

<pre class="prettyPrint">
void SafepointSynchronize::block(JavaThread *thread) {
  assert(thread != NULL, "thread must be set");
  assert(thread->is_Java_thread(), "not a Java thread");

  ttyLocker::break_tty_lock_for_safepoint(os::current_thread_id());

  if (thread->is_terminated()) {
     thread->block_if_vm_exited();
     return;
  }

  JavaThreadState state = thread->thread_state();
  thread->frame_anchor()->make_walkable(thread);

  switch(state) {
    case _thread_in_vm_trans:
    case _thread_in_Java:        // From compiled code
      thread->set_thread_state(_thread_in_vm);

      if (is_synchronizing()) {
         Atomic::inc (&TryingToBlock) ;
      }
      Safepoint_lock->lock_without_safepoint_check();
      if (is_synchronizing()) {
        assert(_waiting_to_block > 0, "sanity check");
        _waiting_to_block--;
        thread->safepoint_state()->set_has_called_back(true);

        DEBUG_ONLY(thread->set_visited_for_critical_count(true));
        if (thread->in_critical()) {
          increment_jni_active_count();
        }
        if (_waiting_to_block == 0) {
          Safepoint_lock->notify_all();
        }
      }
      thread->set_thread_state(_thread_blocked);
      Safepoint_lock->unlock();
      Threads_lock->lock_without_safepoint_check();//关键代码
      thread->set_thread_state(state);
      Threads_lock->unlock();
      break;
   ...
  }
  if (state != _thread_blocked_trans &&
      state != _thread_in_vm_trans &&
      thread->has_special_runtime_exit_condition()) {
    thread->handle_special_runtime_exit_condition(
      !thread->is_at_poll_safepoint() && (state != _thread_in_native_trans));
  }
}

void Monitor::lock_without_safepoint_check (Thread * Self) {
  assert (_owner != Self, "invariant") ;
  ILock (Self) ;
  assert (_owner == NULL, "invariant");
  set_owner (Self);
}

void Monitor::lock_without_safepoint_check () {
  lock_without_safepoint_check (Thread::current()) ;
}
</pre>


<p>&#8195;&#8195;看到上面的实现可以确定，Java线程执行时会调用<code>Threads_lock-&gt;lock_without_safepoint_check()</code>，而Threads_lock因为被VMThread持有，将一直卡死在<code>ILock (Self)</code>这个逻辑里，从而没有设置current_monitor属性，由此验证了我们的想法。</p>

<h2>Bug修复</h2>

<p>&#8195;&#8195;在了解了原因之后，我们可以简单的修复这个Bug。将下面两行代码调换下位置即可：</p>

<pre class="prettyPrint">
 ThreadBlockInVM tbivm(jt);
 Self->set_current_pending_monitor(this);//设置当前monitor对象为当前线程等待的monitor对象
</pre>


<p>
&#8195;&#8195;该Bug不会对生产环境产生影响，本文主要是和大家分享分析问题的过程，希望大家碰到疑惑都能有一查到底的劲儿，带着问题，不断提出自己的猜想，然后不断验证自己的猜想，最终解决问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从日志上理解JAVA调试机制]]></title>
    <link href="http://nijiaben.github.io/blog/2014/07/19/java-debug-log/"/>
    <updated>2014-07-19T09:58:49+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/07/19/java-debug-log</id>
    <content type="html"><![CDATA[<p>&#8195;&#8195;JAVA调试我想大家都玩过，或许因为非常完美地集成到了我们日常的IDE里，比如eclipse，netbeans，可是大家有没有想过它是怎么实现的呢，接下来我会从vm中打印的调试日志来跟大家认识下这个调试体系。</p>

<!--more-->


<p>&#8195;&#8195;大家都是一点IDE里面的调试按钮，就轻松建立了调试环境，IDE其实是帮你做了些你可能不知道的事，请看如下图</p>

<p><img src="http://nijiaben.github.io/images/2014/07/debug.jpg"></p>

<p>&#8195;&#8195;你将会看到如下内容</p>

<p><img src="http://nijiaben.github.io/images/2014/07/eclipse_command.jpg"></p>

<p>&#8195;&#8195;其实这就是eclipse为你构建的命令行，从中筛选出如下命令行语句</p>

<pre class="prettyPrint">
-agentlib:jdwp=transport=dt_socket,suspend=y,address=localhost:51823 
</pre>


<p>&#8195;&#8195;这就是关键了，熟悉agent的人应该都知道这是加载了一个叫做jdwp的agent，也就是说vm会去找一个叫做<code>libjdwp.so/libjdwp.dylib</code>的动态库，于是通过nm看看里面究竟有些什么方法？</p>

<pre class="prettyPrint">
nijiaben@nijiaben : ~/Developer/open_source/openjdk/jdk7u/build/macosx-x86_64-debug/lib
[0] % nm libjdwp.dylib
00000000000152b0 T _Agent_OnLoad
0000000000016520 T _Agent_OnUnload
00000000000531c0 D _ArrayReference_Cmds
00000000000531e0 D _ArrayType_Cmds
0000000000053230 D _ClassLoaderReference_Cmds
0000000000053240 D _ClassObjectReference_Cmds
0000000000053200 D _ClassType_Cmds
0000000000053260 D _EventRequest_Cmds
0000000000053f88 S _Field_Cmds
0000000000053280 D _Method_Cmds
0000000000053668 b _NullString
00000000000532c0 D _ObjectReference_Cmds
0000000000053320 D _ReferenceType_Cmds
00000000000533c0 D _StackFrame_Cmds
00000000000533f0 D _StringReference_Cmds
0000000000053400 D _ThreadGroupReference_Cmds
0000000000053420 D _ThreadReference_Cmds
00000000000534c0 D _VirtualMachine_Cmds
</pre>


<p>&#8195;&#8195;赫然看到了Agent的几个方法，<em>Agent_OnLoad和</em>Agent_OnUnLoad，于是更加肯定这个动态库就是一个agent实例了。
有了它自然想看看这个Agent加载的时候干了些什么事。先不急于看里面的实现，一个好的模块或者应用，往往通过详细的日志就可以知道它的大致情况，其实jdwp也是有详细的日志可看的，在上面的-agentlib:jdwp后面再加上一个参数logflags=0xfff，即-agentlib:jdwp=transport=dt_socket,suspend=y,logflags=0xfff，然后再次执行java命令，你将会在你的当前目录下生成一个类似jdwp.log.297的文件，297其实是进程的ID，那当我们仅仅是启动，还没有做任何操作的时候jdwp都干了些什么？</p>

<pre class="prettyPrint">
[#|29.05.2013 21:20:18.161 CST|FINEST|J2SE1.5|jdwp|LOC=MISC:"debugInit.c":296;;PID=297;THR=t@60821504|:Onload: transport=dt_socket,address=8000,server=y,suspend=n,logflags=0xfff|#]
[#|29.05.2013 21:20:18.161 CST|FINEST|J2SE1.5|jdwp|LOC=JVMTI:"debugInit.c":300;;PID=297;THR=t@60821504|:GetPotentialCapabilities()|#]
[#|29.05.2013 21:20:18.161 CST|FINEST|J2SE1.5|jdwp|LOC=JVMTI:"debugInit.c":359;;PID=297;THR=t@60821504|:AddCapabilities()|#]
[#|29.05.2013 21:20:18.161 CST|FINEST|J2SE1.5|jdwp|LOC=JVMTI:"debugInit.c":128;;PID=297;THR=t@60821504|:SetEventNotificationMode()|#]
[#|29.05.2013 21:20:18.161 CST|FINEST|J2SE1.5|jdwp|LOC=JVMTI:"debugInit.c":128;;PID=297;THR=t@60821504|:SetEventNotificationMode()|#]
[#|29.05.2013 21:20:18.161 CST|FINEST|J2SE1.5|jdwp|LOC=JVMTI:"debugInit.c":390;;PID=297;THR=t@60821504|:SetEventCallbacks()|#]
[#|29.05.2013 21:20:18.161 CST|FINEST|J2SE1.5|jdwp|LOC=MISC:"debugInit.c":398;;PID=297;THR=t@60821504|:OnLoad: DONE|#]
</pre>


<p>&#8195;&#8195;由于篇幅的问题，就只把部分日志列出来解释下，从上面我们可以获得的执行的时间，执行的环境类型，执行的哪个文件的哪一行，进程ID，线程地址，然后就是真正的日志信息等。
首先看看LOC，是location_type的简称，那么它包括多少种呢，我想从下面的宏定义上可以看出来</p>

<pre class="prettyPrint">
#define    JDWP_LOG_JVM         0x00000001
#define    JDWP_LOG_JNI         0x00000002
#define    JDWP_LOG_JVMTI       0x00000004
#define    JDWP_LOG_MISC        0x00000008
#define    JDWP_LOG_STEP        0x00000010
#define    JDWP_LOG_LOC         0x00000020
#define    JDWP_LOG_CB          0x00000040
#define    JDWP_LOG_ERROR       0x00000080
#define    JDWP_LOG_ALL         0xffffffff
</pre>


<p>&#8195;&#8195;agent的实现离不开jvmti，jdwp也同样如此，那么它究竟想利用jvmti里的哪些能力呢，从下面的代码基本可以看出来了</p>

<pre class="prettyPrint">
   /* Fill in ones that we must have */
    (void)memset(&needed_capabilities,0,sizeof(needed_capabilities));
    needed_capabilities.can_access_local_variables              = 1;
    needed_capabilities.can_generate_single_step_events         = 1;
    needed_capabilities.can_generate_exception_events           = 1;
    needed_capabilities.can_generate_frame_pop_events           = 1;
    needed_capabilities.can_generate_breakpoint_events          = 1;
    needed_capabilities.can_suspend                             = 1;
    needed_capabilities.can_generate_method_entry_events        = 1;
    needed_capabilities.can_generate_method_exit_events         = 1;
    needed_capabilities.can_generate_garbage_collection_events  = 1;
    needed_capabilities.can_maintain_original_method_order      = 1;
    needed_capabilities.can_generate_monitor_events             = 1;
    needed_capabilities.can_tag_objects                         = 1;

    /* And what potential ones that would be nice to have */
    needed_capabilities.can_force_early_return
                = potential_capabilities.can_force_early_return;
    needed_capabilities.can_generate_field_modification_events
                = potential_capabilities.can_generate_field_modification_events;
    needed_capabilities.can_generate_field_access_events
                = potential_capabilities.can_generate_field_access_events;
    needed_capabilities.can_get_bytecodes
                = potential_capabilities.can_get_bytecodes;
    needed_capabilities.can_get_synthetic_attribute
                = potential_capabilities.can_get_synthetic_attribute;
    needed_capabilities.can_get_owned_monitor_info
                = potential_capabilities.can_get_owned_monitor_info;
    needed_capabilities.can_get_current_contended_monitor
                = potential_capabilities.can_get_current_contended_monitor;
    needed_capabilities.can_get_monitor_info
                = potential_capabilities.can_get_monitor_info;
    needed_capabilities.can_pop_frame
                = potential_capabilities.can_pop_frame;
    needed_capabilities.can_redefine_classes
                = potential_capabilities.can_redefine_classes;
    needed_capabilities.can_redefine_any_class
                = potential_capabilities.can_redefine_any_class;
    needed_capabilities.can_get_owned_monitor_stack_depth_info
        = potential_capabilities.can_get_owned_monitor_stack_depth_info;
    needed_capabilities.can_get_constant_pool
                = potential_capabilities.can_get_constant_pool;
    {
        needed_capabilities.can_get_source_debug_extension      = 1;
        needed_capabilities.can_get_source_file_name            = 1;
        needed_capabilities.can_get_line_numbers                = 1;
        needed_capabilities.can_signal_thread
                = potential_capabilities.can_signal_thread;
    }
</pre>


<p>  <br/>
&#8195;&#8195;这就对为什么我们可以通过调试体系可以看到本地变量的值，可以一步一步push/pop frame等能力不足为奇了。
因为agent是在vm初始化过程中加载的，vm的环境其实很多还没准备好，所以jvmti提供了一种能力&#8212;事件通知，在某个特定事件发生的时候，agent可以通过注册一些回调事件来做一些特殊的工作，比如在vm初始化完成之后，在类文件加载之后，在类被加载之后等等都可以做一些相关的事情，jdwp主要注册了几个回调事件，重点是vm初始化的回调函数，此时才是真正的完成jdwp的初始化动作，这也是为什么我们的调试体系不能对所有的java代码进行跟踪的原因了，比如说AppClassLoader的创建过程，这个其实都是在vm初始化过程中创建的，但是这个时候jdwp还没有初始化呢，自然也无法完成我们的debug过程了。</p>

<pre class="prettyPrint">
    gdata->callbacks.VMInit             = &cbEarlyVMInit;
    gdata->callbacks.VMDeath            = &cbEarlyVMDeath;
    gdata->callbacks.Exception  = &cbEarlyException;
</pre>


<p>&#8195;&#8195;在cbEarlyVMInit中干的事就不细说了，可以通过jdwp的日志大概知道干了些啥，但是有点还是要说下，假设要大家去设计实现这个功能，大家应该都会想到它的通信场景，类似命令模式，客户端不断发命令到服务端，服务端收到命令之后然后将请求结果反馈回来，比如说我们把鼠标放到某个变量上面，我们会看到弹出个小提示板，会把这个对象的值树状列出来，其实jdwp也就是这么实现的，那我们就可能想知道jdwp到底提供了哪些命令</p>

<pre class="prettyPrint">
l1Array[JDWP_COMMAND_SET(VirtualMachine)] = (void *)VirtualMachine_Cmds;
    l1Array[JDWP_COMMAND_SET(ReferenceType)] = (void *)ReferenceType_Cmds;
    l1Array[JDWP_COMMAND_SET(ClassType)] = (void *)ClassType_Cmds;
    l1Array[JDWP_COMMAND_SET(ArrayType)] = (void *)ArrayType_Cmds;

    l1Array[JDWP_COMMAND_SET(Field)] = (void *)Field_Cmds;
    l1Array[JDWP_COMMAND_SET(Method)] = (void *)Method_Cmds;
    l1Array[JDWP_COMMAND_SET(ObjectReference)] = (void *)ObjectReference_Cmds;
    l1Array[JDWP_COMMAND_SET(StringReference)] = (void *)StringReference_Cmds;
    l1Array[JDWP_COMMAND_SET(ThreadReference)] = (void *)ThreadReference_Cmds;
    l1Array[JDWP_COMMAND_SET(ThreadGroupReference)] = (void *)ThreadGroupReference_Cmds;
    l1Array[JDWP_COMMAND_SET(ClassLoaderReference)] = (void *)ClassLoaderReference_Cmds;
    l1Array[JDWP_COMMAND_SET(ArrayReference)] = (void *)ArrayReference_Cmds;
    l1Array[JDWP_COMMAND_SET(EventRequest)] = (void *)EventRequest_Cmds;
    l1Array[JDWP_COMMAND_SET(StackFrame)] = (void *)StackFrame_Cmds;
    l1Array[JDWP_COMMAND_SET(ClassObjectReference)] = (void *)ClassObjectReference_Cmds;
</pre>


<p>&#8195;&#8195;从上面我们基本看到列出的都是分类，比如我们想看字段的，执行方法的，甚至vm的，那每个分类势必包含一些关键的命令，比如</p>

<pre class="prettyPrint">
void *VirtualMachine_Cmds[] = { (void *)21
    ,(void *)version
    ,(void *)classesForSignature
    ,(void *)allClasses
    ,(void *)getAllThreads
    ,(void *)topLevelThreadGroups
    ,(void *)dispose
    ,(void *)idSizes
    ,(void *)suspend
    ,(void *)resume
    ,(void *)doExit
    ,(void *)createString
    ,(void *)capabilities
    ,(void *)classPaths
    ,(void *)disposeObjects
    ,(void *)holdEvents
    ,(void *)releaseEvents
    ,(void *)capabilitiesNew
    ,(void *)redefineClasses
    ,(void *)setDefaultStratum
    ,(void *)allClassesWithGeneric
    ,(void *)instanceCounts
};
</pre>


<p>&#8195;&#8195;这就列出了我们想看vm相关信息或者操作的一些命令，其实这些都是一些function</p>

<pre class="prettyPrint">
[#|29.05.2013 21:21:22.439 CST|FINEST|J2SE1.5|jdwp|LOC=MISC:"debugLoop.c":153;;PID=297;THR=t@290471936|:Command set 1, command 10|#]
</pre>


<p>&#8195;&#8195;假如我们操作之后有上面这么一条日志，我们看到取的指令集合是1，想执行这个集合中的第10条命令，指令集合为1，说明取的是上面的llArray[1]，也就是上面的VirtualMachine指令集合，10表示我们找的是 VirtualMachine中的doExit这条指令，也就是说客户端希望你服务端执行这条指令，</p>

<pre class="prettyPrint">
static jboolean
doExit(PacketInputStream *in, PacketOutputStream *out)
{
    jint exitCode;

    exitCode = inStream_readInt(in);
    if (gdata->vmDead) {
        /* quietly ignore */
        return JNI_FALSE;
    }

    /* We send the reply from here because we are about to exit. */
    if (inStream_error(in)) {
        outStream_setError(out, inStream_error(in));
    }
    outStream_sendReply(out);

    forceExit(exitCode);

    /* Shouldn't get here */
    JDI_ASSERT(JNI_FALSE);

    /* Shut up the compiler */
    return JNI_FALSE;

}
/* All process exit() calls come from here */
void
forceExit(int exit_code)
{
    /* make sure the transport is closed down before we exit() */
    transport_close();
    exit(exit_code);
}
</pre>


<p>&#8195;&#8195;大家也猜到了，这其实就是退出vm，其实这也是我今天想写这篇文章的一个原因，我们这边线下环境一个系统，运行一段时间之后就突然间进程消失了，没有任何的日志，排除了人为的kill，System.exit，没有crash日志，更没有coredump，实在是诡异，跟了两天，突然在远程调试的时候发现了如下选项</p>

<p><img src="http://nijiaben.github.io/images/2014/07/eclipse_debug_kill.jpg"></p>

<p>&#8195;&#8195;所以我不得不猜想是它导致的，经过自己测试，当我点击</p>

<p><img src="http://nijiaben.github.io/images/2014/07/eclipse_debug_kill_button.jpg"></p>

<p>&#8195;&#8195;这个的时候，进程果然退出了，没有任何迹象，所以晚上花了点时间写了这篇文章记录下这诡异的问题</p>

<p>&#8195;&#8195;这个暂时就介绍到这里，虽然还比较肤浅，有机会再从原理角度介绍jdwp的具体实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDK的sql设计不合理导致的驱动类初始化死锁问题]]></title>
    <link href="http://nijiaben.github.io/blog/2014/07/08/jdk-sql-deadlock/"/>
    <updated>2014-07-08T16:39:46+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/07/08/jdk-sql-deadlock</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>&#8195;&#8195;当我们一个系统既需要mysql驱动，也需要oracle驱动的时候，在并发加载初始化这些驱动类的过程中产生死锁的可能性非常大，下面是一个模拟的例子，对于Thread2的实现其实是jdk里java.sql.DriverService的逻辑，也是我们第一次调用java.sql.DriverManager.registerDriver注册一个驱动实例要走的逻辑(jdk1.6下)，不过这篇文章是使用我们生产环境的一个系统的线程dump和内存dump为基础进行分析展开的。</p>

<!--more-->




<pre class="prettyPrint">

import java.util.Iterator;

import sun.misc.Service;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException {
        Thread1 thread1 = new Thread1();
        Thread2 thread2 = new Thread2();
        thread1.start();
        thread2.start();
    }
}

class Thread1 extends Thread {
    public void run() {
        try {
            Class<?> clazz = Class.forName("com.mysql.jdbc.Driver", true, Thread.currentThread()
                .getContextClassLoader());
            System.out.println(clazz);
        } catch (ClassNotFoundException e) {
        }
    }
}

class Thread2 extends Thread {
    public void run() {
        Iterator ps = Service.providers(java.sql.Driver.class);
        try {
            while (ps.hasNext()) {
                System.out.println(ps.next());
            } 
        } catch (Throwable t) {
           
        }
    }
}
</pre>


<p>&#8195;&#8195;如果以上代码运行过程中发现有线程一直卡死在Class.forName的调用里，那么说明问题已经重现了。</p>

<p>&#8195;&#8195;先上两张图</p>

<p><code>内存态线程堆栈</code></p>

<p><img src="http://nijiaben.github.io/images/2014/07/heap_thread_1.png"></p>

<p><code>线程堆栈</code></p>

<p><img src="http://nijiaben.github.io/images/2014/07/thread_1.png"></p>

<h2>存疑点</h2>

<p>&#8195;&#8195;仔细看看上面的线程dump分析和内存dump分析里的线程分析模块，您可能会有如下两个疑惑：</p>

<ul>
<li><p>【为什么线程[Thread-0]一直卡在Class.forName的位置】：这有点出乎意料，做一个类加载要么找不到抛出ClassNotFoundException，要么找到直接返回，为什么会一直卡在这个位置呢？</p></li>
<li><p>【明明[Thread-0]注册的是mysql驱动为什么会去加载Odbc的驱动类】：通过[Thread-0]在栈上看倒数第二帧展开看到传入Class.forName的参数是com.mysql.jdbc.Driver，然后展开栈上顺序第二帧，看到传入的参数是sun.jdbc.odbc.JdbcOdbcDriver，这意味着在对mysql驱动类做加载初始化的过程中又触发了JdbcOdbc驱动类的加载</p></li>
</ul>


<h2>疑惑点解释</h2>

<h3>疑惑二：</h3>

<p>&#8195;&#8195;第一个疑惑我们先留着，先解释下第二个疑惑，大家可以对照堆栈通过反编译rt.jar还有ojdbc6-11.2.0.3.0.jar看具体的代码</p>

<p><code>驱动类加载过程简要介绍:</code></p>

<p>&#8195;&#8195;当要注册某个sql驱动的时候是通过调用java.sql.DriverManager.registerDriver来实现的(注意这个方法加了synchronized关键字，后面解释第一个疑惑的时候是关键)，而这个方法在第一次执行过程中，会在当前线程classloader的classpath下寻找所有/META-INF/services/java.sql.Driver文件，这个文件在mysql和oracle驱动jar里都有，里面写的是对应的驱动实现类名，这种机制是jdk提供的spi实现，找到这些文件之后，依次使用Class.forName(driverClassName, true, this.loader)来对这些驱动类进行加载，其中第二个参数是true，意味着不仅仅做一次loadClass的动作，还会初始化该类，即调用包含静态块的&lt; clinit >方法，执行完之后才会返回，这样就解释了第二个疑惑，在mysql驱动注册过程中还会对odbc驱动类进行加载并初始化</p>

<p><code>感想:</code></p>

<p>&#8195;&#8195;其实我觉得这种设计有点傻，为什么要干和自己不相关的事情呢，画蛇添足的设计，首先类初始化的开销是否放到一起做并没有多大区别，其次正由于这种设计导致了今天这个死锁的发生</p>

<h3>疑惑一：</h3>

<p>&#8195;&#8195;现在来说第一个疑惑，为什么会一直卡在Class.forName呢，到底卡在哪里，于是再通过jstack -m <pid>命令将jvm里的堆栈也打印出来，如下所示</p>

<pre class="prettyPrint">
----------------- 5738 -----------------
0x003f67a2      _dl_sysinfo_int80 + 0x2
0xb79a71ae      _ZN2os13PlatformEvent4parkEv + 0xee
0xb7997acb      _ZN13ObjectMonitor4waitExbP6Thread + 0x5fb
0xb7a73c53      _ZN18ObjectSynchronizer19waitUninterruptiblyE6HandlexP6Thread + 0x53
0xb777eb34      _ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread + 0x74
0xb777e288      _ZN13instanceKlass10initializeEP6Thread + 0x58
0xb7821ad9      _Z28find_class_from_class_loaderP7JNIEnv_12symbolHandleh6HandleS2_hP6Thread + 0xb9
0xb7807d99      JVM_FindClassFromClassLoader + 0x269
0xb734c236      Java_java_lang_Class_forName0 + 0x116
0xb433064a      * java.lang.Class.forName0(java.lang.String, boolean, java.lang.ClassLoader) bci:0 (Interpreted frame)
0xb4328fa7      * java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader) bci:32 line:247 (Interpreted frame)
0xb4328fa7      * sun.misc.Service$LazyIterator.next() bci:31 line:271 (Interpreted frame)
0xb4329483      * java.sql.DriverService.run() bci:26 line:664 (Interpreted frame)
0xb43263e6      <StubRoutines>
0xb77a4e31      _ZN9JavaCalls11call_helperEP9JavaValueP12methodHandleP17JavaCallArgumentsP6Thread + 0x1c1
0xb79a6418      _ZN2os20os_exception_wrapperEPFvP9JavaValueP12methodHandleP17JavaCallArgumentsP6ThreadES1_S3_S5_S7_ + 0x18
0xb77a4c5f      _ZN9JavaCalls4callEP9JavaValue12methodHandleP17JavaCallArgumentsP6Thread + 0x2f
0xb780aace      JVM_DoPrivileged + 0x40e
0xb734b95d      Java_java_security_AccessController_doPrivileged__Ljava_security_PrivilegedAction_2 + 0x3d
0xb433064a      * java.security.AccessController.doPrivileged(java.security.PrivilegedAction) bci:0 (Interpreted frame)
0xb4328fa7      * java.sql.DriverManager.loadInitialDrivers() bci:31 line:506 (Interpreted frame)
0xb432910d      * java.sql.DriverManager.initialize() bci:11 line:612 (Interpreted frame)
0xb432910d      * java.sql.DriverManager.registerDriver(java.sql.Driver) bci:6 line:281 (Interpreted frame)
0xb432910d      * com.mysql.jdbc.Driver.<clinit>() bci:7 line:65 (Interpreted frame)
0xb43263e6      <StubRoutines>
0xb77a4e31      _ZN9JavaCalls11call_helperEP9JavaValueP12methodHandleP17JavaCallArgumentsP6Thread + 0x1c1
0xb79a6418      _ZN2os20os_exception_wrapperEPFvP9JavaValueP12methodHandleP17JavaCallArgumentsP6ThreadES1_S3_S5_S7_ + 0x18
0xb77a4c5f      _ZN9JavaCalls4callEP9JavaValue12methodHandleP17JavaCallArgumentsP6Thread + 0x2f
0xb77800c1      _ZN13instanceKlass27call_class_initializer_implE19instanceKlassHandleP6Thread + 0xa1
0xb777ed8e      _ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread + 0x2ce
0xb777e288      _ZN13instanceKlass10initializeEP6Thread + 0x58
0xb7821ad9      _Z28find_class_from_class_loaderP7JNIEnv_12symbolHandleh6HandleS2_hP6Thread + 0xb9
0xb7807d99      JVM_FindClassFromClassLoader + 0x269
0xb734c236      Java_java_lang_Class_forName0 + 0x116
0xb433064a      * java.lang.Class.forName0(java.lang.String, boolean, java.lang.ClassLoader) bci:0 (Interpreted frame)
0xb4328fa7      * java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader) bci:32 line:247 (Interpreted frame)
0xb4328fa7      * Thread1.run() bci:9 line:17 (Interpreted frame)

</pre>


<p>&#8195;&#8195;我们看到其实正在做类的初始化动作，并且线程正在调用ObjectSynchronizer::waitUninterruptibly一直没返回，在看这方法的调用者instanceKlass1::initialize_impl，我们找到源码位置如下：</p>

<pre class="prettyPrint">
void instanceKlass::initialize_impl(instanceKlassHandle this_oop, TRAPS) {
  // Make sure klass is linked (verified) before initialization
  // A class could already be verified, since it has been reflected upon.
  this_oop->link_class(CHECK);

  DTRACE_CLASSINIT_PROBE(required, instanceKlass::cast(this_oop()), -1);

  bool wait = false;

  // refer to the JVM book page 47 for description of steps
  // Step 1
  { ObjectLocker ol(this_oop, THREAD);

    Thread *self = THREAD; // it's passed the current thread

    // Step 2
    // If we were to use wait() instead of waitInterruptibly() then
    // we might end up throwing IE from link/symbol resolution sites
    // that aren't expected to throw.  This would wreak havoc.  See 6320309.
    while(this_oop->is_being_initialized() && !this_oop->is_reentrant_initialization(self)) {
        wait = true;
      ol.waitUninterruptibly(CHECK);
    }

    // Step 3
    if (this_oop->is_being_initialized() && this_oop->is_reentrant_initialization(self)) {
      DTRACE_CLASSINIT_PROBE_WAIT(recursive, instanceKlass::cast(this_oop()), -1,wait);
      return;
    }

    // Step 4
    if (this_oop->is_initialized()) {
      DTRACE_CLASSINIT_PROBE_WAIT(concurrent, instanceKlass::cast(this_oop()), -1,wait);
      return;
    }

    // Step 5
    if (this_oop->is_in_error_state()) {
      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, instanceKlass::cast(this_oop()), -1,wait);
      ResourceMark rm(THREAD);
      const char* desc = "Could not initialize class ";
      const char* className = this_oop->external_name();
      size_t msglen = strlen(desc) + strlen(className) + 1;
      char* message = NEW_RESOURCE_ARRAY(char, msglen);
      if (NULL == message) {
        // Out of memory: can't create detailed error message
        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);
      } else {
        jio_snprintf(message, msglen, "%s%s", desc, className);
        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);
      }
    }

    // Step 6
    this_oop->set_init_state(being_initialized);
    this_oop->set_init_thread(self);
  }
  ...
}
</pre>


<p><code>类的初始化过程:</code></p>

<p>&#8195;&#8195;当某个线程获得机会对某个类进行初始化的时候(请看上面的Step 6)，会设置这个类的init_state属性为being_initialized(如果初始化好了会设置为fully_initialized，异常的话会设置为initialization_error)，还会设置init_thread属性为当前线程，在这个设置过程中是有针对这个类提供了一把互斥锁的，因此当有别的线程进来的时候会被拦截在外面，如果设置完了，这把互斥锁也释放了，但是因为这个类的状态被设置了，因此并发问题也得到了解决，当另外一个线程也尝试初始化这个类的时候会判断这个类的状态是不是being_initialized，并且其init_thread不是当前线程，那么就会一直卡在那里，也就是此次线程dump的线程所处的状态，正在初始化类的线程会调用&lt; clinit >方法，如果正常结束了，那么就设置其状态为fully_initialized，并且通知之前卡在那里等待初始化完成的线程，然他们继续往下走(下一个动作就是再判断下状态，发现完成了就直接return了)</p>

<p><code>猜想:</code></p>

<p>&#8195;&#8195;在了解了上面的过程之后，于是我们猜测两种可能</p>

<ul>
<li>第一，这个类的状态还是being_intialized，还在while循环里没有跳出来</li>
<li>第二，事件通知机制出现了问题，也就是pthread_cond_wait和pthread_cond_signal之间的通信过程出现了问题。</li>
</ul>


<p>&#8195;&#8195;不过第二种可能性非常小，比较linux久经考验了，那接下来我们验证其实是第一个猜想</p>

<p><code>验证：</code></p>

<p>&#8195;&#8195;我们通过GDB attach的方式连到了问题机器上(好在机器没有挂)，首先我们要找到具体的问题线程，我们通过上面的jstack -m命令看到了线程ID是5738，然后通过info threads找到对应的线程，并得到它的序号14</p>

<pre class="prettyPrint">
(gdb) info threads
  17 process 5724  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  16 process 6878  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  15 process 5739  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  14 process 5738  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  13 process 5737  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  12 process 5736  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  11 process 5735  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  10 process 5734  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  9 process 5733  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  8 process 5732  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  7 process 5731  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  6 process 5730  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  5 process 5729  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  4 process 5728  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  3 process 5727  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  2 process 5726  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
  1 process 5725  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
</pre>


<p>
&#8195;&#8195;然后通过thread 14切换到对应的线程，并通过bt看到了如下的堆栈，正如我们想象的那样，正在做类的初始化，一直卡在那里</p>

<pre class="prettyPrint">
(gdb) thread 14
[Switching to thread 14 (process 5738)]#0  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
(gdb) bt
#0  0x003f67a2 in _dl_sysinfo_int80 () from /lib/ld-linux.so.2
#1  0x005e0d76 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/tls/i686/nosegneg/libpthread.so.0
#2  0x005e13ee in pthread_cond_wait@GLIBC_2.0 () from /lib/tls/i686/nosegneg/libpthread.so.0
#3  0xb79a71ae in os::PlatformEvent::park () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
#4  0xb7997acb in ObjectMonitor::wait () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
#5  0xb7a73c53 in ObjectSynchronizer::waitUninterruptibly () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
#6  0xb777eb34 in instanceKlass::initialize_impl () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
#7  0xb777e288 in instanceKlass::initialize () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
#8  0xb7821ad9 in find_class_from_class_loader () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
#9  0xb7807d99 in JVM_FindClassFromClassLoader () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/server/libjvm.so
#10 0xb734c236 in Java_java_lang_Class_forName0 () from /home/opt/taobao/install/jdk1.6.0_33/jre/lib/i386/libjava.so
#11 0xb433064a in ?? ()
#12 0x0813b120 in ?? ()
#13 0x70aaa690 in ?? ()
#14 0x70aaa6a0 in ?? ()
#15 0x00000001 in ?? ()
#16 0x70aaa698 in ?? ()
#17 0x00000000 in ?? ()

</pre>


<p>&#8195;&#8195;我们通过f 6选择第7帧，在通过disassemble反汇编该帧，也就是对instanceKlass::initialize_impl ()这个方法反汇编</p>

<pre class="prettyPrint">
0xb777eaed <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+45>:  lea    0xfffffff4(%ebp),%esp    //将%ebp偏移0xfffffff4位置的值存到%esp栈顶，然后下面的pop操作存到%ebx
0xb777eaf0 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+48>:  pop    %ebx
0xb777eaf1 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+49>:  pop    %esi
0xb777eaf2 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+50>:  pop    %edi
0xb777eaf3 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+51>:  pop    %ebp
0xb777eaf4 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+52>:  ret
0xb777eaf5 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+53>:  push   $0x1
0xb777eaf7 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+55>:  lea    0xffffffd8(%ebp),%edx
0xb777eafa <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+58>:  push   %esi
0xb777eafb <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+59>:  push   %ebx
0xb777eafc <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+60>:  push   %edx
0xb777eafd <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+61>:  call   0xb7a73a80 <_ZN12ObjectLockerC1E6HandleP6Threadb>
0xb777eb02 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+66>:  add    $0x10,%esp
0xb777eb05 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+69>:  xor    %eax,%eax
0xb777eb07 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+71>:  test   %ebx,%ebx
0xb777eb09 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+73>:  je     0xb777eb0d <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+77>
0xb777eb0b <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+75>:  mov    (%ebx),%eax      //将%ebx的值移到%eax
0xb777eb0d <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+77>:  cmpl   $0x4,0xe0(%eax)  //对比%eax偏移0xe0位置的值和0x4(这个值其实就是上面提到的being_initialized状态，这就说明了%eax偏移0xe0位置其实存的就是初始化类的初始化状态)
0xb777eb14 <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+84>:  jne    0xb777eb4f <_ZN13instanceKlass15initialize_implE19instanceKlassHandleP6Thread+143>
</pre>


<p>&#8195;&#8195;从上面的注释我们其实得出了，我们要看当前类的初始化状态，那就是看eax寄存器偏移0xe0的位置的值，而eax其实就是ebp寄存器偏移0xfffffff4位置的值，于是我们通过如下地址内存查到得到是4</p>

<pre class="prettyPrint">
(gdb) x $ebp + 0xfffffff4
0x70aaa45c: 0x71af2180
(gdb) x/3w 0x71af2180 + 0xe0
0x71af2260: 0x00000004  0x0813c800  0x0000001a
</pre>


<p>    <br/>
&#8195;&#8195;而4其实代表的就是being_initialized这个状态，代码如下</p>

<pre class="prettyPrint">
  enum ClassState {
    unparsable_by_gc = 0,               
    allocated,                          
    loaded,                             
    linked,                             
    being_initialized,                  
    fully_initialized,                  
    initialization_error                
  };
</pre>


<p>
&#8195;&#8195;从这于是我们验证了第一个猜想，其实是状态一直没有变更，因此一直卡在那里，为了更进一步确认这个问题，要是我们能找到该类的init_thread线程id就更清楚了，拿到这个ID我们就能看到这个线程栈，就知道它在干什么了，但是很遗憾，这个很难获取到，至少我一直没有找到办法，因为线程ID在线程对象里一直没有存，都是调用的os函数来获取的，得换个思路。</p>

<p>&#8195;&#8195;突然发现instanceKlass.hpp代码中得知两个属性原来是相邻的(init_state和init_thread)，于是断定下一个地址的值就代表是这个线程对象了，但是其属性何其多，找到想要的太不易了，最主要的是还担心自己看的代码和服务器上的jvm代码不一致，这样更蛋疼了，于是继续查看Thread.hpp中的JavaThread类，找到个关键字0xDEAD-2=0xDEAB,这个有可能是volatile TerminatedTypes _terminated属性的值，于是把线程对象打印出来，果然查到了关键字0xDEAB</p>

<pre class="prettyPrint">
(gdb) x/100w 0x0813c800
0x813c800:  0xb7bc06e8  0x00000000  0x00000000  0x00000000
0x813c810:  0x0813c488  0x0813d2c8  0x00000000  0x00000000
0x813c820:  0x080f9bf8  0x080f8b50  0x70a59b60  0x00000000
0x813c830:  0x00000000  0x00000000  0x00000000  0x00000000
0x813c840:  0x00014148  0x00000505  0x00000000  0x00000000
0x813c850:  0x00000000  0x00000000  0x00000000  0x3f800021
0x813c860:  0x00000001  0x00000023  0x3f800021  0x0001b530
0x813c870:  0x00000000  0x00000000  0x00000000  0x080ffdc0
0x813c880:  0x00000001  0x00000000  0x080ffe24  0x00000014
0x813c890:  0x00000031  0x00000000  0x00000000  0x0813dab0
0x813c8a0:  0x0813c428  0x0813ce98  0x70a5b000  0x00051000
0x813c8b0:  0x00000000  0xffffffff  0x00000000  0x080ffdc0
0x813c8c0:  0x00002bad  0x0813d400  0x0813d500  0x0813d700
0x813c8d0:  0x0813d800  0x00000000  0x00000000  0x104aa1ad
0x813c8e0:  0x544a5ab2  0x32378fc7  0x00008767  0x00000000
0x813c8f0:  0x00000000  0x00000000  0x0ee9547d  0x00000000
0x813c900:  0x00000000  0x00000000  0x0813b000  0x75878760
0x813c910:  0x70a59a94  0x00000000  0x70a59abc  0xb7829020
0x813c920:  0xb7bb7100  0x00000000  0x00000000  0x00000000
0x813c930:  0x00000000  0x00000000  0x00000000  0x00000000
0x813c940:  0x00000000  0x00000000  0x00000000  0x00000000
0x813c950:  0x00000000  0x00000000  0x00000000  0x0000000a
0x813c960:  0x0813da98  0x00000000  0x0000deab  0x00000001
0x813c970:  0x00000000  0x00000000  0x00000002  0x00000000
0x813c980:  0x00000000  0x00000000  0x00000000  0x00000000
</pre>


<p>&#8195;&#8195;因此顺着这个属性继续往上找，找到了_thread_state表示线程状态的值（向上偏移三个字），0x0000000a，即10，然后查看代码知道原来线程是出于block状态</p>

<pre class="prettyPrint">
 public:                                    
  volatile JavaThreadState _thread_state;
 private:
  ThreadSafepointState *_safepoint_state;        
  address               _saved_exception_pc;    
  volatile TerminatedTypes _terminated;
</pre>


<p><code>JavaThreadState</code></p>

<pre class="prettyPrint">
 enum JavaThreadState {
  _thread_uninitialized     =  0, 
  _thread_new               =  2, 
  _thread_new_trans         =  3, 
  _thread_in_native         =  4, 
  _thread_in_native_trans   =  5, 
  _thread_in_vm             =  6, 
  _thread_in_vm_trans       =  7, 
  _thread_in_Java           =  8, 
  _thread_in_Java_trans     =  9, 
  _thread_blocked           = 10, 
  _thread_blocked_trans     = 11, 
  _thread_max_state         = 12  
};
</pre>


<p>&#8195;&#8195;这样一来查看下线程dump，发现<code>Thread-1</code>正好处于BLOCKED状态，也就是说Thread-1就是那个正在对mysql驱动类做初始化的线程，这说明<code>Thread-0</code>和<code>Thread-1</code>成功互锁了</p>

<p>&#8195;&#8195;于是我们展开<code>Thread-1</code>，看到<code>- waiting to lock &lt;0x71ae2ec0&gt; (a java.lang.Class for java.sql.DriverManager)</code>，该线程正在等待java.sql.DriverManager类型锁，而blocked在那里，而这个类型锁是被<code>Thread-0</code>线程持有的，从<code>Thread-1</code>这个线程堆栈来看它其实也是在做Class.forName动作，并且通过<code>Thread-1</code>,展开第四帧我们可以看到其正在对加载sun.jdbc.odbc.JdbcOdbcDriver</p>

<p><code>问题现场遐想:</code></p>

<p>&#8195;&#8195;于是我们大胆设想一个场景，<code>Thread-1</code>先获取到初始化sun.jdbc.odbc.JdbcOdbcDriver的机会，然后在执行sun.jdbc.odbc.JdbcOdbcDriver这个类的静态块的时候调用DriverManager.registerDriver(new Driver());，而该方法之前已经提到了是会加同步锁的，再想象一下，在这个这个静态块之前，并且设置了sun.jdbc.odbc.JdbcOdbcDriver类的初始化状态为being_initialized之后，<code>Thread-0</code>这个线程执行到了卡在的那个位置，并且我们从其堆栈可以看出它已经持有了java.sql.DriverManager这个类型的锁，因此这两个线程陷入了互锁状态</p>

<h3>解决方案</h3>

<p>&#8195;&#8195;解决方案目前想到的是将驱动类的加载过程变成单线程加载，不存在并发情况就没问题了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过HSDB来了解String值的真身在哪里]]></title>
    <link href="http://nijiaben.github.io/blog/2014/06/28/hsdb-string/"/>
    <updated>2014-06-28T11:33:07+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/06/28/hsdb-string</id>
    <content type="html"><![CDATA[<p>&#8195;&#8195;最近通过<code>@RednaxelaFX</code>的一篇文章得知了HSDB，并好好研究了一下用法，对学习jvm的人来说绝对是一个利器，可以摆脱GDB，直接图形化看内存结构布局，具体的用法我就不多说了，这篇<a href="http://rednaxelafx.iteye.com/blog/1847971">文章</a>介绍得很详细了，这次写文章主要是想通过这一利器来分析下String的值在java里的内存情况，不同场景下的String的值到底是在内存里的哪块区域，这里强调的是值，并不是对象，因为对象我们都知道是存在heap里的，我们看java.lang.String的源码会看到有一个value数组，这里才是真正的值，本文顺带也是hsdb用法的一个介绍，如此利器希望给大家带来不一样的乐趣。</p>

<!--more-->


<p>&#8195;&#8195;还是先看demo</p>

<pre class="prettyPrint">
public class StringTest {
    private String val1="a";
    private static String val2=StringTest.class.getName()+"b";

    public static void main(String args[]){
        StringTest st=new StringTest();
        String a="a";
        String d="a";
        String b=a+"b";
        String c="a"+"b";
        String e="ab";
        System.out.println(a+b+c+d+e);
    }
}
</pre>


<p>&#8195;&#8195;本文想从上面的例子得出哪些结论呢？</p>

<pre><code>1. 实例变量val1和局部变量a,d是否指向同一个内存地址
2. 局部变量b,c,e是否指向同一个内存地址
3. 局部变量b的值是在哪里分配的,stack?heap?perm?
4. 字符常量”a”,”ab”分配在哪里？
5. 静态变量val2的值又是分配在哪里？
</code></pre>

<p>&#8195;&#8195;先看看我们通过eclipse调试能确定的结果，断点打在最后一行</p>

<p><img src="http://nijiaben.github.io/images/2014/06/eclipse_value.jpg"></p>

<p>&#8195;&#8195;得到初步结论：</p>

<pre><code>1. 实例变量val1和局部变量a,d里的value值都是指向同一个id为25的值
2. 局部变量c和e指向了同一个id为28的值
3. 局部变量b和c，e不是指向同一个地方，有一个面值相同的值在另外一个内存区域
</code></pre>

<p>&#8195;&#8195;接下来我们通过hsdb来验证下上面的结论，以及解答剩下的疑惑</p>

<p>&#8195;&#8195;操作步骤如下：</p>

<pre><code>1. 设置断点在`System.out.println(a+b+c+d+e);`这一行，vm参数设置`-XX:+UseSerialGC -Xmx10m`
2. 通过jps命令获取对应的pid
3. 然后通过如下命令打开hsdb：`java -cp $JAVA_HOME/lib/sa-jdi.jar sun.jvm.hotspot.HSDB,(如果是windows请替换$JAVA_HOME为%JAVA_HOME%)`
4. 点击File-&gt;Attach to...输入pid
    此时你会看到如下界面：
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_1.jpg"></p>

<pre><code>这是一个线程列表，我们选择main这个线程，也就是我们的主线程

5. 点击面板里第二个图标
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_2.jpg"></p>

<pre><code>得到如下图
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_3.jpg"></p>

<pre><code>这个图其实是我们main方法的栈帧，因为我们目前只有一层调用，还在main方法里，看到我们圈起来的那部分内容，看到好多String对象既有在PermGen里的，也有在NewGen里的，那么每一个具体是什么值呢，是对应我们代码里的那些局部变量吗，如果是的话，哪个对应哪个呢

6. 点击大窗口里的windows-&gt;Console
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_4.jpg"></p>

<pre><code>得到命令行控制台窗口，在窗口内敲回车，会看到如下界面
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_5.jpg"></p>

<pre><code>7. 在命令行窗口里输入universe，先得到每个分区的内存范围，由于格式的问题，我就直接copy出来了
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_6.jpg"></p>

<pre><code>8. 从上面的main方法栈帧里我们分别取查看那些String对象在内存里的位置（第二列地址就是对象的地址，第一列是栈帧里每部分的内存地址），先按照如下菜单调出查看内存结构的窗口
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_7.jpg"></p>

<pre><code>弹出窗口之后类似下面的操作，在2处输入1的地址，1处圈起来的是紫色标注的String对象的内存地址，细心的读者可能发现了，1处的地址在上面的每个分区内存块的PSPermGen里，这说明这个值为ab的String对象是在perm区的，这个对象的char数组的地址，也就是下面的标注3处的
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_8.jpg"></p>

<pre><code>其实我们看到的那几个String对象的顺序是对应我们声明的局部变量的逆序，也就是e，c，b，d，a，最后那个StringTest就是局部变量st，后面的ObjArray其实是我们main方法传进的字符数组，这个其实我们通过javap -verbose StringTest可以查到
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_9.jpg"></p>

<pre><code>哪个solt对应哪个局部变量都有写的，要想看到这个必须在编译的时候要加上-g参数才行

下面再查找下StringTest这个对象的内存值
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_10.jpg"></p>

<pre><code>通过分别对比每个String对象和StringTest对象的内存地址和每个区的内存地址范围，我们能得出的结论是

* 局部变量a,d,c,e是在perm区的
* 局部变量b和st是在eden区的，但是st的val1的值又是在perm区的
* 同时能验证上面一开始得出的三个结论
* 我们也没看到有对象在栈上分配，只看到栈上持有对象的引用，因此当栈回收的时候只是将引用给回收了，具体的对象值还是在内存里

9. 接下来是要找到静态变量val2，在命令行中输入`mem 0x00000000f5043360 2`，因为val2作为静态变量是和class关联的，因此要找到对象的class，如果了解java对象的内存结构的话我们知道每个oop都有一个head，这个head由两部分组成，一个是mark,另一个是_klass，因此通过mem对oop的内存地址取连续的两个字宽，第二个字宽就是我们要的klass
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_11.jpg"></p>

<pre><code>这里估计是一个bug，不能全取，我们只能取后面的8位才行，也就是0xf5ccef60，然后按照第8步的方式输入上面的内存地址，在最后我们看到val2
</code></pre>

<p><img src="http://nijiaben.github.io/images/2014/06/hsdb_12.jpg"></p>

<pre><code>对比内存分代我们得到这个地址是在eden区的，也就是在heap里分配的,另外如果你加一个赋值常量的静态变量，你会发现居然是在perm区的，这个就大家自己去验证吧
</code></pre>

<p>注：以上结论都是在centos系统jdk6上进行验证的，jdk7可能有所不一样.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM Attach机制实现]]></title>
    <link href="http://nijiaben.github.io/blog/2014/06/18/jvm-attach/"/>
    <updated>2014-06-18T19:15:52+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/06/18/jvm-attach</id>
    <content type="html"><![CDATA[<h2>Attach是什么</h2>

<p>   &#8195;&#8195;在讲这个之前，我们先来点大家都知道的东西，当我们感觉线程一直卡在某个地方，想知道卡在哪里，首先想到的是进行线程dump，而常用的命令是jstack <pid>，我们就可以看到如下线程栈了</p>

<!--more-->




<pre class="prettyPrint">
2014-06-18 12:56:14
Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.51-b03 mixed mode):

"Attach Listener" daemon prio=5 tid=0x00007fb0c6800800 nid=0x440b waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Service Thread" daemon prio=5 tid=0x00007fb0c584d800 nid=0x5303 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread1" daemon prio=5 tid=0x00007fb0c482e000 nid=0x5103 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread0" daemon prio=5 tid=0x00007fb0c482c800 nid=0x4f03 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Signal Dispatcher" daemon prio=5 tid=0x00007fb0c4815800 nid=0x4d03 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Finalizer" daemon prio=5 tid=0x00007fb0c4813800 nid=0x3903 in Object.wait() [0x00000001187d2000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    - waiting on <0x00000007aaa85568> (a java.lang.ref.ReferenceQueue$Lock)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)
    - locked <0x00000007aaa85568> (a java.lang.ref.ReferenceQueue$Lock)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)
    at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:189)

"Reference Handler" daemon prio=5 tid=0x00007fb0c4800000 nid=0x3703 in Object.wait() [0x00000001186cf000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    - waiting on <0x00000007aaa850f0> (a java.lang.ref.Reference$Lock)
    at java.lang.Object.wait(Object.java:503)
    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)
    - locked <0x00000007aaa850f0> (a java.lang.ref.Reference$Lock)

"main" prio=5 tid=0x00007fb0c5800800 nid=0x1903 waiting on condition [0x0000000107962000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
    at java.lang.Thread.sleep(Native Method)
    at Test.main(Test.java:5)

"VM Thread" prio=5 tid=0x00007fb0c583d800 nid=0x3503 runnable

"GC task thread#0 (ParallelGC)" prio=5 tid=0x00007fb0c401e000 nid=0x2503 runnable

"GC task thread#1 (ParallelGC)" prio=5 tid=0x00007fb0c401e800 nid=0x2703 runnable

"GC task thread#2 (ParallelGC)" prio=5 tid=0x00007fb0c401f800 nid=0x2903 runnable

"GC task thread#3 (ParallelGC)" prio=5 tid=0x00007fb0c4020000 nid=0x2b03 runnable

"GC task thread#4 (ParallelGC)" prio=5 tid=0x00007fb0c4020800 nid=0x2d03 runnable

"GC task thread#5 (ParallelGC)" prio=5 tid=0x00007fb0c4021000 nid=0x2f03 runnable

"GC task thread#6 (ParallelGC)" prio=5 tid=0x00007fb0c4022000 nid=0x3103 runnable

"GC task thread#7 (ParallelGC)" prio=5 tid=0x00007fb0c4022800 nid=0x3303 runnable

"VM Periodic Task Thread" prio=5 tid=0x00007fb0c5845000 nid=0x5503 waiting on condition

</pre>


<p>   &#8195;&#8195;大家是否注意过上面圈起来的两个线程，”Attach Listener”和“Signal Dispatcher”，这两个线程是我们这次要讲的Attach机制的关键，先偷偷告诉各位，其实Attach Listener这个线程在jvm起来的时候可能并没有的，后面会细说。</p>

<p>   &#8195;&#8195;那Attach机制是什么？说简单点就是jvm提供一种jvm进程间通信的能力，能让一个进程传命令给另外一个进程，并让它执行内部的一些操作，比如说我们为了让另外一个jvm进程把线程dump出来，那么我们跑了一个jstack的进程，然后传了个pid的参数，告诉它要哪个进程进行线程dump，既然是两个进程，那肯定涉及到进程间通信，以及传输协议的定义，比如要执行什么操作，传了什么参数等</p>

<h2>Attach能做些什么</h2>

<p>   &#8195;&#8195;总结起来说，比如内存dump，线程dump，类信息统计(比如加载的类及大小以及实例个数等)，动态加载agent(使用过btrace的应该不陌生)，动态设置vm flag(但是并不是所有的flag都可以设置的，因为有些flag是在jvm启动过程中使用的，是一次性的)，打印vm flag，获取系统属性等，这些对应的源码(AttachListener.cpp)如下</p>

<pre class="prettyPrint">
static AttachOperationFunctionInfo funcs[] = {
  { "agentProperties",  get_agent_properties },
  { "datadump",         data_dump },
  { "dumpheap",         dump_heap },
  { "load",             JvmtiExport::load_agent_library },
  { "properties",       get_system_properties },
  { "threaddump",       thread_dump },
  { "inspectheap",      heap_inspection },
  { "setflag",          set_flag },
  { "printflag",        print_flag },
  { "jcmd",             jcmd },
  { NULL,               NULL }
};
</pre>


<p>&#8195;&#8195;后面是命令对应的处理函数。</p>

<h2>Attach在jvm里如何实现的</h2>

<h3>Attach Listener线程的创建</h3>

<p> &#8195;&#8195;前面也提到了，jvm在启动过程中可能并没有启动Attach Listener这个线程，可以通过jvm参数来启动，代码  （Threads::create_vm）如下：</p>

<pre class="prettyPrint"> 
  if (!DisableAttachMechanism) {
    if (StartAttachListener || AttachListener::init_at_startup()) {
      AttachListener::init();
    }
  }
bool AttachListener::init_at_startup() {
  if (ReduceSignalUsage) {
    return true;
  } else {
    return false;
  }
}
</pre>


<p>&#8195;&#8195;其中DisableAttachMechanism，StartAttachListener ，ReduceSignalUsage均默认是false(globals.hpp)</p>

<pre class="prettyPrint">
product(bool, DisableAttachMechanism, false,                              \
         "Disable mechanism that allows tools to Attach to this VM”)   
product(bool, StartAttachListener, false,                                 \
          "Always start Attach Listener at VM startup")  
product(bool, ReduceSignalUsage, false,                                   \
          "Reduce the use of OS signals in Java and/or the VM”)  
</pre>


<p>&#8195;&#8195;因此AttachListener::init()并不会被执行，而Attach Listener线程正是在此方法里创建的</p>

<pre class="prettyPrint">
// Starts the Attach Listener thread
void AttachListener::init() {
  EXCEPTION_MARK;
  klassOop k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), true, CHECK);
  instanceKlassHandle klass (THREAD, k);
  instanceHandle thread_oop = klass->allocate_instance_handle(CHECK);

  const char thread_name[] = "Attach Listener";
  Handle string = java_lang_String::create_from_str(thread_name, CHECK);

  // Initialize thread_oop to put it into the system threadGroup
  Handle thread_group (THREAD, Universe::system_thread_group());
  JavaValue result(T_VOID);
  JavaCalls::call_special(&result, thread_oop,
                       klass,
                       vmSymbols::object_initializer_name(),
                       vmSymbols::threadgroup_string_void_signature(),
                       thread_group,
                       string,
                       CHECK);

  KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
  JavaCalls::call_special(&result,
                        thread_group,
                        group,
                        vmSymbols::add_method_name(),
                        vmSymbols::thread_void_signature(),
                        thread_oop,             // ARG 1
                        CHECK);

  { MutexLocker mu(Threads_lock);
    JavaThread* listener_thread = new JavaThread(&Attach_listener_thread_entry);

    // Check that thread and osthread were created
    if (listener_thread == NULL || listener_thread->osthread() == NULL) {
      vm_exit_during_initialization("java.lang.OutOfMemoryError",
                                    "unable to create new native thread");
    }

    java_lang_Thread::set_thread(thread_oop(), listener_thread);
    java_lang_Thread::set_daemon(thread_oop());

    listener_thread->set_threadObj(thread_oop());
    Threads::add(listener_thread);
    Thread::start(listener_thread);
  }
}
</pre>


<p>&#8195;&#8195;既然在启动的时候不会创建这个线程，那么我们在上面看到的那个线程是怎么创建的呢，这个就要关注另外一个线程“Signal Dispatcher”了，顾名思义是处理信号的，这个线程是在jvm启动的时候就会创建的，具体代码就不说了。</p>

<p>&#8195;&#8195;下面以jstack的实现来说明触发Attach这一机制进行的过程，jstack命令的实现其实是一个叫做JStack.java的类，查看jstack代码后会走到下面的方法里</p>

<pre class="prettyPrint">
private static void runThreadDump(String pid, String args[]) throws Exception {
        VirtualMachine vm = null;
        try {
            vm = VirtualMachine.Attach(pid);
        } catch (Exception x) {
            String msg = x.getMessage();
            if (msg != null) {
                System.err.println(pid + ": " + msg);
            } else {
                x.printStackTrace();
            }
            if ((x instanceof AttachNotSupportedException) &&
                (loadSAClass() != null)) {
                System.err.println("The -F option can be used when the target " +
                    "process is not responding");
            }
            System.exit(1);
        }

        // Cast to HotSpotVirtualMachine as this is implementation specific
        // method.
        InputStream in = ((HotSpotVirtualMachine)vm).remoteDataDump((Object[])args);

        // read to EOF and just print output
        byte b[] = new byte[256];
        int n;
        do {
            n = in.read(b);
            if (n > 0) {
                String s = new String(b, 0, n, "UTF-8");
                System.out.print(s);
            }
        } while (n > 0);
        in.close();
        vm.detach();
    }
</pre>


<p>&#8195;&#8195;请注意VirtualMachine.Attach(pid);这行代码，触发Attach pid的关键，如果是在linux下会走到下面的构造函数</p>

<pre class="prettyPrint">
LinuxVirtualMachine(AttachProvider provider, String vmid)
        throws AttachNotSupportedException, IOException
    {
        super(provider, vmid);

        // This provider only understands pids
        int pid;
        try {
            pid = Integer.parseInt(vmid);
        } catch (NumberFormatException x) {
            throw new AttachNotSupportedException("Invalid process identifier");
        }

        // Find the socket file. If not found then we attempt to start the
        // Attach mechanism in the target VM by sending it a QUIT signal.
        // Then we attempt to find the socket file again.
        path = findSocketFile(pid);
        if (path == null) {
            File f = createAttachFile(pid);
            try {
                // On LinuxThreads each thread is a process and we don't have the
                // pid of the VMThread which has SIGQUIT unblocked. To workaround
                // this we get the pid of the "manager thread" that is created
                // by the first call to pthread_create. This is parent of all
                // threads (except the initial thread).
                if (isLinuxThreads) {
                    int mpid;
                    try {
                        mpid = getLinuxThreadsManager(pid);
                    } catch (IOException x) {
                        throw new AttachNotSupportedException(x.getMessage());
                    }
                    assert(mpid >= 1);
                    sendQuitToChildrenOf(mpid);
                } else {
                    sendQuitTo(pid);
                }

                // give the target VM time to start the Attach mechanism
                int i = 0;
                long delay = 200;
                int retries = (int)(AttachTimeout() / delay);
                do {
                    try {
                        Thread.sleep(delay);
                    } catch (InterruptedException x) { }
                    path = findSocketFile(pid);
                    i++;
                } while (i <= retries && path == null);
                if (path == null) {
                    throw new AttachNotSupportedException(
                        "Unable to open socket file: target process not responding " +
                        "or HotSpot VM not loaded");
                }
            } finally {
                f.delete();
            }
        }

        // Check that the file owner/permission to avoid Attaching to
        // bogus process
        checkPermissions(path);

        // Check that we can connect to the process
        // - this ensures we throw the permission denied error now rather than
        // later when we attempt to enqueue a command.
        int s = socket();
        try {
            connect(s, path);
        } finally {
            close(s);
        }
    }
</pre>


<p>&#8195;&#8195;这里要解释下代码了，首先看到调用了createAttachFile方法在目标进程的cwd目录下创建了一个文件/proc/<pid>/cwd/.Attach_pid<pid>，这个在后面的信号处理过程中会取出来做判断(为了安全)，另外我们知道在linux下线程是用进程实现的，在jvm启动过程中会创建很多线程，比如我们上面的信号线程，也就是会看到很多的pid(应该是LWP)，那么如何找到这个信号处理线程呢，从上面实现来看是找到我们传进去的pid的父进程，然后给它的所有子进程都发送一个SIGQUIT信号，而jvm里除了信号线程，其他线程都设置了对此信号的屏蔽，因此收不到该信号，于是该信号就传给了“Signal Dispatcher”，在传完之后作轮询等待看目标进程是否创建了某个文件，AttachTimeout默认超时时间是5000ms，可通过设置系统变量sun.tools.Attach.AttachTimeout来指定，下面是Signal Dispatcher线程的entry实现</p>

<pre class="prettyPrint">
static void signal_thread_entry(JavaThread* thread, TRAPS) {
  os::set_priority(thread, NearMaxPriority);
  while (true) {
    int sig;
    {
      // FIXME : Currently we have not decieded what should be the status
      //         for this java thread blocked here. Once we decide about
      //         that we should fix this.
      sig = os::signal_wait();
    }
    if (sig == os::sigexitnum_pd()) {
       // Terminate the signal thread
       return;
    }

    switch (sig) {
      case SIGBREAK: {
        // Check if the signal is a trigger to start the Attach Listener - in that
        // case don't print stack traces.
        if (!DisableAttachMechanism && AttachListener::is_init_trigger()) {
          continue;
        }
        // Print stack traces
        // Any SIGBREAK operations added here should make sure to flush
        // the output stream (e.g. tty->flush()) after output.  See 4803766.
        // Each module also prints an extra carriage return after its output.
        VM_PrintThreads op;
        VMThread::execute(&op);
        VM_PrintJNI jni_op;
        VMThread::execute(&jni_op);
        VM_FindDeadlocks op1(tty);
        VMThread::execute(&op1);
        Universe::print_heap_at_SIGBREAK();
        if (PrintClassHistogram) {
          VM_GC_HeapInspection op1(gclog_or_tty, true /* force full GC before heap inspection */,
                                   true /* need_prologue */);
          VMThread::execute(&op1);
        }
        if (JvmtiExport::should_post_data_dump()) {
          JvmtiExport::post_data_dump();
        }
        break;
      }
      ….
      }
    }
  }
}
</pre>


<p>&#8195;&#8195;当信号是SIGBREAK(在jvm里做了#define，其实就是SIGQUIT)的时候，就会触发
AttachListener::is_init_trigger()的执行，</p>

<pre class="prettyPrint">
bool AttachListener::is_init_trigger() {
  if (init_at_startup() || is_initialized()) {
    return false;               // initialized at startup or already initialized
  }
  char fn[PATH_MAX+1];
  sprintf(fn, ".Attach_pid%d", os::current_process_id());
  int ret;
  struct stat64 st;
  RESTARTABLE(::stat64(fn, &st), ret);
  if (ret == -1) {
    snprintf(fn, sizeof(fn), "%s/.Attach_pid%d",
             os::get_temp_directory(), os::current_process_id());
    RESTARTABLE(::stat64(fn, &st), ret);
  }
  if (ret == 0) {
    // simple check to avoid starting the Attach mechanism when
    // a bogus user creates the file
    if (st.st_uid == geteuid()) {
      init();
      return true;
    }
  }
  return false;
}
</pre>


<p>&#8195;&#8195;一开始会判断当前进程目录下是否有个.Attach_pid<pid>文件（前面提到了），如果没有就会在/tmp下创建一个/tmp/.Attach_pid<pid>，当那个文件的uid和自己的uid是一致的情况下（为了安全）再调用init方法</p>

<pre class="prettyPrint">
// Starts the Attach Listener thread
void AttachListener::init() {
  EXCEPTION_MARK;
  klassOop k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), true, CHECK);
  instanceKlassHandle klass (THREAD, k);
  instanceHandle thread_oop = klass->allocate_instance_handle(CHECK);

  const char thread_name[] = "Attach Listener";
  Handle string = java_lang_String::create_from_str(thread_name, CHECK);

  // Initialize thread_oop to put it into the system threadGroup
  Handle thread_group (THREAD, Universe::system_thread_group());
  JavaValue result(T_VOID);
  JavaCalls::call_special(&result, thread_oop,
                       klass,
                       vmSymbols::object_initializer_name(),
                       vmSymbols::threadgroup_string_void_signature(),
                       thread_group,
                       string,
                       CHECK);

  KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
  JavaCalls::call_special(&result,
                        thread_group,
                        group,
                        vmSymbols::add_method_name(),
                        vmSymbols::thread_void_signature(),
                        thread_oop,             // ARG 1
                        CHECK);

  { MutexLocker mu(Threads_lock);
    JavaThread* listener_thread = new JavaThread(&Attach_listener_thread_entry);

    // Check that thread and osthread were created
    if (listener_thread == NULL || listener_thread->osthread() == NULL) {
      vm_exit_during_initialization("java.lang.OutOfMemoryError",
                                    "unable to create new native thread");
    }

    java_lang_Thread::set_thread(thread_oop(), listener_thread);
    java_lang_Thread::set_daemon(thread_oop());

    listener_thread->set_threadObj(thread_oop());
    Threads::add(listener_thread);
    Thread::start(listener_thread);
  }
}
</pre>


<p>&#8195;&#8195;此时水落石出了，看到创建了一个线程，并且取名为Attach Listener。再看看其子类LinuxAttachListener的init方法</p>

<pre class="prettyPrint">
int LinuxAttachListener::init() {
  char path[UNIX_PATH_MAX];          // socket file
  char initial_path[UNIX_PATH_MAX];  // socket file during setup
  int listener;                      // listener socket (file descriptor)

  // register function to cleanup
  ::atexit(listener_cleanup);

  int n = snprintf(path, UNIX_PATH_MAX, "%s/.java_pid%d",
                   os::get_temp_directory(), os::current_process_id());
  if (n < (int)UNIX_PATH_MAX) {
    n = snprintf(initial_path, UNIX_PATH_MAX, "%s.tmp", path);
  }
  if (n >= (int)UNIX_PATH_MAX) {
    return -1;
  }

  // create the listener socket
  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
  if (listener == -1) {
    return -1;
  }

  // bind socket
  struct sockaddr_un addr;
  addr.sun_family = AF_UNIX;
  strcpy(addr.sun_path, initial_path);
  ::unlink(initial_path);
  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
  if (res == -1) {
    RESTARTABLE(::close(listener), res);
    return -1;
  }

  // put in listen mode, set permissions, and rename into place
  res = ::listen(listener, 5);
  if (res == 0) {
      RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);
      if (res == 0) {
          res = ::rename(initial_path, path);
      }
  }
  if (res == -1) {
    RESTARTABLE(::close(listener), res);
    ::unlink(initial_path);
    return -1;
  }
  set_path(path);
  set_listener(listener);

  return 0;
}
</pre>


<p>&#8195;&#8195;看到其创建了一个监听套接字，并创建了一个文件/tmp/.java_pid<pid>，这个文件就是客户端之前一直在轮询等待的文件，随着这个文件的生成，意味着Attach的过程圆满结束了。</p>

<h3>Attach listener接收请求</h3>

<p>&#8195;&#8195;看看它的entry实现Attach_listener_thread_entry</p>

<pre class="prettyPrint">
static void Attach_listener_thread_entry(JavaThread* thread, TRAPS) {
  os::set_priority(thread, NearMaxPriority);

  thread->record_stack_base_and_size();

  if (AttachListener::pd_init() != 0) {
    return;
  }
  AttachListener::set_initialized();

  for (;;) {
    AttachOperation* op = AttachListener::dequeue();
    if (op == NULL) {
      return;   // dequeue failed or shutdown
    }

    ResourceMark rm;
    bufferedStream st;
    jint res = JNI_OK;

    // handle special detachall operation
    if (strcmp(op->name(), AttachOperation::detachall_operation_name()) == 0) {
      AttachListener::detachall();
    } else {
      // find the function to dispatch too
      AttachOperationFunctionInfo* info = NULL;
      for (int i=0; funcs[i].name != NULL; i++) {
        const char* name = funcs[i].name;
        assert(strlen(name) <= AttachOperation::name_length_max, "operation <= name_length_max");
        if (strcmp(op->name(), name) == 0) {
          info = &(funcs[i]);
          break;
        }
      }

      // check for platform dependent Attach operation
      if (info == NULL) {
        info = AttachListener::pd_find_operation(op->name());
      }

      if (info != NULL) {
        // dispatch to the function that implements this operation
        res = (info->func)(op, &st);
      } else {
        st.print("Operation %s not recognized!", op->name());
        res = JNI_ERR;
      }
    }

    // operation complete - send result and output to client
    op->complete(res, &st);
  }
}
</pre>


<p>&#8195;&#8195;从代码来看就是从队列里不断取AttachOperation，然后找到请求命令对应的方法进行执行，比如我们一开始说的jstack命令，找到 { &#8220;threaddump&#8221;,       thread_dump }的映射关系，然后执行thread_dump方法</p>

<p>&#8195;&#8195;再来看看其要调用的AttachListener::dequeue()，</p>

<pre class="prettyPrint">
AttachOperation* AttachListener::dequeue() {
  JavaThread* thread = JavaThread::current();
  ThreadBlockInVM tbivm(thread);

  thread->set_suspend_equivalent();
  // cleared by handle_special_suspend_equivalent_condition() or
  // java_suspend_self() via check_and_wait_while_suspended()

  AttachOperation* op = LinuxAttachListener::dequeue();

  // were we externally suspended while we were waiting?
  thread->check_and_wait_while_suspended();

  return op;
}
</pre>


<p>&#8195;&#8195;最终调用的是LinuxAttachListener::dequeue()，</p>

<pre class="prettyPrint">
LinuxAttachOperation* LinuxAttachListener::dequeue() {
  for (;;) {
    int s;

    // wait for client to connect
    struct sockaddr addr;
    socklen_t len = sizeof(addr);
    RESTARTABLE(::accept(listener(), &addr, &len), s);
    if (s == -1) {
      return NULL;      // log a warning?
    }

    // get the credentials of the peer and check the effective uid/guid
    // - check with jeff on this.
    struct ucred cred_info;
    socklen_t optlen = sizeof(cred_info);
    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
      int res;
      RESTARTABLE(::close(s), res);
      continue;
    }
    uid_t euid = geteuid();
    gid_t egid = getegid();

    if (cred_info.uid != euid || cred_info.gid != egid) {
      int res;
      RESTARTABLE(::close(s), res);
      continue;
    }

    // peer credential look okay so we read the request
    LinuxAttachOperation* op = read_request(s);
    if (op == NULL) {
      int res;
      RESTARTABLE(::close(s), res);
      continue;
    } else {
      return op;
    }
  }
}
</pre>


<p>&#8195;&#8195;我们看到如果没有请求的话，会一直accept在那里，当来了请求，然后就会创建一个套接字，并读取数据，构建出LinuxAttachOperation返回并执行。</p>

<p>&#8195;&#8195;整个过程就这样了，从Attach线程创建到接收请求，处理请求。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从tcp原理角度理解Broken pipe和Connection reset by peer的区别]]></title>
    <link href="http://nijiaben.github.io/blog/2014/05/20/tcp-broken-pipe/"/>
    <updated>2014-05-20T19:31:28+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/05/20/tcp-broken-pipe</id>
    <content type="html"><![CDATA[<p>&#8195;&#8195;以前我们经常会碰到<code>Broken pipe</code>或者<code>Connection reset by peer</code>之类的异常，但是tcp实现里什么情况下会抛出这些异常呢，以前我给对方的回答都是模棱两可的，自己说实话都没把握，因为自己也没有验证过，对它们的认识都是从网上看来的，正确与否也不知道，昨天独明突然又问到这个问题，前段时间正好对tcp这块研究了一段时间，有了点理论知识之后再从实践角度对此问题进行一下分析，下面对我这次的调研过程进行下描述与大家分享，希望大家以后对此类问题都能很自信地应答。</p>

<h2>三次握手和四次挥手过程</h2>

<p>&#8195;&#8195;在讲具体的原因之前，我们有必要补充下tcp这块的一些基础知识，我们都知道tcp通信有三次握手和四次挥手，网上介绍的文章也一大堆，图我也懒得画了，直接网上找一个图给大家</p>

<!--more-->


<p><img src="http://nijiaben.github.io/images/2014/07/tcp_hank.jpg"></p>

<p>&#8195;&#8195;三次握手是最前面的三条线表示的过程，四次挥手是最后面的四条线表示的过程，里面涉及到几个关键词，SYN，ACK，FIN，MSS，其中SYN是主要用在三次握手过程中的，FIN用在四次挥手过程中，ACK在三次握手和四次挥手过程中的作用就是对收到的SYN和FIN做一个确认，SYN，FIN等存在于TCP头里(tcp报文图也给大家弄了个图，不用再去找啦)，0/1表示有无此标记，在tcp实现里后面还会跟一个依次递增的数字，比如上面的J，K等，确认就是递增这些数字(真正的数据报文的ack除外)，MSS是表示每一个tcp报文里数据字段的最大长度，不包括tcp头的大小噢
相信大家看到这两个图会对这些概念有了一个清晰的认识了</p>

<p><img src="http://nijiaben.github.io/images/2014/07/tcp_header.jpg"></p>

<h2>tcpdump抓包工具</h2>

<p>&#8195;&#8195;介绍了基础原理之后，再介绍下抓包工具，tcpdump，这工具对你了解tcp的整个过程会非常有帮助，在你无法调试tcp实现的情况下这个工具自然也是必不可少的，具体用法网上有很多介绍，直接从man page上也可以看到详细的介绍，我也不多说啦，下面的截图就是tcpdump根据tcp通信过程获取到的</p>

<p><img src="http://nijiaben.github.io/images/2014/07/tcpdump_1.jpg"></p>

<p>&#8195;&#8195;这要稍微提下tcpdump的结果和上面的几个过程的对应关系
前面三条其实就是我们上面所说的三次握手，四次握手过程上面没有完全表现出来，只完成了一半的挥手过程（5，8两条表示的）
里面有几个标识S，F，ack，P，其实还有个R，如果有这些标识那么在tcp头里的SYN，FIN，ACK，PSH，RET分别为1，其中PSH表示要求tcp立即将数据传递给上层，不要做别的什么处理，RET这个表示重置连接，也是和我们今天讨论的问题有很大关系的FLAG，下面会详细介绍</p>

<h2>reset报文发送场景</h2>

<p>&#8195;&#8195;RST的标志位，这个标识为在如下几种情况下会被设置，以下是我了解的情况，可能还有更多的场景，没有验证</p>

<ul>
<li>当尝试和未开放的服务器端口建立tcp连接时，服务器tcp将会直接向客户端发送reset报文</li>
<li>双方之前已经正常建立了通信通道，也可能进行过了交互，当某一方在交互的过程中发生了异常，如崩溃等，异常的一方会向对端发送reset报文，通知对方将连接关闭</li>
<li>当收到TCP报文，但是发现该报文不是已建立的TCP连接列表可处理的，则其直接向对端发送reset报文</li>
<li>ack报文丢失，并且超出一定的重传次数或时间后，会主动向对端发送reset报文释放该TCP连接</li>
</ul>


<h2>Broken pipe以及Connection reset by peer</h2>

<p>&#8195;&#8195;做了这么些铺垫之后下面进入正题，那么<code>Broken pipe</code>或者<code>Connection reset by peer</code>分别代表什么意思呢，下面从glibc的源码里有对此的介绍</p>

<pre class="prettyPrint">
#. TRANS Broken pipe; there is no process reading from the other end of a pipe.
#. TRANS Every library function that returns this error code also generates a
#. TRANS @code{SIGPIPE} signal; this signal terminates the program if not handled
#. TRANS or blocked.  Thus, your program will never actually see @code{EPIPE}
#. TRANS unless it has handled or blocked @code{SIGPIPE}.
#: sysdeps/generic/siglist.h:39 sysdeps/gnu/errlist.c:359
#: sysdeps/unix/siglist.c:39
msgid "Broken pipe"
msgstr "断开的管道"

#. TRANS A network connection was closed for reasons outside the control of the
#. TRANS local host, such as by the remote machine rebooting or an unrecoverable
#. TRANS protocol violation.
#: sysdeps/gnu/errlist.c:614
msgid "Connection reset by peer"
msgstr ""

</pre>


<p>&#8195;&#8195;其实我们java异常里看到的<code>Broken pipe</code>或者<code>Connection reset by peer</code>信息不是jdk或者jvm里定义的，我看到这些关键字往往会首先搜索下jdk或者hotspot源码找到位置进行上下文分析，但是这次没找到，后面才想到应该是linux或者glibc里定义的，果然在glibc离看到了如上的描述和定义</p>

<p>&#8195;&#8195;对于<code>Broken pipe</code>在管道的另外一端没有进程再读的时候就会抛出此异常，<code>Connection reset by peer</code>的描述其实不是很正确，从我的实践来看只描述了一方面，其实在某一端正常close之后，也是可能会有此异常的。</p>

<h2>异常模拟</h2>

<p>&#8195;&#8195;从我的测试场景是这样的，
共同的前提是客户端向服务端发了数据之后立马调用close关闭socket并进程退出，而服务端在收到客户端的数据之后sleep一会，保证对方的socket已经关闭，接着分别进行两种场景测试</p>

<p>&#8195;&#8195;<code>场景：</code></p>

<ol>
<li><p>服务端往socket里写一次数据，返回继续做select</p></li>
<li><p>服务端连续写两次数据，必须保证两次的buffer都是有数据的，也就是保证ByteBuffer的pos和limit要不是一个值</p></li>
</ol>


<p>&#8195;&#8195;<code>结果：</code></p>

<ol>
<li><p>会抛出Connection reset by peer </br>
<img src="http://nijiaben.github.io/images/2014/07/tcp_error_1.jpg"></p></li>
<li><p>会抛出Broken pipe</br>
<img src="http://nijiaben.github.io/images/2014/07/tcp_error_2.jpg"></p></li>
</ol>


<p>&#8195;&#8195;<code>分析：</code></p>

<ol>
<li><p>当我们往一个对端已经close的通道写数据的时候，对方的tcp会收到这个报文，并且反馈一个reset报文，tcpdump的结果如下所示,当收到reset报文的时候，继续做select读数据的时候就会抛出<code>Connect reset by peer</code>的异常，从堆栈可以看得出
<img src="http://nijiaben.github.io/images/2014/07/tcpdump_2.jpg"></p></li>
<li><p>当第一次往一个对端已经close的通道写数据的时候会和上面的情况一样，会收到reset报文，当再次往这个socket写数据的时候，就会抛出<code>Broken pipe</code>了
，根据tcp的约定，当收到reset包的时候，上层必须要做出处理，调用将socket文件描述符进行关闭，其实也意味着pipe会关闭，因此会抛出这个顾名思义的异常</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pcduino搭建web站点IP映射解决方案]]></title>
    <link href="http://nijiaben.github.io/blog/2014/05/04/pcduino-web-site/"/>
    <updated>2014-05-04T10:43:57+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/05/04/pcduino-web-site</id>
    <content type="html"><![CDATA[<p>&#8195;&#8195;在pcduino上搭建站点，有两个问题首先需要解决</p>

<ul>
<li> 域名绑定</li>
<li> 端口映射</li>
</ul>


<p>&#8195;&#8195;如果你的pcduino连的路由器的IP已经是公网IP，按照如下步骤查看</p>

<ul>
<li> 打开路由器管理页面，比如<code>192.168.1.1</code>，查看运行状态里WAN显示的IP地址</li>
<li> 打开<code>www.ip138.com</code>，上面会显示你的公网IP</li>
<li> 如果以上两者相等，说明你的路由器就是直接连的公网，否则外面可能还有一层或者几层路由器，这个就比较麻烦了，你必须要有操作他们的权限才能继续往下走</li>
</ul>


<!--more-->


<h2>域名绑定解决方案</h2>

<ul>
<li> 自己在域名管理处设置A记录指向你的公网IP，该IP如果是静态的(可以通过重启路由器查看你的公网IP是否有变化来测试)，这个就好说了，如果是动态变化的，那么要么你的A记录跟着变，要么参考下一条方案</li>
<li> 针对动态IP，一般采用花生壳的方案，一般的路由器都带有嵌入式的花生壳，在路由器里登录花生壳就好了，域名的管理需要在花生壳官网配置，同时要到你的域名商那里修改dns，指向花生壳的dns，如<code>ns1.dnsoray.net</code>和<code>ns2.dnsoray.net</code>，这样基本就可以了，同时在花生壳官网你可以看到你的域名自动帮你A记录到你的公网IP，如果显示的IP不是你的公网IP，就麻烦了，下面具体描述下这种情况</li>
</ul>


<p>&#8195;&#8195;某些互联网宽带服务运营商(简称为ISP)为了扩展所属地区的相关信息业务,或基于其他的技术原因,在用户拥有“公网IP”的同时，在ISP出口作出一个特殊的技术手段处理 —— NAT转发，受到被ISP 做NAT转发的用户苦不堪言,明明拥有公网IP地址，在使用大部分动态域名解析软件时却出现被解析到另外一个莫名其妙的公网IP地址。目前免费的花生壳用户是不提供此类解决方案的，除非你成为付费用户，几百块一年吧，我其实就是处于这种情况，我自己目前方案是第一种（我的比这个还复杂点，我的pcduino是处在多重局域网中，下面正要说的），比较蛋疼，没有想到好的解决方案，万一路由器重启了，我必须重新改变A记录指向，屌丝总想省点钱(空间服务费省了，要是域名服务费也能省了就好了)。</p>

<h2>端口转发的设置过程</h2>

<ul>
<li> pcduino所连的路由器直接处于广域网中的情况，在你的路由器管理页面里选择&#8221;转发规则&#8221;->&#8221;虚拟服务器&#8221;里添加新条目(假如你使用的是tplink，其他的路由器也类似)，里面有几个选项，直接看帮助就知道什么意思了，该设置主要实现的功能是针对某个端口来的所有请求都转发给对应的内网机器，比如80来的web请求都转给<code>192.168.1.10</code>，这个IP就是pcduino的IP，下面会介绍pcduino上如果进行静态IP的设置</li>
<li> 对于网中网的情况，那么就必须要有从分配了公网IP的路由器到pcduino的路由器之间涉及的所有路由器都要有操作权限，也就是通过类似上面的方法一层层指定下来，比如公网里80端口来的服务首先转到路由器1的80端口，然后再转给路由器2的80端口&#8230;以此类推，直到你的pcduino的80端口</li>
<li> 如果嫌设置端口映射麻烦，那还有一个方案，那就是通过设置每个路由器的dmz主机，上层路由器的dmz主机指向下层路由器的IP或者pcduino的IP，这样相当于将pcduino整个暴露给公网了，当然你中间的路由器也是类似的情况，安全性有待考验</li>
</ul>


<h2>pcduino设置静态IP的操作</h2>

<p>&#8195;&#8195;我的pcduino弄了一个<a href="http://item.jd.com/509932.html`">无usb无线网卡</a>，即插即用，很方便</p>

<ul>
<li> 首先确保你正确连接了你的无线网络，通过<code>iwlist wlan3 scan</code>查看你的无线网络参数，ESSID指定的值就是你的无线网名字，不要选错了   <br/>
<pre class="prettyPrint">
root@ubuntu:/etc/network# iwlist wlan3 scan       <br/>
    wlan3     Scan completed :
              ESSID:"RJB"   <br/>
              Protocol:IEEE 802.11bgn         <br/>
              Mode:Master
              Frequency:2.452 GHz (Channel 9)
              Encryption key:on
              Bit Rates:150 Mb/s
</pre></li>
<li> 通过上面我们看到几个关键参数，<code>wlan3</code>(网卡名)，<code>ESSID</code>(网络名)，<code>Channel 9</code>(信道)</li>
<li><p> 于是编辑/etc/network/interface，加入如下内容
<pre class="prettyPrint">
auto wlan3<br/>
iface wlan3 inet static<br/>
address 192.168.1.10<br/>
netmask 255.255.255.0<br/>
gateway 192.168.1.1<br/>
wpa-ssid RJB（要连接的wlan ssid）<br/>
wpa-passphrase wlan密码<br/>
wireless-channel 9（信道号）
</pre></p></li>
<li><p> 修改dns服务器地址</p>

<ul>
<li><p>拷贝<code>/etc/resolv.conf</code>里面的内容出来，然后删除该文件</p></li>
<li><p>新建上面的这个文件，将拷贝的内容复制进去，同时增加<code>nameserver 8.8.8.8</code></p></li>
<li><p>执行命令<code>chattr +i /etc/resolv.conf</code>，之所以执行该步骤，是为了不让<code>resolv.conf</code>了的内容被覆盖</p></li>
<li>重启网络<code>/etc/init.d/networking restart</code> ，抑或重启系统<code>shutdown -r now</code></li>
</ul>


<p> 通过以上方式就可以将你的pcduino地址绑定到静态地址了，这样这个地址你就可以放心地在路由器上配置端口转发规则了</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress新纪元]]></title>
    <link href="http://nijiaben.github.io/blog/2014/04/23/new-begin/"/>
    <updated>2014-04-23T23:47:00+08:00</updated>
    <id>http://nijiaben.github.io/blog/2014/04/23/new-begin</id>
    <content type="html"><![CDATA[<p><img src="http://nijiaben.github.io/images/2014/04/github_page_and-octopress.png"></p>

<pre><code>    今天又做了一个尝试，从wordpress换到了octopress，放弃了pcduino，选择了免费的github。
</code></pre>

<ul>
<li>octopress界面的清爽简洁</li>
<li>octopress对markdown语法的天然支持

<ul>
<li>虽然wordpress也有markdown的插件，但是还是喜欢正统</li>
<li>公司周报都用markdown写了，主要是排版非常舒服</li>
</ul>
</li>
<li>octopress有程序员的思维，用官方话说“Octopress is a blogging framework for hackers”</li>
<li>pcduino

<ul>
<li>于己写文章/发布都比较蛋疼，毕竟是一块价值仅300多的开发板，性能有限，有时间真的会影响写文章的心情</li>
<li>于人访问速度犹如龟速，甚至有时候还经常打不开，实在对不住看客们</li>
<li>域名访问不稳定，主要还是自己不想成为域名代理服务商付费用户，只得路由器上做端口映射，路由器重启域名还会重新指定A记录，实在是屌丝至极</li>
</ul>
</li>
<li>转向github，大势所趋，公司内部都慢慢放弃svn，投入github托管，自己目前开发的项目也使用git，之前记得微博上有人招聘，提了几个要求，如果你连github账户都没一个，请不要投简历给我，可见github的未来非常美好啊

<ul>
<li>主要还是免费的，哈哈， 访问速度还可以，虽然偶尔会被墙一下，不过貌似问题不大</li>
<li>还支持域名绑定</li>
</ul>
</li>
</ul>


<p>之前的部分博文请访问<a href="http://alipaymiddleware.com/">支付宝中间件官方博客</a></p>
]]></content>
  </entry>
  
</feed>
