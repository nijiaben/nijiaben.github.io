<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JVM | 你假笨]]></title>
  <link href="http://nijiaben.github.io/blog/categories/jvm/atom.xml" rel="self"/>
  <link href="http://nijiaben.github.io/"/>
  <updated>2016-05-18T23:46:24+08:00</updated>
  <id>http://nijiaben.github.io/</id>
  <author>
    <name><![CDATA[你假笨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[YGC前后新生代变大？]]></title>
    <link href="http://nijiaben.github.io/blog/2016/05/18/ygc-worse/"/>
    <updated>2016-05-18T18:59:44+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/05/18/ygc-worse</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>我们都知道gc是为了释放内存，但是你是否碰到过ygc前后新生代反增不减的情况呢？gc日志效果类似下面的：</p>

<p><code>
2016-05-18T15:06:13.011+0800: [GC [ParNew (promotion failed): 636088K-&gt;690555K(707840K), 0.2958900 secs][CMS: 1019739K-&gt;1019733K(1310720K), 2.6208600 secs] 1655820K-&gt;1655820K(2018560K), [CMS Perm : 205486K-&gt;205486K(262144K)], 2.9174390 secs] [Times: user=3.74 sys=0.01, real=2.91 secs]
</code></p>

<p>从上面的gc日志来看，我们新生代使用的是ParNew，而老生代用的是CMS GC，我们注意到ParNew的效果是新生代从636088K新增到了690555K，这是什么情况？</p>

<!--more-->


<h2>原理分析</h2>

<p>要解释这个问题，我们先要弄清楚YGC的过程，parNew是新生代的gc算法，简单来说从gc roots开始扫描对象，当扫到一个只要是属于新生代的对象就将其挪到to space，但是老的对象还不会做释放，直到gc完成之后再看是否释放老的对象(比如说上面我们看到了<code>promotion failed</code>的关键字，意味着晋升失败了，也就是说to和old都装不下新生代晋升来的对象，那么在这种情况下其实是不会对eden和from里的老对象做释放的，尽管to space里已经可能存在一份副本了)，但是在gc前后不管是否晋升成功，都会对from space和to space做一个对换，也就是原来的from变成to，原来的to变成from，再来看看打印gc前后内存变化的代码</p>

<p>```
void GenCollectedHeap::print_heap_change(size_t prev_used) const {
  if (PrintGCDetails &amp;&amp; Verbose) {</p>

<pre><code>gclog_or_tty-&gt;print(" "  SIZE_FORMAT
                    "-&gt;" SIZE_FORMAT
                    "("  SIZE_FORMAT ")",
                    prev_used, used(), capacity());
</code></pre>

<p>  } else {</p>

<pre><code>gclog_or_tty-&gt;print(" "  SIZE_FORMAT "K"
                    "-&gt;" SIZE_FORMAT "K"
                    "("  SIZE_FORMAT "K)",
                    prev_used / K, used() / K, capacity() / K);
</code></pre>

<p>  }
}</p>

<p>size_t GenCollectedHeap::used() const {
  size_t res = 0;
  for (int i = 0; i &lt; _n_gens; i++) {</p>

<pre><code>res += _gens[i]-&gt;used();
</code></pre>

<p>  }
  return res;
}</p>

<p>size_t DefNewGeneration::used() const {
  return eden()->used()</p>

<pre><code>   + from()-&gt;used();      // to() is only used during scavenge
</code></pre>

<p>}
```</p>

<p>从上面代码我们知道，gc之后的内存情况是used()方法返回的，其中新生代的used方法返回的是eden+from的内存，同样的上面的prev_used也是这么计算的，只是发生在gc之前，这样一来，根据我上面提到的情况，在gc之后不管是否成功都会做一次from和to的swap，那么gc之前新生代的使用大小，其实是gc之前eden+from的使用大小，而gc之后的新生代的使用大小，其实是eden+原来的to现在是使用的大小，原来的to现在使用的大小其实就是在gc过程中将eden和from拷贝过来的对象所占的大小。</p>

<p>综上分析你应该知道为什么会出现这种情况了，其实是一种特殊情况，只有在出现<code>promotion failed</code>的情况下才会发生这样的情况，因为在这个情况下存在to里新增对象，而from和eden不会变化的情况</p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之JDK8下的僵尸(无法回收)类加载器]]></title>
    <link href="http://nijiaben.github.io/blog/2016/04/24/classloader-unload/"/>
    <updated>2016-04-24T11:21:24+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/04/24/classloader-unload</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>这篇文章基于最近在排查的一个问题，花了我们团队不少时间来排查这个问题，现象是有一些类加载器是作为key放到WeakHashMap里的，但是经历过多次full gc之后，依然坚挺地存在内存里，但是从代码上来说这些类加载器是应该被回收的，因为没有任何强引用可以到达这些类加载器了，于是我们做了内存dump，分析了下内存，发现除了一个WeakHashMap外并没有别的GC ROOT途径达到这些类加载器了，那这样一来经过多次FULL GC肯定是可以被回收的，但是事实却不是这样，为了让这个问题听起来更好理解，还是照例先上个Demo，完全模拟了这种场景。</p>

<!--more-->


<h2>Demo</h2>

<p>首先我们创建两个类AAA和AAB，分别打包到两个不同jar里，比如AAA.jar和AAB.jar，这两个类之间是有关系的，AAA里有个属性是AAB类型的，注意这两个jar不要放到classpath里让appClassLoader加载到：</p>

<p>```
public class AAA {</p>

<pre><code>    private AAB aab;
    public AAA(){
            aab=new AAB();
    }
    public void clear(){
            aab=null;
    }
</code></pre>

<p>}</p>

<p>public class AAB {}
```</p>

<p>接着我们创建一个类加载TestLoader，里面存一个WeakHashMap，专门来存TestLoader的，并且复写loadClass方法，如果是加载AAB这个类，就创建一个新的TestLoader来从AAB.jar里加载这个类</p>

<p>```
import java.net.URL;
import java.net.URLClassLoader;
import java.util.WeakHashMap;</p>

<p>public class TestLoader extends URLClassLoader {</p>

<pre><code>    public static WeakHashMap&lt;TestLoader,Object&gt; map=new WeakHashMap&lt;TestLoader,Object&gt;();
    private static int count=0;
    public TestLoader(URL[] urls){
            super(urls);
            map.put(this, new Object());
    }
    @SuppressWarnings("resource")
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
            if(name.equals("AAB") &amp;&amp; count==0){
                    try {
                            count=1;
                URL[] urls = new URL[1];
                urls[0] = new URL("file:///home/nijiaben/tmp/AAB.jar");
                return new TestLoader(urls).loadClass("AAB");
            }catch (Exception e){
                e.printStackTrace();
            }
            }else{
                    return super.loadClass(name);
            }
            return null;
    }
</code></pre>

<p>}
```</p>

<p>再看我们的主类TTest，一些说明都写在类里了：</p>

<p>```
import java.lang.reflect.Method;
import java.net.URL;</p>

<p>/<em>*
 * Created by nijiaben on 4/22/16.
 </em>/
public class TTest {</p>

<pre><code>private Object aaa;
public static void main(String args[]){
    try {
        TTest tt = new TTest();
        //将对象移到old，并置空aaa的aab属性
        test(tt);
        //清理掉aab对象
        System.gc();
        System.out.println("finished");
    }catch (Exception e){
        e.printStackTrace();
    }
}

@SuppressWarnings("resource")
    public static void test(TTest tt){
    try {
        //创建一个新的类加载器，从AAA.jar里加载AAA类
        URL[] urls = new URL[1];
        urls[0] = new URL("file:///home/nijiaben/tmp/AAA.jar");
        tt.aaa=new TestLoader(urls).loadClass("AAA").newInstance();
        //保证类加载器对象能进入到old里，因为ygc是不会对classLoader做清理的
        for(int i=0;i&lt;10;i++){
            System.gc();
            Thread.sleep(1000);
        }
        //将aaa里的aab属性清空掉，以便在后面gc的时候能清理掉aab对象，这样AAB的类加载器其实就没有什么地方有强引用了，在full gc的时候能被回收
        Method[] methods=tt.aaa.getClass().getDeclaredMethods();
        for(Method m:methods){
            if(m.getName().equals("clear")){
                    m.invoke(tt.aaa);
                    break;
            }
        }
    }catch (Exception e){
        e.printStackTrace();
    }
}
</code></pre>

<p>}
```</p>

<p>运行的时候请跑在JDK8下，打个断点在<code>System.out.println("finished")</code>的地方，然后做一次内存dump。</p>

<p>从上面的例子中我们得知，TTest是类加载器AppClassLoader加载的，其属性aaa的对象类型是通过TestLoader从AAA.jar里加载的，而aaa里的aab属性是从一个全新的类加载器TestLoader从AAB.jar里加载的，当我们做了多次System GC之后，这些对象会移到old，在做最后一次GC之后，aab对象会从内存里移除，其类加载器此时已经是没有任何地方的强引用了，只有一个WeakHashMap引用它，理论上做GC的时候也应该被回收，但是事实时这个AAB的这个类加载器并没有被回收，从分析结果来看，GC ROOT路径是WeakHashMap，如图所示：</p>

<p><img src="/images/2016/04/mat.png"></p>

<h2>JDK8里的metaspace</h2>

<p>这里不得不提的一个概念是JDK8里的metaspace，它是为了取代perm的，至于好处是什么，我个人觉得不是那么明显，有点费力不讨好的感觉，代码改了很多，但是实际收益并不明显，据说是oracle内部斗争的一个结果。</p>

<p>在JDK8里虽然没了perm，但是klass的信息还是要有地方存，jvm里为此分配了两块内存，一块是紧挨着heap来的，就和perm一样，专门用来存klass的信息，可以通过<code>-XX:CompressedClassSpaceSize</code>来设置大小，另外一块和它们不一定连着，主要是存非klass之外的其他信息，比如常量池什么的，可以通过<code>-XX:InitialBootClassLoaderMetaspaceSize</code>来设置，同时我们还可以通过<code>-XX:MaxMetaspaceSize</code>来设置触发metaspace回收的阈值。</p>

<p>每个类加载器都会从全局的metaspace空间里取一些metaChunk管理起来，当有类定义的时候，其实就是从这些内存里分配的，当不够的时候再去全局的metaspace里分配一块并管理起来。</p>

<p>这块具体的情况后面可以专门写一篇文章来介绍，包括内存结构，内存分配，GC等。</p>

<h2>JDK8里的ClassLoaderDataGraph</h2>

<p>每个类加载器都会对应一个ClassLoaderData的数据结构，里面会存譬如具体的类加载器对象，加载的klass，管理内存的metaspace等，它是一个链式结构，会链到下一个ClassLoaderData上，gc的时候通过ClassLoaderDataGraph来遍历这些ClassLoaderData，ClassLoaderDataGraph的第一个ClassLoaderData是bootstrapClassLoader的</p>

<p>```
class ClassLoaderData : public CHeapObj<mtClass> {
  ...
  static ClassLoaderData * _the_null_class_loader_data;</p>

<p>  oop _class_loader;          // oop used to uniquely identify a class loader</p>

<pre><code>                          // class loader or a canonical class path
</code></pre>

<p>  Dependencies _dependencies; // holds dependencies from this class loader</p>

<pre><code>                          // data to others.
</code></pre>

<p>  Metaspace * _metaspace;  // Meta-space where meta-data defined by the</p>

<pre><code>                       // classes in the class loader are allocated.
</code></pre>

<p>  Mutex* <em>metaspace_lock;  // Locks the metaspace for allocations and setup.
  bool </em>unloading;         // true if this class loader goes away
  bool <em>keep_alive;        // if this CLD is kept alive without a keep_alive_object().
  bool </em>is_anonymous;      // if this CLD is for an anonymous class
  volatile int _claimed;   // true if claimed, for example during GC traces.</p>

<pre><code>                       // To avoid applying oop closure more than once.
                       // Has to be an int because we cas it.
</code></pre>

<p>  Klass* _klasses;         // The classes defined by the class loader.</p>

<p>  JNIHandleBlock* _handles; // Handles to constant pool arrays</p>

<p>  // These method IDs are created for the class loader and set to NULL when the
  // class loader is unloaded.  They are rarely freed, only for redefine classes
  // and if they lose a data race in InstanceKlass.
  JNIMethodBlock*                  _jmethod_ids;</p>

<p>  // Metadata to be deallocated when it's safe at class unloading, when
  // this class loader isn't unloaded itself.
  GrowableArray&lt;Metadata<em>></em>      _deallocate_list;</p>

<p>  // Support for walking class loader data objects
  ClassLoaderData* _next; /// Next loader_datas created</p>

<p>  // ReadOnly and ReadWrite metaspaces (static because only on the null
  // class loader for now).
  static Metaspace<em> _ro_metaspace;
  static Metaspace</em> _rw_metaspace;</p>

<p>  ...</p>

<p>}
```</p>

<p>这里提几个属性：</p>

<ul>
<li><code>_class_loader</code> : 就是对应的类加载器对象</li>
<li><code>_keep_alive</code> : 如果这个值是true，那这个类加载器会认为是活的，会将其做为GC ROOT的一部分，gc的时候不会被回收</li>
<li><code>_unloading</code> : 表示这个类加载是否需要卸载的</li>
<li><code>_is_anonymous</code> : 是否匿名，这种ClassLoaderData主要是在lambda表达式里用的，这个我后面会详细说</li>
<li><code>_next</code> : 指向下一个ClassLoaderData，在gc的时候方便遍历</li>
<li><code>_dependencies</code> : 这个属性也是本文的重点，后面会细说</li>
</ul>


<p>再来看下构造函数：</p>

<p>```
ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool is_anonymous, Dependencies dependencies) :
  <em>class_loader(h_class_loader()),
  </em>is_anonymous(is_anonymous),
  // An anonymous class loader data doesn't have anything to keep
  // it from being unloaded during parsing of the anonymous class.
  // The null-class-loader should always be kept alive.
  <em>keep_alive(is_anonymous || h_class_loader.is_null()),
  </em>metaspace(NULL), <em>unloading(false), </em>klasses(NULL),
  <em>claimed(0), </em>jmethod_ids(NULL), <em>handles(NULL), </em>deallocate_list(NULL),
  <em>next(NULL), </em>dependencies(dependencies),
  _metaspace_lock(new Mutex(Monitor::leaf+1, "Metaspace allocation lock", true)) {</p>

<pre><code>// empty
</code></pre>

<p>}
<code>``
可见，</code><em>keep_ailve<code>属性的值是根据</code></em>is_anonymous`以及当前类加载器是不是bootstrapClassLoader来的。</p>

<p><code>_keep_alive</code>到底用在哪？其实是在GC的的时候，来决定要不要用Closure或者用什么Closure来扫描对应的ClassLoaderData。</p>

<p>```
void ClassLoaderDataGraph::roots_cld_do(CLDClosure<em> strong, CLDClosure</em> weak) {
  //从最后一个创建的classloader到bootstrapClassloader<br/>
  for (ClassLoaderData* cld = <em>head;  cld != NULL; cld = cld-></em>next) {</p>

<pre><code>//如果是ygc，那weak和strong是一样的，对所有的类加载器都做扫描，保证它们都是活的 
//如果是cms initmark阶段，如果要unload_classes了(should_unload_classes()返回true)，则weak为null，那就只遍历bootstrapclassloader以及正在做匿名类加载的类加载  
CLDClosure* closure = cld-&gt;keep_alive() ? strong : weak;
if (closure != NULL) {
  closure-&gt;do_cld(cld);
}
</code></pre>

<p>  }
```</p>

<h2>类加载器什么时候被回收</h2>

<p>类加载器是否需要被回收，其实就是看这个类加载器对象是否是活的，所谓活的就是这个类加载器加载的任何一个类或者这些类的对象是强可达的，当然还包括这个类加载器本身就是GC ROOT一部分或者有GC ROOT可达的路径，那这个类加载器就肯定不会被回收。</p>

<p>从各种GC情况来看：</p>

<ul>
<li>如果是YGC，类加载器是作为GC ROOT的，也就是都不会被回收</li>
<li>如果是Full GC，只要是死的就会被回收</li>
<li>如果是CMS GC，CMS GC过程也是会做标记的（这是默认情况，不过可以通过一些参数来改变），但是不会做真正的清理，真正的清理动作是发生在下次进入安全点的时候。</li>
</ul>


<h2>僵尸类加载器如何产生</h2>

<p>如果类加载器是与GC ROOT的对象存在真正依赖的这种关系，这种类加载器对象是活的无可厚非，我们通过zprofiler或者mat都可以分析出来，可以将链路绘出来，但是有两种情况例外：</p>

<h3>lambda匿名类加载</h3>

<p>lambda匿名类加载走的是unsafe的defineAnonymousClass方法，这个方法在vm里对应的是下面的方法</p>

<p>```
UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh))
{
  instanceKlassHandle anon_klass;
  jobject res_jh = NULL;</p>

<p>  UnsafeWrapper("Unsafe_DefineAnonymousClass");
  ResourceMark rm(THREAD);</p>

<p>  HeapWord* temp_alloc = NULL;</p>

<p>  anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data,</p>

<pre><code>                                            cp_patches_jh,
                                               &amp;temp_alloc, THREAD);
</code></pre>

<p>  if (anon_klass() != NULL)</p>

<pre><code>res_jh = JNIHandles::make_local(env, anon_klass-&gt;java_mirror());
</code></pre>

<p>  // try/finally clause:
  if (temp_alloc != NULL) {</p>

<pre><code>FREE_C_HEAP_ARRAY(HeapWord, temp_alloc, mtInternal);
</code></pre>

<p>  }</p>

<p>  // The anonymous class loader data has been artificially been kept alive to
  // this point.   The mirror and any instances of this class have to keep
  // it alive afterwards.
  if (anon_klass() != NULL) {</p>

<pre><code>anon_klass-&gt;class_loader_data()-&gt;set_keep_alive(false);
</code></pre>

<p>  }</p>

<p>  // let caller initialize it as needed...</p>

<p>  return (jclass) res_jh;
}
UNSAFE_END
}</p>

<p><code>``
可见，在创建成功匿名类之后，会将对应的ClassLoaderData的</code><em>keep_alive<code>属性设置为false，那是不是意味着</code></em>keep_alive<code>属性在这之前都是true呢？下面的</code>parse_stream`方法是从上面的方法最终会调下来的方法</p>

<p>```
Klass<em> SystemDictionary::parse_stream(Symbol</em> class_name,</p>

<pre><code>                                  Handle class_loader,
                                  Handle protection_domain,
                                  ClassFileStream* st,
                                  KlassHandle host_klass,
                                  GrowableArray&lt;Handle&gt;* cp_patches,
                                  TRAPS) {
</code></pre>

<p>  TempNewSymbol parsed_name = NULL;</p>

<p>  Ticks class_load_start_time = Ticks::now();</p>

<p>  ClassLoaderData* loader_data;
  if (host_klass.not_null()) {</p>

<pre><code>// Create a new CLD for anonymous class, that uses the same class loader
// as the host_klass
assert(EnableInvokeDynamic, "");
guarantee(host_klass-&gt;class_loader() == class_loader(), "should be the same");
guarantee(!DumpSharedSpaces, "must not create anonymous classes when dumping");
loader_data = ClassLoaderData::anonymous_class_loader_data(class_loader(), CHECK_NULL);
loader_data-&gt;record_dependency(host_klass(), CHECK_NULL);
</code></pre>

<p>  } else {</p>

<pre><code>loader_data = ClassLoaderData::class_loader_data(class_loader());
</code></pre>

<p>  }</p>

<p>  instanceKlassHandle k = ClassFileParser(st).parseClassFile(class_name,</p>

<pre><code>                                                         loader_data,
                                                         protection_domain,
                                                         host_klass,
                                                         cp_patches,
                                                         parsed_name,
                                                         true,
                                                         THREAD);
</code></pre>

<p>...</p>

<p>}</p>

<p>ClassLoaderData* ClassLoaderData::anonymous_class_loader_data(oop loader, TRAPS) {
  // Add a new class loader data to the graph.
  return ClassLoaderDataGraph::add(loader, true, CHECK_NULL);
}</p>

<p>ClassLoaderData* ClassLoaderDataGraph::add(Handle loader, bool is_anonymous, TRAPS) {
  // We need to allocate all the oops for the ClassLoaderData before allocating the
  // actual ClassLoaderData object.
  ClassLoaderData::Dependencies dependencies(CHECK_NULL);</p>

<p>  No_Safepoint_Verifier no_safepoints; // we mustn't GC until we've installed the</p>

<pre><code>                                   // ClassLoaderData in the graph since the CLD
                                   // contains unhandled oops
</code></pre>

<p>  ClassLoaderData* cld = new ClassLoaderData(loader, is_anonymous, dependencies);</p>

<p>...
}
```</p>

<p>从上面的代码得知，只要走了unsafe的那个方法，都会为当前类加载器创建一个ClassLoaderData对象，并设置其<code>_is_anonymous</code>为true，也同时意味着<code>_keep_alive</code>的属性是true，并加入到ClassLoaderDataGraph中。</p>

<p>试想如果创建的这个匿名类没有成功，也就是<code>anon_klass()==null</code>，那这个<code>_keep_alive</code>属性就永远无法设置为false了，这意味着这个ClassLoaderData对应的ClassLoader对象将永远都是GC ROOT的一部分，无法被回收，这种情况就是真正的僵尸类加载器了，不过目前我还没模拟出这种情况来，有兴趣的同学可以试一试，如果真的能模拟出来，这绝对是JDK里的一个BUG，可以提交给社区。</p>

<h3>类加载器依赖导致的</h3>

<p>这里说的类加载器依赖，并不是说ClassLoader里的parent建立的那种依赖关系，如果是这种关系，那其实通过mat或者zprofiler这样的工具都是可以分析出来的，但是还存在一种情况，那些工具都是分析不出来的，这种关系就是通过ClassLoaderData里的<code>_dependencies</code>属性得出来的，比如说如果A类加载器的<code>_dependencies</code>属性里记录了B类加载器，那当GC遍历A类加载器的时候也会遍历B类加载器，并将其标活，哪怕B类加载器其实是可以被回收了的，可以看下下面的代码</p>

<p>```
void ClassLoaderData::oops_do(OopClosure<em> f, KlassClosure</em> klass_closure, bool must_claim) {
  if (must_claim &amp;&amp; !claim()) {</p>

<pre><code>return;
</code></pre>

<p>  }</p>

<p>  f->do_oop(&amp;<em>class_loader);
  </em>dependencies.oops_do(f);
  _handles->oops_do(f);
  if (klass_closure != NULL) {</p>

<pre><code>classes_do(klass_closure);
</code></pre>

<p>  }
}
```</p>

<p>那问题来了，这种依赖关系是怎么记录的呢？其实我们上面的demo就模拟了这种情况，可以仔细去看看，我也针对这个demo描述下，比如加载AAA的类加载器TestLoader加载AAA后，并创建AAA对象，此时会看到有个类型是AAB的属性，此时会对常量池里的类型做一个解析，我们看到TestLoader的loadClass方法的时候做了一个判断，如果是AAB类型的类加载，那就创建一个新的类加载器对象从AAB.jar里去加载，当加载返回的时候，在jvm里其实就会记录这么一层依赖关系，认为AAA的类加载器依赖AAB的类加载器，并记录下来，但是纵观所有的hotspot代码，并没有一个地方来清理这种依赖关系的，也就是说只要这种依赖关系建立起来，会一直持续到AAA的类加载器被回收的时候，AAB的类加载器才会被回收，所以说这算一种伪僵尸类加载器，虽然从依赖关系上其实并不依赖了(比如demo里将AAA的aab属性做clear清空动作)，但是GC会一直认为他们是存在这种依赖关系的，会持续存在一段时间，具体持续多久就看AAA类加载器的情况了。</p>

<p>针对这种情况个人认为需要一个类似引用计数的GC策略，当某两个类加载器确实没有任何依赖的时候，将其清理掉这种依赖关系，估计要实现这种改动的地方也挺多，没那么简单，所以当时的设计者或许因为这样并没有这么做了，我觉得这算是偷懒妥协的结果吧，当然这只是我的一种猜测。</p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之栈溢出完全解读]]></title>
    <link href="http://nijiaben.github.io/blog/2016/04/19/stack-over-flow/"/>
    <updated>2016-04-19T01:24:25+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/04/19/stack-over-flow</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>之所以想写这篇文章，其实是因为最近有不少系统出现了栈溢出导致进程crash的问题，并且很隐蔽，根本原因还得借助coredump才能分析出来，于是想从JVM实现的角度来全面分析下栈溢出的这类问题，或许你碰到过如下的场景:</p>

<ul>
<li>日志里出现了StackOverflowError的异常</li>
<li>进程突然消失了，但是留下了crash日志</li>
<li>进程消失了，crash日志也没有留下</li>
</ul>


<p>这些都可能是栈溢出导致的。</p>

<!--more-->


<h2>如何定位是否是栈溢出</h2>

<p>上面提到的后面两种情况有可能不是我们今天要聊的栈溢出的问题导致的crash，也许是别的一些可能，那如何确定上面三种情况是栈溢出导致的呢？</p>

<ul>
<li>出现了StackOverflowError，这种毫无疑问，必然是栈溢出，具体什么方法导致的栈溢出从栈上是能知道的，不过要提醒一点，我们打印出来看到的栈可能是不全的，因为JVM里对栈的输出条数是可以控制的，默认是1024，这个参数是<code>-XX:MaxJavaStackTraceDepth=1024</code>，可以将这个参数设置为-1，那将会全部输出对应的堆栈</li>
<li>如果进程消失了，但是留下了crash日志，那请检查下crash日志里的Current thread的stack范围，以及RSP寄存器的值，如果RSP寄存器的值是超出这个stack范围的，那说明是栈溢出了。</li>
<li>如果crash日志也没有留下，那只能通过coredump来分析了，在进程运行前，先执行<code>ulimit -c unlimited</code>，然后再跑进程，在进程挂掉之后，会产生一个<code>core.&lt;pid&gt;</code>的文件，然后再通过<code>jstack $JAVA_HOME/bin/java core.&lt;pid&gt;</code>来看输出的栈，如果正常输出了，那就可以看是否存在很长的调用栈的线程，当然还有可能没有正常输出的，因为jstack的这条从core文件抓栈的命令其实是基于serviceability agent来实现的，而SA在某些版本里是存在bug的，当然现在的SA也不能说完全没有bug，还是存在不少bug的，祝你好运。</li>
</ul>


<h2>如何解决栈溢出的问题</h2>

<p>这个需要具体问题具体分析，因为导致栈溢出的原因很多，提三个主要的：
* java代码写得不当，比如出现递归死循环，这也是最常见的，只能靠写代码的人稍微小心了
* native代码有栈上分配的逻辑，并且要求的内存还不小
* 线程栈空间设置比较小</p>

<p>有时候我们的代码需要调用到native里去，最常见的一种情况譬如<code>java.net.SocketInputStream.read0</code>方法，这是一个native方法，在进入到这个方法里之后，它首先就要求到栈上去分配一个64KB的缓存(64位linux)，试想一下如果执行到read0这个方法的时候，剩余的栈空间已经不足以分配64KB的内存了会怎样？也许就是一开头我们提到的crash，这只是一个例子，还有其他的一些native实现，包括我们自己也可能写这种native代码，如果真有这种情况，我们就需要好好斟酌下我们的线程栈到底要设置多大了。</p>

<p>如果我们的代码确实存在正常的很深的递归调用的话，通常是我们的栈可能设置太小，我们可以通过<code>-Xss</code>或者<code>-XX:ThreadStackSize</code>来设置java线程栈的大小，如果两个参数都设置了，那具体有效的是写在后面的那个生效。顺便提下，线程栈内存是和java heap独立的内存，并不是在java heap内分配的，是直接malloc分配的内存。</p>

<h2>线程栈大小</h2>

<p>在jvm里，线程其实不仅仅只有一种，比如我们java里创建的叫做java线程，还有gc线程，编译线程等，默认情况下他们的栈大小如下：</p>

<p>```
size_t os::Linux::default_stack_size(os::ThreadType thr_type) {
  // default stack size (compiler thread needs larger stack)</p>

<h1>ifdef AMD64</h1>

<p>  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);</p>

<h1>else</h1>

<p>  size_t s = (thr_type == os::compiler_thread ? 2 * M : 512 * K);</p>

<h1>endif // AMD64</h1>

<p>  return s;
}
```
可见默认情况下编译线程需要的栈空间是其他种类线程的4倍。</p>

<p>各种类型的线程他们所需要的栈的大小其实是可以通过不同的参数来控制的：</p>

<p>```
switch (thr_type) {</p>

<pre><code>  case os::java_thread:
    // Java threads use ThreadStackSize which default value can be
    // changed with the flag -Xss
    assert (JavaThread::stack_size_at_create() &gt; 0, "this should be set");
    stack_size = JavaThread::stack_size_at_create();
    break;
  case os::compiler_thread:
    if (CompilerThreadStackSize &gt; 0) {
      stack_size = (size_t)(CompilerThreadStackSize * K);
      break;
    } // else fall through:
      // use VMThreadStackSize if CompilerThreadStackSize is not defined
  case os::vm_thread:
  case os::pgc_thread:
  case os::cgc_thread:
  case os::watcher_thread:
    if (VMThreadStackSize &gt; 0) stack_size = (size_t)(VMThreadStackSize * K);
    break;
  }
</code></pre>

<p>```</p>

<ul>
<li><code>java_thread</code>的stack_size，其实就是-Xss或者-XX:ThreadStackSize的值</li>
<li><code>compiler_thread</code>的stack_size，是-XX:CompilerThreadStackSize指定的值</li>
<li>vm内部的线程比如gc线程等可以通过-XX:VMThreadStackSize来设置</li>
</ul>


<h2>JVM里栈溢出的实现</h2>

<p>JVM里的栈溢出到底是怎么实现的，得从栈的大致结构说起：</p>

<p><code>
// Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\  JavaThread created by VM does not have glibc
//    |    glibc guard page    | - guard, attached Java thread usually has
//    |                        |/  1 page glibc guard.
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |  HotSpot Guard Pages   | - red and yellow pages
//    |                        |/
//    +------------------------+ JavaThread::stack_yellow_zone_base()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// Non-Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\
//    |  glibc guard page      | - usually 1 page
//    |                        |/
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
//    pthread_attr_getstack()
</code></p>

<p>linux下java线程栈是从高地址往低地址方向走的，在栈尾（低地址）会预留两块受保护的内存区域，分别叫做yellow page和red page，其中yellow page在前，另外如果是java创建的线程，最后并没有图示的一个page的<code>glibc guard page</code>，非java线程是有的，但是没有yellow和red page，比如我们的gc线程，注意编译线程其实是java线程。</p>

<p>除了yellow page和red page，其实还有个shadow page，这三个page可以分别通过vm参数<code>-XX:StackYellowPages</code>,<code>-XX:StackRedPages</code>,<code>-XX:StackShadowPages</code>来控制。当我们要调用某个java方法的时候，它需要多大的栈其实是预先知道的，javac里就计算好了，但是如果调用的是native方法，那这就不好办了，在native方法里到底需要多大内存，这个无法得知，因此shadow page就是用来做一个大致的预测，看需要多大的栈空间，如果预测到新的RSP的值超过了yellowpage的位置，那就直接抛出栈溢出的异常，否则就去新的方法里处理，当我们的代码访问到yellow page或者red page里的地址的时候，因为这块内存是受保护的，所以会产生SIGSEGV的信号，此时会交给JVM里的信号处理函数来处理，针对yellow page以及red page会有不同的处理策略，其中yellow page的处理是会抛出StackOverflowError的异常，进程不会挂掉，也就是文章开头提到的第一个场景，但是如果是red page，那将直接导致进程退出，不过还是会产生Crash的日志，也就是文章开头提到的第二个场景，另外还有第三个场景，其实是没有栈空间了并且访问了超过了red page的地址，这个时候因为栈空间不够了，所以信号处理函数都进不去，因此就直接crash了，crash日志也不会产生。</p>

<p>```
 if (sig == SIGSEGV) {</p>

<pre><code>  address addr = (address) info-&gt;si_addr;

  // check if fault address is within thread stack
  if (addr &lt; thread-&gt;stack_base() &amp;&amp;
      addr &gt;= thread-&gt;stack_base() - thread-&gt;stack_size()) {
    // stack overflow
    if (thread-&gt;in_stack_yellow_zone(addr)) {
      thread-&gt;disable_stack_yellow_zone();
      if (thread-&gt;thread_state() == _thread_in_Java) {
        // Throw a stack overflow exception.  Guard pages will be reenabled
        // while unwinding the stack.
        stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
      } else {
        // Thread was in the vm or native code.  Return and try to finish.
        return 1;
      }
    } else if (thread-&gt;in_stack_red_zone(addr)) {
      // Fatal red zone violation.  Disable the guard pages and fall through
      // to handle_unexpected_exception way down below.
      thread-&gt;disable_stack_red_zone();
      tty-&gt;print_raw_cr("An irrecoverable stack overflow has occurred.");

      // This is a likely cause, but hard to verify. Let's just print
      // it as a hint.
      tty-&gt;print_raw_cr("Please check if any of your loaded .so files has "
                        "enabled executable stack (see man page execstack(8))");
    } else {
      // Accessing stack address below sp may cause SEGV if current
      // thread has MAP_GROWSDOWN stack. This should only happen when
      // current thread was created by user code with MAP_GROWSDOWN flag
      // and then attached to VM. See notes in os_linux.cpp.
      if (thread-&gt;osthread()-&gt;expanding_stack() == 0) {
         thread-&gt;osthread()-&gt;set_expanding_stack();
         if (os::Linux::manually_expand_stack(thread, addr)) {
           thread-&gt;osthread()-&gt;clear_expanding_stack();
           return 1;
         }
         thread-&gt;osthread()-&gt;clear_expanding_stack();
      } else {
         fatal("recursive segv. expanding stack.");
      }
    }
 }
</code></pre>

<p>  }</p>

<p>  ......</p>

<p>  if (stub != NULL) {</p>

<pre><code>// save all thread context in case we need to restore it
if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);

uc-&gt;uc_mcontext.gregs[REG_PC] = (greg_t)stub;
return true;
</code></pre>

<p>  }</p>

<p>  // signal-chaining
  if (os::Linux::chained_handler(sig, info, ucVoid)) {</p>

<pre><code> return true;
</code></pre>

<p>  }</p>

<p>  if (!abort_if_unrecognized) {</p>

<pre><code>// caller wants another chance, so give it to him
return false;
</code></pre>

<p>  }</p>

<p>  if (pc == NULL &amp;&amp; uc != NULL) {</p>

<pre><code>pc = os::Linux::ucontext_get_pc(uc);
</code></pre>

<p>  }</p>

<p>  // unmask current signal
  sigset_t newset;
  sigemptyset(&amp;newset);
  sigaddset(&amp;newset, sig);
  sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);</p>

<p>  VMError err(t, sig, pc, info, ucVoid);
  err.report_and_die();</p>

<p>  ShouldNotReachHere(); <br/>
```
了解上面的场景之后，再回过头来想想JVM为什么要设置这几个page，其实是为了安全，能预测到栈溢出的话就抛出StackOverfolwError，而避免导致进程挂掉。</p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDK8在泛型类型推导上的变化]]></title>
    <link href="http://nijiaben.github.io/blog/2016/04/03/type-inference/"/>
    <updated>2016-04-03T12:50:39+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/04/03/type-inference</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>最近公司在大面积推广JDK8，整体来说升级上来算顺利的，大部分问题可能在编译期就碰到了，但是有些时候比较蛋疼，编译期没有出现问题，但是在运行期就出了问题，比如今天要说的这个话题，所以大家再升级的时候还是要多测测再上线，当然JDK8给我们带来了不少收益，花点时间升级上来还是值得的。</p>

<!--more-->


<h2>问题描述</h2>

<p>还是老规矩，先上demo，让大家直观地知道我们要说的问题。</p>

<p>```
public class Test {</p>

<pre><code>  static &lt;T extends Number&gt; T getObject() {
        return (T)Long.valueOf(1L);
  }

  public static void main(String... args) throws Exception {
        StringBuilder sb = new StringBuilder();
        sb.append(getObject());
  }
</code></pre>

<p>}
```
demo很简单，就是有个使用了泛型的函数getObject，其返回类型是Number的子类，然后我们将函数返回值传给StringBuilder的多态方法append，我们知道append方法有很多，参数类型也很多，但是唯独没有参数是Number的append方法，如果有的话，大家应该猜到会优先选择这个方法了，既然没有，那到底会选哪个呢，我们分别用jdk6(jdk7类似)和jdk8来编译下上面的类，然后用javap看看输出结果（只看main方法）：</p>

<p>jdk6编译的字节码：</p>

<p>```
public static void main(java.lang.String...) throws java.lang.Exception;</p>

<pre><code>flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS
Code:
  stack=2, locals=2, args_size=1
     0: new           #3                  // class java/lang/StringBuilder
     3: dup
     4: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V
     7: astore_1
     8: aload_1
     9: invokestatic  #5                  // Method getObject:()Ljava/lang/Number;
    12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
    15: pop
    16: return
  LineNumberTable:
    line 8: 0
    line 9: 8
    line 10: 16
Exceptions:
  throws java.lang.Exception
</code></pre>

<p>```</p>

<p>jdk8编译的字节码：</p>

<p>```
public static void main(java.lang.String...) throws java.lang.Exception;</p>

<pre><code>descriptor: ([Ljava/lang/String;)V
flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS
Code:
  stack=2, locals=2, args_size=1
     0: new           #3                  // class java/lang/StringBuilder
     3: dup
     4: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V
     7: astore_1
     8: aload_1
     9: invokestatic  #5                  // Method getObject:()Ljava/lang/Number;
    12: checkcast     #6                  // class java/lang/CharSequence
    15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;
    18: pop
    19: return
  LineNumberTable:
    line 8: 0
    line 9: 8
    line 10: 19
Exceptions:
  throws java.lang.Exception
</code></pre>

<p>```</p>

<p>对比上面那个的差异，我们看到bci从12开始变了，jdk8里多了下面这行表示要对栈顶的数据做一次类型检查看是不是CharSequence类型：</p>

<p><code>
 12: checkcast     #6                  // class java/lang/CharSequence
</code></p>

<p>另外调用的StringBuilder的append方法也是不一样的，jdk7里是调用的参数为Object类型的append方法，而jdk8里调用的是CharSequence类型的append方法。</p>

<p>最主要的是在jdk6和jdk8下运行上面的代码，在jdk6下是正常跑过的，但是在jdk8下是直接抛出异常的：</p>

<p>```
Exception in thread "main" java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.CharSequence</p>

<pre><code>at Test.main(Test.java:9)
</code></pre>

<p>```</p>

<p>至此问题整个应该描述清楚了。</p>

<h2>问题分析</h2>

<p>先来说说如果要我们来做这个java编译器实现这个功能，我们要怎么来做，其他的都是很明确的，重点在于如下这段如何来确定append的方法使用哪个：</p>

<p><code>
sb.append(getObject());
</code>
我们知道getObject()返回的是个泛型对象，这个对象是Number的子类，因此我们首先会去遍历StringBuilder的所有可见的方法，包括从父类继承过来的，找是不是存在一个方法叫做append，并且参数类型是Number的方法，如果有，那就直接使用这个方法，如果没有，那我们得想办法找到一个最合适的方法，关键就在于这个合适怎么定义，比如说我们看到有个append的方法，其参数是Object类型的，Number是Object的子类，所以我们选择这个方法肯定没问题，假如说另外有个append方法，其参数是Serializable类型(当然其实并没有这种参数的方法)，Number实现了这个接口，我们选择这个方法也是没问题的，那到底是Object参数的更合适还是Serializable的更合适呢，还有更甚者，我们知道StringBuilder有个方法，其参数是CharSequence，假如我们传进去的参数其实既是Number的子类，同时又实现了CharSequence这个接口，那我们究竟要不要选它呢？这些问题我们都需要去考虑，而且各有各的理由，说起来都感觉挺合理的。</p>

<h2>JDK6里泛型的类型推导</h2>

<p>这里分析的是jdk6的javac代码，不过大致看了下jdk7的这块针对这个问题的逻辑也差不多，所以就以这块为例了，jdk6里的泛型类型推导其实比较简单，从上面的输出结果我们也猜到了，其实就是选了参数为Object类型的append方法，它觉得它是最合适的：</p>

<p>```
private Symbol findMethod(Env<AttrContext> env,</p>

<pre><code>                          Type site,
                          Name name,
                          List&lt;Type&gt; argtypes,
                          List&lt;Type&gt; typeargtypes,
                          Type intype,
                          boolean abstractok,
                          Symbol bestSoFar,
                          boolean allowBoxing,
                          boolean useVarargs,
                          boolean operator) {
    for (Type ct = intype; ct.tag == CLASS; ct = types.supertype(ct)) {
        ClassSymbol c = (ClassSymbol)ct.tsym;
        if ((c.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) == 0)
            abstractok = false;
        for (Scope.Entry e = c.members().lookup(name);
             e.scope != null;
             e = e.next()) {
            //- System.out.println(" e " + e.sym);
            if (e.sym.kind == MTH &amp;&amp;
                (e.sym.flags_field &amp; SYNTHETIC) == 0) {
                bestSoFar = selectBest(env, site, argtypes, typeargtypes,
                                       e.sym, bestSoFar,
                                       allowBoxing,
                                       useVarargs,
                                       operator);
            }
        }
        //- System.out.println(" - " + bestSoFar);
        if (abstractok) {
            Symbol concrete = methodNotFound;
            if ((bestSoFar.flags() &amp; ABSTRACT) == 0)
                concrete = bestSoFar;
            for (List&lt;Type&gt; l = types.interfaces(c.type);
                 l.nonEmpty();
                 l = l.tail) {
                bestSoFar = findMethod(env, site, name, argtypes,
                                       typeargtypes,
                                       l.head, abstractok, bestSoFar,
                                       allowBoxing, useVarargs, operator);
            }
        if (concrete != bestSoFar &amp;&amp;
                concrete.kind &lt; ERR  &amp;&amp; bestSoFar.kind &lt; ERR &amp;&amp;
                types.isSubSignature(concrete.type, bestSoFar.type))
                bestSoFar = concrete;
        }
    }
    return bestSoFar;
}
</code></pre>

<p>```</p>

<p>上面的逻辑大概是遍历当前类(比如这个例子中的StringBuilder)及其父类，依次从他们的方法里找出一个最合适的方法返回，重点就落在了selectBest这个方法上:</p>

<p>```
Symbol selectBest(Env<AttrContext> env,</p>

<pre><code>                  Type site,
                  List&lt;Type&gt; argtypes,
                  List&lt;Type&gt; typeargtypes,
                  Symbol sym,
                  Symbol bestSoFar,
                  boolean allowBoxing,
                  boolean useVarargs,
                  boolean operator) {
    if (sym.kind == ERR) return bestSoFar;
    if (!sym.isInheritedIn(site.tsym, types)) return bestSoFar;
    assert sym.kind &lt; AMBIGUOUS;
    try {
        if (rawInstantiate(env, site, sym, argtypes, typeargtypes,
                           allowBoxing, useVarargs, Warner.noWarnings) == null) {
            // inapplicable
            switch (bestSoFar.kind) {
            case ABSENT_MTH: return wrongMethod.setWrongSym(sym);
            case WRONG_MTH: return wrongMethods;
            default: return bestSoFar;
            }
        }
    } catch (Infer.NoInstanceException ex) {
        switch (bestSoFar.kind) {
        case ABSENT_MTH:
            return wrongMethod.setWrongSym(sym, ex.getDiagnostic());
        case WRONG_MTH:
            return wrongMethods;
        default:
            return bestSoFar;
        }
    }
    if (!isAccessible(env, site, sym)) {
        return (bestSoFar.kind == ABSENT_MTH)
            ? new AccessError(env, site, sym)
            : bestSoFar;
    }
    return (bestSoFar.kind &gt; AMBIGUOUS)
        ? sym
        : mostSpecific(sym, bestSoFar, env, site,
                       allowBoxing &amp;&amp; operator, useVarargs);
}
</code></pre>

<p>```
这个方法的主要逻辑落在rawInstantiate这个方法里(具体代码不贴了，有兴趣的去看下代码，我将最终最关键的调用方法argumentsAcceptable贴出来，主要做参数的匹配)，如果当前方法也合适，那就和之前挑出来的最好的方法做一个比较看谁最适合，这个选择过程在最后的mostSpecific方法里，其实就和冒泡排序差不多，不过是找最接近的那个类型(逐层找对应是父类的方法，和最小公倍数有点类似)。</p>

<p>```</p>

<pre><code>boolean argumentsAcceptable(List&lt;Type&gt; argtypes,
                            List&lt;Type&gt; formals,
                            boolean allowBoxing,
                            boolean useVarargs,
                            Warner warn) {
    Type varargsFormal = useVarargs ? formals.last() : null;
    while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
        boolean works = allowBoxing
            ? types.isConvertible(argtypes.head, formals.head, warn)
            : types.isSubtypeUnchecked(argtypes.head, formals.head, warn);
        if (!works) return false;
        argtypes = argtypes.tail;
        formals = formals.tail;
    }
    if (formals.head != varargsFormal) return false; // not enough args
    if (!useVarargs)
        return argtypes.isEmpty();
    Type elt = types.elemtype(varargsFormal);
    while (argtypes.nonEmpty()) {
        if (!types.isConvertible(argtypes.head, elt, warn))
            return false;
        argtypes = argtypes.tail;
    }
    return true;
}    
</code></pre>

<p>```
针对具体的例子其实就是看StringBuilder里的哪个方法的参数是Number的父类，如果不是就表示没有找到，如果参数都符合期望就表示找到，然后返回。</p>

<p>所以jdk6里的这块的逻辑相对来说比较简单。</p>

<h2>JDK8里泛型的类型推导</h2>

<p>jdk8里的推导相对来说比较复杂，不过大部分逻辑和上面的都差不多，但是argumentsAcceptable这块的变动比较大，增加了一些数据结构，规则变得更加复杂，考虑的场景也更多了，因为代码嵌套层数很深，具体的代码我就不贴了，有兴趣的自己去跟下代码（具体变化可以从AbstractMethodCheck.argumentsAcceptable这个方法开始）。</p>

<p>针对具体这个demo，如果getObject返回的对象既实现了CharSequence，又是Number的子类，那它认为这种情况其实选择参数为CharSequence类型的append方法比参数为Object类型的方法更合适，看起来是要求更严格一些了，适用范围收窄了一些，不是去匹配大而范的接口方法，因此其多加了一层checkcast的检查，不过我个人观点是觉得这块有点太激进了。</p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不可逆的类初始化过程]]></title>
    <link href="http://nijiaben.github.io/blog/2016/03/31/class-init/"/>
    <updated>2016-03-31T22:11:56+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/03/31/class-init</id>
    <content type="html"><![CDATA[<p>类的加载过程说复杂很复杂，说简单也简单，说复杂是因为细节很多，比如说今天要说的这个，可能很多人都不了解；说简单，大致都知道类加载有这么几个阶段，loaded->linked->initialized，为了让大家能更轻松地知道我今天说的这个话题，我不详细说类加载的整个过程，改天有时间有精力了我将整个类加载的过程和大家好好说说（PS：我对类加载过程慢慢清晰起来得益于当初在支付宝做cloudengine容器开发的时候，当时引入了标准的osgi，解决类加载的问题几乎是每天的家常便饭，相信大家如果还在使用OSGI，那估计能体会我当时的那种痛，哈哈）。</p>

<!--more-->


<p>本文我想说的是最后一个阶段，类的初始化，但是也不细说其中的过程，只围绕我们今天要说的展开。</p>

<p>我们定义一个类的时候，可能有静态变量，可能有静态代码块，这些逻辑编译之后会封装到一个叫做clinit的方法里，比如下面的代码：</p>

<p>```
class BadClass{</p>

<pre><code>private static int a=100;
static{
    System.out.println("before init");
    int b=3/0;
    System.out.println("after init");
}

public static void doSomething(){
    System.out.println("do somthing");
}
</code></pre>

<p>}
<code>``
编译之后我们通过</code>javap -verbose BadClass`可以看到如下字节码：</p>

<p>```
{
  BadClass();</p>

<pre><code>flags:
Code:
  stack=1, locals=1, args_size=1
     0: aload_0
     1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
     4: return
  LineNumberTable:
    line 1: 0
</code></pre>

<p>  public static void doSomething();</p>

<pre><code>flags: ACC_PUBLIC, ACC_STATIC
Code:
  stack=2, locals=0, args_size=0
     0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
     3: ldc           #3                  // String do somthing
     5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     8: return
  LineNumberTable:
    line 10: 0
    line 11: 8
</code></pre>

<p>  static {};</p>

<pre><code>flags: ACC_STATIC
Code:
  stack=2, locals=1, args_size=0
     0: bipush        100
     2: putstatic     #5                  // Field a:I
     5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
     8: ldc           #6                  // String before init
    10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
    13: iconst_3
    14: iconst_0
    15: idiv
    16: istore_0
    17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
    20: ldc           #7                  // String after init
    22: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
    25: return
  LineNumberTable:
    line 2: 0
    line 4: 5
    line 5: 13
    line 6: 17
    line 7: 25
</code></pre>

<p>}
```</p>

<p>我们看到最后那个方法<code>static{}</code>，其实就是我上面说的clinit方法，我们看到静态字段的初始化和静态代码库都封装在这个方法里。</p>

<p>假如我们通过如下代码来测试上面的类：</p>

<p>```
 public static void main(String args[]){</p>

<pre><code>    try{
        BadClass.doSomething();
    }catch (Throwable e){
        e.printStackTrace();
    }

    BadClass.doSomething();
}
</code></pre>

<p>```</p>

<p>大家觉得输出会是什么？是会打印多次<code>before init</code>吗？其实不然，输出结果如下：</p>

<p>```
before init
java.lang.ExceptionInInitializerError</p>

<pre><code>at ObjectTest.main(ObjectTest.java:7)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
</code></pre>

<p>Caused by: java.lang.ArithmeticException: / by zero</p>

<pre><code>at BadClass.&lt;clinit&gt;(ObjectTest.java:25)
... 6 more
</code></pre>

<p>Exception in thread "main" java.lang.NoClassDefFoundError: Could not initialize class BadClass</p>

<pre><code>at ObjectTest.main(ObjectTest.java:12)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
</code></pre>

<p>```</p>

<p>也就是说其实是只输出了一次<code>before init</code>，这是为什么呢？</p>

<p>clinit方法在我们第一次主动使用这个类的时候会触发执行，比如我们访问这个类的静态方法或者静态字段就会触发执行clinit，但是这个过程是不可逆的，也就是说当我们执行一遍之后再也不会执行了，如果在执行这个方法过程中出现了异常没有被捕获，那这个类将永远不可用，虽然我们上面执行<code>BadClass.doSomething()</code>的时候catch住了异常，但是当代码跑到这里的时候，在jvm里已经将这个类打上标记了，说这个类初始化失败了，下次再初始化的时候就会直接返回并抛出类似的异常<code>java.lang.NoClassDefFoundError: Could not initialize class BadClass</code>，而不去再次执行初始化的逻辑，具体可以看下jvm里对类的状态定义：</p>

<p>```
 enum ClassState {</p>

<pre><code>unparsable_by_gc = 0,               // object is not yet parsable by gc. Value of _init_state at object allocation.
allocated,                          // allocated (but not yet linked)
loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
linked,                             // successfully linked/verified (but not initialized yet)
being_initialized,                  // currently running class initializer
fully_initialized,                  // initialized (successfull final state)
initialization_error                // error happened during initialization
</code></pre>

<p>  };
```</p>

<p>如果clinit执行失败了，抛了一个未被捕获的异常，那将这个类的状态设置为<code>initialization_error</code>,并且无法再恢复，因为jvm会认为你这次初始化失败了，下次肯定也是失败的，为了防止不断抛这种异常，所以做了一个缓存处理，不是每次都再去执行clinit，因此大家要特别注意，类的初始化过程可千万不能出错，出错就可能只能重启了哦。</p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
</feed>
