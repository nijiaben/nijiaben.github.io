<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JVM | 你假笨]]></title>
  <link href="http://nijiaben.github.io/blog/categories/jvm/atom.xml" rel="self"/>
  <link href="http://nijiaben.github.io/"/>
  <updated>2016-03-31T22:13:40+08:00</updated>
  <id>http://nijiaben.github.io/</id>
  <author>
    <name><![CDATA[你假笨]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[不可逆的类初始化过程]]></title>
    <link href="http://nijiaben.github.io/blog/2016/03/31/class-init/"/>
    <updated>2016-03-31T22:11:56+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/03/31/class-init</id>
    <content type="html"><![CDATA[<p>类的加载过程说复杂很复杂，说简单也简单，说复杂是因为细节很多，比如说今天要说的这个，可能很多人都不了解；说简单，大致都知道类加载有这么几个阶段，loaded->linked->initialized，为了让大家能更轻松地知道我今天说的这个话题，我不详细说类加载的整个过程，改天有时间有精力了我将整个类加载的过程和大家好好说说（PS：我对类加载过程慢慢清晰起来得益于当初在支付宝做cloudengine容器开发的时候，当时引入了标准的osgi，解决类加载的问题几乎是每天的家常便饭，相信大家如果还在使用OSGI，那估计能体会我当时的那种痛，哈哈）。</p>

<!--more-->


<p>本文我想说的是最后一个阶段，类的初始化，但是也不细说其中的过程，只围绕我们今天要说的展开。</p>

<p>我们定义一个类的时候，可能有静态变量，可能有静态代码块，这些逻辑编译之后会封装到一个叫做clinit的方法里，比如下面的代码：</p>

<p>```
class BadClass{</p>

<pre><code>private static int a=100;
static{
    System.out.println("before init");
    int b=3/0;
    System.out.println("after init");
}

public static void doSomething(){
    System.out.println("do somthing");
}
</code></pre>

<p>}
<code>``
编译之后我们通过</code>javap -verbose BadClass`可以看到如下字节码：</p>

<p>```
{
  BadClass();</p>

<pre><code>flags:
Code:
  stack=1, locals=1, args_size=1
     0: aload_0
     1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
     4: return
  LineNumberTable:
    line 1: 0
</code></pre>

<p>  public static void doSomething();</p>

<pre><code>flags: ACC_PUBLIC, ACC_STATIC
Code:
  stack=2, locals=0, args_size=0
     0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
     3: ldc           #3                  // String do somthing
     5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     8: return
  LineNumberTable:
    line 10: 0
    line 11: 8
</code></pre>

<p>  static {};</p>

<pre><code>flags: ACC_STATIC
Code:
  stack=2, locals=1, args_size=0
     0: bipush        100
     2: putstatic     #5                  // Field a:I
     5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
     8: ldc           #6                  // String before init
    10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
    13: iconst_3
    14: iconst_0
    15: idiv
    16: istore_0
    17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
    20: ldc           #7                  // String after init
    22: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
    25: return
  LineNumberTable:
    line 2: 0
    line 4: 5
    line 5: 13
    line 6: 17
    line 7: 25
</code></pre>

<p>}
```</p>

<p>我们看到最后那个方法<code>static{}</code>，其实就是我上面说的clinit方法，我们看到静态字段的初始化和静态代码库都封装在这个方法里。</p>

<p>假如我们通过如下代码来测试上面的类：</p>

<p>```
 public static void main(String args[]){</p>

<pre><code>    try{
        BadClass.doSomething();
    }catch (Throwable e){
        e.printStackTrace();
    }

    BadClass.doSomething();
}
</code></pre>

<p>```</p>

<p>大家觉得输出会是什么？是会打印多次<code>before init</code>吗？其实不然，输出结果如下：</p>

<p>```
before init
java.lang.ExceptionInInitializerError</p>

<pre><code>at ObjectTest.main(ObjectTest.java:7)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
</code></pre>

<p>Caused by: java.lang.ArithmeticException: / by zero</p>

<pre><code>at BadClass.&lt;clinit&gt;(ObjectTest.java:25)
... 6 more
</code></pre>

<p>Exception in thread "main" java.lang.NoClassDefFoundError: Could not initialize class BadClass</p>

<pre><code>at ObjectTest.main(ObjectTest.java:12)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
</code></pre>

<p>```</p>

<p>也就是说其实是只输出了一次<code>before init</code>，这是为什么呢？</p>

<p>clinit方法在我们第一次主动使用这个类的时候会触发执行，比如我们访问这个类的静态方法或者静态字段就会触发执行clinit，但是这个过程是不可逆的，也就是说当我们执行一遍之后再也不会执行了，如果在执行这个方法过程中出现了异常没有被捕获，那这个类将永远不可用，虽然我们上面执行<code>BadClass.doSomething()</code>的时候catch住了异常，但是当代码跑到这里的时候，在jvm里已经将这个类打上标记了，说这个类初始化失败了，下次再初始化的时候就会直接返回并抛出类似的异常<code>java.lang.NoClassDefFoundError: Could not initialize class BadClass</code>，而不去再次执行初始化的逻辑，具体可以看下jvm里对类的状态定义：</p>

<p>```
 enum ClassState {</p>

<pre><code>unparsable_by_gc = 0,               // object is not yet parsable by gc. Value of _init_state at object allocation.
allocated,                          // allocated (but not yet linked)
loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
linked,                             // successfully linked/verified (but not initialized yet)
being_initialized,                  // currently running class initializer
fully_initialized,                  // initialized (successfull final state)
initialization_error                // error happened during initialization
</code></pre>

<p>  };
```</p>

<p>如果clinit执行失败了，抛了一个未被捕获的异常，那将这个类的状态设置为<code>initialization_error</code>,并且无法再恢复，因为jvm会认为你这次初始化失败了，下次肯定也是失败的，为了防止不断抛这种异常，所以做了一个缓存处理，不是每次都再去执行clinit，因此大家要特别注意，类的初始化过程可千万不能出错，出错就可能只能重启了哦。</p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何定位消耗CPU最多的线程]]></title>
    <link href="http://nijiaben.github.io/blog/2016/03/31/cpu-thread/"/>
    <updated>2016-03-31T18:27:35+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/03/31/cpu-thread</id>
    <content type="html"><![CDATA[<p>之前有朋友反馈说发的内容希望有个梯度，逐步加深，前面发了几篇关于jvm源码分析的文章，可能我觉得我已经把内容写得浅显易懂了，但是对于某些没怎么接触的同学来说还是比较难理解，这个我以后慢慢改进吧，今天发篇轻松点的文章，可能大家在工作过程中也会可能碰到类似的问题，或许有经验的同学看到这个题目就知道我要说什么了，也有自己的定位方法。</p>

<!--more-->


<p>话不多说了，先来看代码吧</p>

<p>```
public class Test{</p>

<pre><code>    public static void main(String args[]){
            for(int i=0;i&lt;10;i++){
                    new Thread(){
                            public void run(){
                                    try{
                                            Thread.sleep(100000);
                                    }catch(Exception e){}
                            }
                    }.start();
            }
            Thread t=new Thread(){
                    public void run(){
                            int i=0;
                            while(true){
                                    i=(i++)/100;
                            }
                    }
            };
            t.setName("Busiest Thread");
            t.start();
    }
</code></pre>

<p>}
```</p>

<p>这个例子里新创建了11个线程，其中10个线程没干什么事，主要是sleep，另外有一个线程在循环里一直跑着，可以想象这个线程是这个进程里最耗cpu的线程了，那怎么把这个线程给抓出来呢？</p>

<p>首先我们可以通过<code>top -Hp &lt;pid&gt;</code>来看这个进程里所有线程的cpu消耗情况，得到类似下面的数据</p>

<p>```
$ top -Hp 18207
top - 19:11:43 up 573 days,  2:43,  2 users,  load average: 3.03, 3.03, 3.02
Tasks:  44 total,   1 running,  43 sleeping,   0 stopped,   0 zombie
Cpu(s): 18.8%us,  0.0%sy,  0.0%ni, 81.1%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:  99191752k total, 98683576k used,   508176k free,   128248k buffers
Swap:  1999864k total,   191064k used,  1808800k free, 17413760k cached</p>

<p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
18250 admin     20   0 26.1g  28m  10m R 99.9  0.0   0:19.50 java Test
18207 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18208 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.09 java Test
18209 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18210 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18211 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18212 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18213 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18214 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18215 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18216 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18217 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18218 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18219 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18220 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18221 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18222 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18223 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18224 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18225 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18226 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
18227 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
```</p>

<p>拿到这个结果之后，我们可以看到cpu最高的线程是pid为18250的线程，占了99.9%：</p>

<p><code>
 PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
18250 admin     20   0 26.1g  28m  10m R 99.9  0.0   0:19.50 java Test
</code></p>

<p>接着我们可以通过<code>jstack &lt;pid&gt;</code>的输出来看各个线程栈:</p>

<p>```
$ jstack 18207
2016-03-30 19:12:23
Full thread dump OpenJDK 64-Bit Server VM (25.66-b60 mixed mode):</p>

<p>"Attach Listener" #30 daemon prio=9 os_prio=0 tid=0x00007fb90be13000 nid=0x47d7 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE</p>

<p>"DestroyJavaVM" #29 prio=5 os_prio=0 tid=0x00007fb96245b800 nid=0x4720 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE</p>

<p>"Busiest Thread" #28 prio=5 os_prio=0 tid=0x00007fb91498d000 nid=0x474a runnable [0x00007fb9065fe000]
   java.lang.Thread.State: RUNNABLE</p>

<pre><code>at Test$2.run(Test.java:18)
</code></pre>

<p>"Thread-9" #27 prio=5 os_prio=0 tid=0x00007fb91498c800 nid=0x4749 waiting on condition [0x00007fb906bfe000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<pre><code>at java.lang.Thread.sleep(Native Method)
at Test$1.run(Test.java:9)
</code></pre>

<p>"Thread-8" #26 prio=5 os_prio=0 tid=0x00007fb91498b800 nid=0x4748 waiting on condition [0x00007fb906ffe000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<pre><code>at java.lang.Thread.sleep(Native Method)
at Test$1.run(Test.java:9)
</code></pre>

<p>"Thread-7" #25 prio=5 os_prio=0 tid=0x00007fb91498b000 nid=0x4747 waiting on condition [0x00007fb9073fe000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<pre><code>at java.lang.Thread.sleep(Native Method)
at Test$1.run(Test.java:9)
</code></pre>

<p>"Thread-6" #24 prio=5 os_prio=0 tid=0x00007fb91498a000 nid=0x4746 waiting on condition [0x00007fb9077fe000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)</p>

<pre><code>at java.lang.Thread.sleep(Native Method)
at Test$1.run(Test.java:9)
</code></pre>

<p>...
```</p>

<p>上面的线程栈我们注意到nid的值其实就是线程ID，它是十六进制的，我们将消耗cpu最高的线程<code>18250</code>，转成十六进制<code>0x474a</code>，然后从上面的线程栈里找到<code>nid=0x474a</code>的线程，其栈为：</p>

<p>```</p>

<p>"Busiest Thread" #28 prio=5 os_prio=0 tid=0x00007fb91498d000 nid=0x474a runnable [0x00007fb9065fe000]
   java.lang.Thread.State: RUNNABLE</p>

<pre><code>at Test$2.run(Test.java:18)
</code></pre>

<p>```</p>

<p>即将最耗cpu的线程找出来了，是<code>Businest Thread</code></p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之Object.wait/notify(All)完全解读]]></title>
    <link href="http://nijiaben.github.io/blog/2016/03/27/object-wait-notify/"/>
    <updated>2016-03-27T11:31:25+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/03/27/object-wait-notify</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>本文其实一直都想写，因为各种原因一直拖着没写，直到开公众号的第一天，有朋友再次问到这个问题，这次让我静心下来准备写下这篇文章，本文有些东西是我自己的理解，比如为什么JDK一开始要这么设计，初衷是什么，没怎么去找相关资料，所以只能谈谈自己的理解，所以大家看到文章之后可以谈谈自己的看法，对于实现部分我倒觉得说清楚问题不大，code is here，看明白了就知道怎么回事了。</p>

<!--more-->


<p>Object.wait/notify(All)大家都知道主要是协同线程处理的，大家用得也很多，大概逻辑和下面的用法差不多</p>

<p>```</p>

<pre><code>    new Thread(){
        public void run(){
            synchronized (lock){
                try{
                    lock.wait();
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
        }
    }.start();

    new Thread(){
        public void run(){
            synchronized (lock){
                lock.notify();
            }
        }
    }.start();
</code></pre>

<p>```</p>

<p>看到上面代码，你会有什么疑惑吗？至少我会有几个问题会问自己：</p>

<ul>
<li>为什么进入wait和notify的时候要加synchronized锁</li>
<li>既然加了synchronized锁，那当某个线程调用了wait的时候明明还在synchronized块里，其他线程怎么进入到锁里去执行notify的</li>
<li>为什么wait方法可能会抛出InterruptedException异常</li>
<li>如果有多个线程都进入wait状态，那某个线程调用notify唤醒线程时是否按照顺序唤起那些wait线程</li>
<li>wait的线程是在某个线程执行完notify之后立马就被唤起吗</li>
<li>notifyAll又是怎么实现全唤起的</li>
<li>wait的线程是否会影响load</li>
</ul>


<p>如果上面这些问题也都是你想了解的，那这篇文章或许能给你一个答案。</p>

<h2>为何要加synchronized锁</h2>

<p>从实现上来说，这个锁至关重要，正因为这把锁，才能让整个wait/notify玩转起来，当然我觉得其实通过其他的方式也可以实现类似的机制，不过hotspot至少是完全依赖这把锁来实现wait/notify的。</p>

<p>如果要我们来实现这种机制我们会怎么去做，我们知道wait/notify是为了线程间协作而设计的，当我们执行wait的时候让线程挂起，当执行notify的时候唤醒其中一个挂起的线程，那需要有个地方来保存对象和线程之间的映射关系(可以想象一个map，key是对象，value是一个线程列表)，当调用这个对象的wait方法时，将当前线程放到这个线程列表里，当调用这个对象的notify方法时从这个线程列表里取出一个来让其继续执行，这样看来是可行的，也比较简单，那现在的问题这种映射关系放到哪里。而synchronized正好也是为线程间协作而设计的，上面碰到的问题它也要解决，或许正因为这样wait和notify的实现就直接依赖synchronzied(monitorenter/monitorexit是jvm规范里要求要去实现的)来实现了，这只是我的理解，可能初衷不是这个原因，这其实也是这篇文章迟迟未写的一个原因吧，因为我无法取证自己的理解是对的，欢迎各位在这块谈谈自己的见解。</p>

<h2>wait方法执行后未退出同步块，其他线程如何进入同步块</h2>

<p>这个问题其实要回答很简单，因为在wait处理过程中会临时释放同步锁，不过需要注意的是当某个线程调用notify唤起了这个线程的时候，在wait方法退出之前会重新获取这把锁，只有获取了这把锁才会继续执行，想象一下，我们知道wait的方法是被monitorenter和monitorexit包围起来，当我们在执行wait方法过程中如果释放了锁，出来的时候又不拿锁，那在执行到monitorexit指令的时候会发生什么？当然这可以做兼容，不过这实现起来还是很奇怪的。</p>

<h2>为什么wait方法可能抛出InterruptedException异常</h2>

<p>这个异常大家应该都知道，当我们调用了某个线程的interrupt方法时，对应的线程会抛出这个异常，wait方法也不希望破坏这种规则，因此就算当前线程因为wait一直在阻塞，当某个线程希望它起来继续执行的时候，它还是得从阻塞态恢复过来，因此wait方法被唤醒起来的时候会去检测这个状态，当有线程interrupt了它的时候，它就会抛出这个异常从阻塞状态恢复过来。</p>

<p>这里有两点要注意：</p>

<ul>
<li>如果被interrupt的线程只是创建了，并没有start，那等他start之后进入wait态之后也是不能会恢复的</li>
<li>如果被interrupt的线程已经start了，在进入wait之前，如果有线程调用了其interrupt方法，那这个wait等于什么都没做，会直接跳出来，不会阻塞</li>
</ul>


<h2>被notify(All)的线程有规律吗</h2>

<p>这里要分情况：</p>

<ul>
<li>如果是通过notify来唤起的线程，那先进入wait的线程会先被唤起来</li>
<li>如果是通过nootifyAll唤起的线程，默认情况是最后进入的会先被唤起来，即LIFO的策略</li>
</ul>


<h2>notify执行之后立马唤醒线程吗</h2>

<p>其实这个大家可以验证一下，在notify之后写一些逻辑，看这些逻辑是在其他线程被唤起之前还是之后执行，这个是个细节问题，可能大家并没有关注到这个，其实hotspot里真正的实现是退出同步块的时候才会去真正唤醒对应的线程，不过这个也是个默认策略，也可以改的，在notify之后立马唤醒相关线程。</p>

<h2>notifyAll是怎么实现全唤起的</h2>

<p>或许大家立马想到这个简单，一个for循环就搞定了，不过在jvm里没实现这么简单，而是借助了monitorexit，上面我提到了当某个线程从wait状态恢复出来的时候，要先获取锁，然后再退出同步块，所以notifyAll的实现是调用notify的线程在退出其同步块的时候唤醒起最后一个进入wait状态的线程，然后这个线程退出同步块的时候继续唤醒其倒数第二个进入wait状态的线程，依次类推，同样这这是一个策略的问题，jvm里提供了挨个直接唤醒线程的参数，不过都很罕见就不提了。</p>

<h2>wait的线程是否会影响load</h2>

<p>这个或许是大家比较关心的话题，因为关乎系统性能问题，wait/nofity是通过jvm里的park/unpark机制来实现的，在linux下这种机制又是通过pthread_cond_wait/pthread_cond_signal来玩的，因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。</p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM源码分析之自定义类加载器如何拉长YGC]]></title>
    <link href="http://nijiaben.github.io/blog/2016/03/15/ygc-classloader/"/>
    <updated>2016-03-15T13:51:58+08:00</updated>
    <id>http://nijiaben.github.io/blog/2016/03/15/ygc-classloader</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>本文重点讲述毕玄大师在其公众号上发的一个GC问题<a href="http://hellojava.info/?p=438">一个jstack/jmap等不能用的case</a>（PS：话说毕大师超级喜欢在题目里用case这个词，我觉得题目还是能尽量做到顾名思义好，不然要找起相关文章来真的好难找），对于毕大师那篇文章，题目上没有提到GC的那个问题，不过进入到文章里可以看到，既然文章提到了jstack/jmap的问题，这里也简单回答下jstack/jmap无法使用的问题，其实最常见的场景是使用jstack/jmap的用户和目标进程不是同一个用户，哪怕你执行jstack/jmap的动作是root用户也无济于事，详情可以参考我的这篇文章，<a href="http://lovestblog.cn/blog/2014/06/18/jvm-attach/">JVM Attach机制实现</a>,主要是讲JVM Attach机制的，不过毕大师这里主要提到的是jmap -heap/histo这两个参数带来的问题，如果使用-heap/histo的参数，其实和大家使用-F参数是一样的，底层都是通过serviceability agent来实现的，并不是jvm attach的方式，通过sa连上去之后会挂起进程，在serviceability agent里存在bug可能导致detach的动作不会被执行，从而会让进程一直挂着，可以通过top命令验证进程是否处于T状态，如果是说明进程被挂起了，如果进程被挂起了，可以通过kill -CONT [pid]来恢复。</p>

<!--more-->


<p>再回到那个GC的问题，用的参数如下：</p>

<p><code>
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms512m -Xmx512m -Xmn100m -XX:+UseConcMarkSweepGC
</code></p>

<p>demo程序如下：</p>

<p>```
import com.thoughtworks.xstream.XStream;</p>

<p>public class XStreamTest {</p>

<pre><code>public static void main(String[] args) throws Exception {
    while(true){
        XStream xs = new XStream();
        xs.toString();
        xs = null;
    }
}
</code></pre>

<p>}
```</p>

<p>执行效果如下</p>

<p><code>
2016-03-14T22:48:01.502+0800: [GC [ParNew: 327680K-&gt;4258K(368640K), 0.0179071 secs] 327680K-&gt;4258K(1007616K), 0.0179448 secs] [Times: user=0.06 sys=0.01, real=0.01 secs]
2016-03-14T22:48:05.975+0800: [GC [ParNew: 331938K-&gt;10239K(368640K), 0.0336279 secs] 331938K-&gt;10239K(1007616K), 0.0336593 secs] [Times: user=0.13 sys=0.02, real=0.03 secs]
2016-03-14T22:48:12.215+0800: [GC [ParNew: 337919K-&gt;14444K(368640K), 0.0471005 secs] 337919K-&gt;14444K(1007616K), 0.0471257 secs] [Times: user=0.19 sys=0.02, real=0.05 secs]
2016-03-14T22:48:21.768+0800: [GC [ParNew: 342124K-&gt;19088K(368640K), 0.0605017 secs] 342124K-&gt;19088K(1007616K), 0.0605295 secs] [Times: user=0.26 sys=0.03, real=0.06 secs]
2016-03-14T22:48:35.180+0800: [GC [ParNew: 346768K-&gt;20633K(368640K), 0.0993470 secs] 346768K-&gt;25248K(1007616K), 0.0993777 secs] [Times: user=0.34 sys=0.04, real=0.09 secs]
</code></p>

<p>发现gc的时间越来越长，但是gc触发的时机以及回收的效果都差不多，那问题究竟在哪里呢？</p>

<h2>Demo分析</h2>

<p>虽然这个demo代码逻辑很简单，但是其实这是一个特殊的demo，并不简单，如果我们将XStream对象换成Object对象，会发现不存在这个问题，既然如此那有必要进去看看这个XStream的构造函数：</p>

<p>```
 public XStream() {</p>

<pre><code>    this((ReflectionProvider)null, (Mapper)((Mapper)null), (HierarchicalStreamDriver)(new XppDriver()));
}

/** @deprecated */
public XStream(ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {
    this(reflectionProvider, driver, (ClassLoader)(new CompositeClassLoader()), mapper);
}

/** @deprecated */
public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader, Mapper mapper) {
    this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());
}

public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader, Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {
    this(reflectionProvider, driver, (ClassLoaderReference)classLoader, mapper, new ConverterLookup() {
        public Converter lookupConverterForType(Class type) {
            return defaultConverterLookup.lookupConverterForType(type);
        }
    }, new ConverterRegistry() {
        public void registerConverter(Converter converter, int priority) {
            defaultConverterLookup.registerConverter(converter, priority);
        }
    });
}

/** @deprecated */
public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader, Mapper mapper, ConverterLookup converterLookup, ConverterRegistry converterRegistry) {
    this(reflectionProvider, driver, (ClassLoaderReference)(new ClassLoaderReference(classLoader)), mapper, converterLookup, converterRegistry);
}

public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup, ConverterRegistry converterRegistry) {
    if(reflectionProvider == null) {
        reflectionProvider = JVM.newReflectionProvider();
    }

    this.reflectionProvider = reflectionProvider;
    this.hierarchicalStreamDriver = driver;
    this.classLoaderReference = classLoaderReference;
    this.converterLookup = converterLookup;
    this.converterRegistry = converterRegistry;
    this.mapper = mapper == null?this.buildMapper():mapper;
    this.setupMappers();
    this.setupSecurity();
    this.setupAliases();
    this.setupDefaultImplementations();
    this.setupConverters();
    this.setupImmutableTypes();
    this.setMode(1003);
}
</code></pre>

<p>```</p>

<p>这个构造函数还是很复杂的，里面会创建很多的对象，上面还有一些方法实现我就不贴了，总之都是在不断构建各种大大小小的对象，一个XStream对象构建出来的时候大概好像有12M的样子。</p>

<p>那到底是哪些对象会导致ygc不断增长呢，于是可能想到逐步替换上面这些逻辑，比如将最后一个构造函数里的那些逻辑都禁掉，然后我们再跑测试看看还会不会让ygc不断恶化，最终我们会发现，如果我们直接使用如下构造函数构造对象时，如果传入的classloader是AppClassLoader，那会发现这个问题不再出现了。</p>

<p>```
 public XStream(ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoader classLoader, Mapper mapper) {</p>

<pre><code>    this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());
</code></pre>

<p> }
```</p>

<p>测试代码如下：</p>

<p>```    <br/>
 public static void main(String[] args) throws Exception {</p>

<pre><code>    int i=0;
    while (true) {
        XStream xs = new XStream(null,null, new ClassLoaderReference(XStreamTest.class.getClassLoader()),null, new DefaultConverterLookup());
        xs.toString();
        xs=null;
    }
</code></pre>

<p>  }
```</p>

<p>gc日志如下：</p>

<p><code>
2016-03-14T23:10:33.537+0800: [GC [ParNew: 327680K-&gt;758K(368640K), 0.0019803 secs] 327680K-&gt;758K(1007616K), 0.0020182 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2016-03-14T23:10:35.189+0800: [GC [ParNew: 328438K-&gt;1066K(368640K), 0.0018641 secs] 328438K-&gt;1066K(1007616K), 0.0019055 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
2016-03-14T23:10:36.465+0800: [GC [ParNew: 328746K-&gt;1156K(368640K), 0.0010304 secs] 328746K-&gt;1156K(1007616K), 0.0010519 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2016-03-14T23:10:37.767+0800: [GC [ParNew: 328836K-&gt;1065K(368640K), 0.0011329 secs] 328836K-&gt;1065K(1007616K), 0.0011543 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2016-03-14T23:10:39.035+0800: [GC [ParNew: 328745K-&gt;351K(368640K), 0.0043387 secs] 328745K-&gt;1127K(1007616K), 0.0043700 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
2016-03-14T23:10:40.324+0800: [GC [ParNew: 328031K-&gt;160K(368640K), 0.0011579 secs] 328807K-&gt;936K(1007616K), 0.0011793 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
2016-03-14T23:10:41.610+0800: [GC [ParNew: 327840K-&gt;31K(368640K), 0.0007010 secs] 328616K-&gt;826K(1007616K), 0.0007219 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2016-03-14T23:10:42.919+0800: [GC [ParNew: 327711K-&gt;24K(368640K), 0.0011246 secs] 328506K-&gt;819K(1007616K), 0.0011450 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
2016-03-14T23:10:44.196+0800: [GC [ParNew: 327704K-&gt;24K(368640K), 0.0006797 secs] 328499K-&gt;819K(1007616K), 0.0007586 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</code></p>

<p>是不是觉得很神奇，由此可见，这个classloader至关重要。</p>

<h2>不得不说的类加载器</h2>

<p>这里着重要说的两个概念是<code>初始类加载器</code>和<code>定义类加载器</code>。举个栗子说吧，AClassLoader->BClassLoader->CClassLoader，表示AClassLoader在加载类的时候会委托BClassLoader类加载器来加载，BClassLoader加载类的时候会委托CClassLoader来加载，假如我们使用AClassLoader来加载X这个类，而X这个类最终是被CClassLoader来加载的，那么我们称CClassLoader为X类的定义类加载器，而AClassLoader为X类的初始类加载器，JVM在加载某个类的时候对AClassLoader和CClassLoader进行记录，记录的数据结构是一个叫做SystemDictionary的hashtable，其key是根据ClassLoader对象和类名算出来的hash值（其实是一个entry，可以根据这个hash值找到具体的index位置，然后构建一个包含kalssName和classloader对象的entry放到map里），而value是真正的由定义类加载器加载的Klass对象，因为初始类加载器和定义类加载器是不同的classloader，因此算出来的hash值也是不同的，因此在SystemDictionary里会有多项值的value都是指向同一个Klass对象。</p>

<p>那么JVM为什么要分这两种类加载器呢，其实主要是为了快速找到已经加载的类，比如我们已经通过AClassLoader来触发了对X类的加载，当我们再次使用AClassLoader这个类加载器来加载X这个类的时候就不需要再委托给BClassLoader去找了，因为加载过的类在JVM里有这个类加载器的直接加载的记录，只需要直接返回对应的Klass对象即可。</p>

<h2>Demo中的类加载器是否会加载类</h2>

<p>我们的demo里发现构建了一个CompositeClassLoader的类加载器，那到底有没有用这个类加载器加载类呢，我们可以设置一个断点在CompositeClassLoader的loadClass方法上，于是看到下面的堆栈：</p>

<p>```
main@1, prio=5, in group 'main', status: 'RUNNING'</p>

<pre><code>  at com.thoughtworks.xstream.core.util.CompositeClassLoader.loadClass(CompositeClassLoader.java:53)
  at java.lang.Class.forName0(Class.java:-1)
  at java.lang.Class.forName(Class.java:249)
  at com.thoughtworks.xstream.XStream.buildMapperDynamically(XStream.java:191)
  at com.thoughtworks.xstream.XStream.buildMapper(XStream.java:170)
  at com.thoughtworks.xstream.XStream.&lt;init&gt;(XStream.java:142)
  at com.thoughtworks.xstream.XStream.&lt;init&gt;(XStream.java:116)
  at com.BBBB.main(BBBB.java:15)
</code></pre>

<p>```</p>

<p>可见确实有类加载的动作，根据类加载委托机制，在这个demo中我们能肯定类是交给AppClassLoader来加载的，这样一来CompositeClassLoader就变成了初始类加载器，而AppClassLoader会是定义类加载器，都会在SystemDictionary里存在，因此当我们不断new XStream的时候会不断new CompositeClassLoader对象，加载类的时候会不断往SystemDictionary里插入记录，从而使SystemDictionary越来越膨胀，那自然而然会想到如果GC过程不断去扫描这个SystemDictionary的话，那随着SystemDictionary不断膨胀，那么GC的效率也就越低，抱着验证下猜想的方式我们可以使用perf工具来看看，如果发现cpu占比排前的函数如果都是操作SystemDictionary的，那就基本验证了我们的说法，下面是perf工具的截图，基本证实了这一点。</p>

<p><img src="/images/2016/03/ygc_classloader_perf.png"></p>

<h2>SystemDictionary为什么会影响GC过程</h2>

<p>想象一下这么个情况，我们加载了一个类，然后构建了一个对象(这个对象在eden里构建)当一个属性设置到这个类里，如果gc发生的时候，这个对象是不是要被找出来标活才行，那么自然而然我们加载的类肯定是我们一项重要的gc root，这样SystemDictionary就成为了gc过程中的被扫描对象了，事实也是如此，可以看vm的具体代码：</p>

<p>```
void SharedHeap::process_strong_roots(bool activate_scope,</p>

<pre><code>                                  bool collecting_perm_gen,
                                  ScanningOption so,
                                  OopClosure* roots,
                                  CodeBlobClosure* code_roots,
                                  OopsInGenClosure* perm_blk) {
</code></pre>

<p>  StrongRootsScope srs(this, activate_scope);
  // General strong roots.
  assert(<em>strong_roots_parity != 0, "must have called prologue code");
  // </em>n_termination for <em>process_strong_tasks should be set up stream
  // in a method not running in a GC worker.  Otherwise the GC worker
  // could be trying to change the termination condition while the task
  // is executing in another GC worker.
  if (!</em>process_strong_tasks->is_task_claimed(SH_PS_Universe_oops_do)) {</p>

<pre><code>Universe::oops_do(roots);
// Consider perm-gen discovered lists to be strong.
//将perm gen的非强引用标记为root的一部分
perm_gen()-&gt;ref_processor()-&gt;weak_oops_do(roots);
</code></pre>

<p>  }
  // Global (strong) JNI handles
  if (!_process_strong_tasks->is_task_claimed(SH_PS_JNIHandles_oops_do))</p>

<pre><code>JNIHandles::oops_do(roots);
</code></pre>

<p>  // All threads execute this; the individual threads are task groups.
  if (ParallelGCThreads > 0) {</p>

<pre><code>Threads::possibly_parallel_oops_do(roots, code_roots);
</code></pre>

<p>  } else {</p>

<pre><code>Threads::oops_do(roots, code_roots);
</code></pre>

<p>  }
  if (!_process_strong_tasks-> is_task_claimed(SH_PS_ObjectSynchronizer_oops_do))</p>

<pre><code>ObjectSynchronizer::oops_do(roots);
</code></pre>

<p>  if (!_process_strong_tasks->is_task_claimed(SH_PS_FlatProfiler_oops_do))</p>

<pre><code>FlatProfiler::oops_do(roots);
</code></pre>

<p>  if (!_process_strong_tasks->is_task_claimed(SH_PS_Management_oops_do))</p>

<pre><code>Management::oops_do(roots);
</code></pre>

<p>  if (!_process_strong_tasks->is_task_claimed(SH_PS_jvmti_oops_do))</p>

<pre><code>JvmtiExport::oops_do(roots);
</code></pre>

<p>  if (!_process_strong_tasks->is_task_claimed(SH_PS_SystemDictionary_oops_do)) {</p>

<pre><code>if (so &amp; SO_AllClasses) {
  SystemDictionary::oops_do(roots);
} else if (so &amp; SO_SystemClasses) {
  SystemDictionary::always_strong_oops_do(roots);
}
</code></pre>

<p>  }</p>

<p>  if (!_process_strong_tasks->is_task_claimed(SH_PS_StringTable_oops_do)) {</p>

<pre><code>//JavaObjectsInPerm为false，那么String intern的对象已经class对象都是存在heap里的，否则都存在perm里  
if (so &amp; SO_Strings || (!collecting_perm_gen &amp;&amp; !JavaObjectsInPerm)) {
  //虽然不回收perm，但是interned的String对象不在perm里，那么还是需要遍历下StringTable里的String对象，因为这些对象在heap里
  StringTable::oops_do(roots);
}
if (JavaObjectsInPerm) {
  // Verify the string table contents are in the perm gen
  NOT_PRODUCT(StringTable::oops_do(&amp;assert_is_perm_closure));
}
</code></pre>

<p>  }</p>

<p>  if (!_process_strong_tasks->is_task_claimed(SH_PS_CodeCache_oops_do)) {</p>

<pre><code>if (so &amp; SO_CodeCache) {
  // (Currently, CMSCollector uses this to do intermediate-strength collections.)
  assert(collecting_perm_gen, "scanning all of code cache");
  assert(code_roots != NULL, "must supply closure for code cache");
  if (code_roots != NULL) {
    CodeCache::blobs_do(code_roots);
  }
} else if (so &amp; (SO_SystemClasses|SO_AllClasses)) {
  if (!collecting_perm_gen) {
    // If we are collecting from class statics, but we are not going to
    // visit all of the CodeCache, collect from the non-perm roots if any.
    // This makes the code cache function temporarily as a source of strong
    // roots for oops, until the next major collection.
    //
    // If collecting_perm_gen is true, we require that this phase will call
    // CodeCache::do_unloading.  This will kill off nmethods with expired
    // weak references, such as stale invokedynamic targets.
    CodeCache::scavenge_root_nmethods_do(code_roots);
  }
}
// Verify that the code cache contents are not subject to
// movement by a scavenging collection.
DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&amp;assert_is_non_scavengable_closure, /*do_marking=*/ false));
DEBUG_ONLY(CodeCache::asserted_non_scavengable_nmethods_do(&amp;assert_code_is_non_scavengable));
</code></pre>

<p>  }</p>

<p>  if (!collecting_perm_gen) {</p>

<pre><code>//如果是不回收perm，那找出所有perm指向new的对象  
// All threads perform this; coordination is handled internally.
rem_set()-&gt;younger_refs_iterate(perm_gen(), perm_blk);//perm的level是-1
</code></pre>

<p>  }
  _process_strong_tasks->all_tasks_completed();
}</p>

<p>```</p>

<p>看上面的<code>SH_PS_SystemDictionary_oops_do</code> task就知道了，这个就是对SystemDictionary进行扫描。</p>

<p>但是这里要说的是虽然有对SystemDictionary进行扫描，但是ygc的过程并不会对SystemDictionary进行处理，如果要对它进行处理需要开启类卸载的vm参数，CMS算法下，CMS GC和Full GC在开启CMSClassUnloadingEnabled的情况下是可能对类做卸载动作的，此时会对SystemDictionary进行清理，所以当我们在跑上面demo的时候，通过<code>jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</code>命令执行完之后，ygc的时间瞬间降下来了，不过又会慢慢回去，这是因为jmap的这个命令会做一次gc，这个gc过程会对SystemDictionary进行清理。</p>

<h2>修改VM代码验证</h2>

<p>很遗憾hotspot目前没有对ygc的每个task做一个时间的统计，因此无法直接知道是不是<code>SH_PS_SystemDictionary_oops_do</code>这个task导致了ygc的时间变长，为了证明这个结论，我特地修改了一下代码，在上面的代码上加了一行：</p>

<p>```
if (!_process_strong_tasks->is_task_claimed(SH_PS_SystemDictionary_oops_do)) {</p>

<pre><code>GCTraceTime t("SystemDictionary_OOPS_DO",PrintGCDetails,true,NULL);
if (so &amp; SO_AllClasses) {
  SystemDictionary::oops_do(roots);
} else if (so &amp; SO_SystemClasses) {
  SystemDictionary::always_strong_oops_do(roots);
}
</code></pre>

<p>  }
```</p>

<p>然后重新编译，跑我们的demo，测试结果如下：</p>

<p><code>
2016-03-14T23:57:24.293+0800: [GC2016-03-14T23:57:24.294+0800: [ParNew2016-03-14T23:57:24.296+0800: [SystemDictionary_OOPS_DO, 0.0578430 secs]
: 81920K-&gt;3184K(92160K), 0.0889740 secs] 81920K-&gt;3184K(514048K), 0.0900970 secs] [Times: user=0.27 sys=0.00, real=0.09 secs]
2016-03-14T23:57:28.467+0800: [GC2016-03-14T23:57:28.468+0800: [ParNew2016-03-14T23:57:28.468+0800: [SystemDictionary_OOPS_DO, 0.0779210 secs]
: 85104K-&gt;5175K(92160K), 0.1071520 secs] 85104K-&gt;5175K(514048K), 0.1080490 secs] [Times: user=0.65 sys=0.00, real=0.11 secs]
2016-03-14T23:57:32.984+0800: [GC2016-03-14T23:57:32.984+0800: [ParNew2016-03-14T23:57:32.984+0800: [SystemDictionary_OOPS_DO, 0.1075680 secs]
: 87095K-&gt;8188K(92160K), 0.1434270 secs] 87095K-&gt;8188K(514048K), 0.1439870 secs] [Times: user=0.90 sys=0.01, real=0.14 secs]
2016-03-14T23:57:37.900+0800: [GC2016-03-14T23:57:37.900+0800: [ParNew2016-03-14T23:57:37.901+0800: [SystemDictionary_OOPS_DO, 0.1745390 secs]
: 90108K-&gt;7093K(92160K), 0.2876260 secs] 90108K-&gt;9992K(514048K), 0.2884150 secs] [Times: user=1.44 sys=0.02, real=0.29 secs]
</code>
我们会发现YGC的时间变长的时候，SystemDictionary_OOPS_DO的时间也会相应变长多少，因此验证了我们的说法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消失的死锁]]></title>
    <link href="http://nijiaben.github.io/blog/2015/10/21/deadlock/"/>
    <updated>2015-10-21T18:54:01+08:00</updated>
    <id>http://nijiaben.github.io/blog/2015/10/21/deadlock</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>如果java层面发生了死锁，当我们使用<code>jstack</code>命令的时候其实是可以将死锁的信息给dump出来的，在dump结果的最后会有类似<code>Found one Java-level deadlock:</code>的关键字，接着会把发生死锁的线程的堆栈及对应的同步锁给打印出来，这次碰到一个系统就发生类似的问题，不过这个dump文档里虽然提到了如下的死锁信息：</p>

<!--more-->


<p>```</p>

<h1>Found one Java-level deadlock:</h1>

<p>"worker-1-thread-121":
  waiting to lock monitor 0x00007f3758209dc8 (object 0x0000000764cd2b20, a java.util.concurrent.ConcurrentHashMap),
  which is held by "HSFBizProcessor-4-thread-4"
"HSFBizProcessor-4-thread-4":
  waiting to lock monitor 0x00007f3758289260 (object 0x000000076073ddc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
  which is held by "HSFBizProcessor-4-thread-5"
"HSFBizProcessor-4-thread-5":
  waiting to lock monitor 0x00007f3758253420 (object 0x00000007608e6fc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
  which is held by "HSFBizProcessor-4-thread-4"
```</p>

<p>但是我们在堆栈里搜索对应的锁的时候并没发现，也就是上面提到的</p>

<p><code>
object 0x00000007608e6fc8 which is held by "HSFBizProcessor-4-thread-4"
</code></p>

<p>我们在<code>HSFBizProcessor-4-thread-4</code>这个线程的堆栈里并没有看到对应的持锁信息。</p>

<p>附上线程dump详情</p>

<p>```</p>

<h1>Found one Java-level deadlock:</h1>

<p>"worker-1-thread-121":
  waiting to lock monitor 0x00007f3758209dc8 (object 0x0000000764cd2b20, a java.util.concurrent.ConcurrentHashMap),
  which is held by "HSFBizProcessor-4-thread-4"
"HSFBizProcessor-4-thread-4":
  waiting to lock monitor 0x00007f3758289260 (object 0x000000076073ddc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
  which is held by "HSFBizProcessor-4-thread-5"
"HSFBizProcessor-4-thread-5":
  waiting to lock monitor 0x00007f3758253420 (object 0x00000007608e6fc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader),
  which is held by "HSFBizProcessor-4-thread-4"</p>

<h1>Java stack information for the threads listed above:</h1>

<p>"worker-1-thread-121":</p>

<pre><code>at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:180)
- waiting to lock &lt;0x0000000764cd2b20&gt; (a java.util.concurrent.ConcurrentHashMap)
at org.springframework.beans.factory.support.AbstractBeanFactory.isTypeMatch(AbstractBeanFactory.java:455)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:317)
......
at java.util.concurrent.FutureTask.run(FutureTask.java:138)
at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
at java.lang.Thread.run(Thread.java:662)
</code></pre>

<p>"HSFBizProcessor-4-thread-4":</p>

<pre><code>at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
- waiting to lock &lt;0x000000076073ddc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.SingleSourcePackage.loadClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
at org.springframework.scripting.groovy.GroovyScriptFactory.executeScript(GroovyScriptFactory.java:238)
......
at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
at java.lang.Thread.run(Thread.java:662)
</code></pre>

<p>"HSFBizProcessor-4-thread-5":</p>

<pre><code>at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
- waiting to lock &lt;0x00000007608e6fc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.buddy.DependentPolicy.loadClass(Unknown Source)
at org.eclipse.osgi.internal.loader.buddy.PolicyHandler.doBuddyClassLoading(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:169)
at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:127)
at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:122)
......
at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
at java.lang.Thread.run(Thread.java:662)
</code></pre>

<p>Found 1 deadlock.
```</p>

<h2>类加载的问题？</h2>

<p>首先应该怀疑类加载的问题，因为我们看到导致死锁的对象是一个classloader对象：</p>

<p><code>
waiting to lock monitor 0x00007f3758289260 (object 0x000000076073ddc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
</code></p>

<p>然后我们再来分析下堆栈</p>

<h3>HSFBizProcessor-4-thread-4</h3>

<p>```
"HSFBizProcessor-4-thread-4":</p>

<pre><code>at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
- waiting to lock &lt;0x000000076073ddc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.SingleSourcePackage.loadClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
at org.springframework.scripting.groovy.GroovyScriptFactory.executeScript(GroovyScriptFactory.java:238)
at org.springframework.scripting.groovy.GroovyScriptFactory.getScriptedObject(GroovyScriptFactory.java:185)
</code></pre>

<p>```</p>

<p>我这里只把关键的线程栈贴出来，从栈顶知道正在等一把锁：</p>

<p>```</p>

<pre><code>- waiting to lock &lt;0x000000076073ddc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
</code></pre>

<p>```</p>

<p>这把锁的对象是一个ClassLoader对象，我们找到对应的代码，确实存在synchronized的操作：</p>

<p>```
private Class&lt;?> findLoadedClass(String classname) {</p>

<pre><code>if ((LOCK_CLASSNAME) || (this.isParallelClassLoader)) {
  boolean initialLock = lockClassName(classname);
  try {
    return this.classloader.publicFindLoaded(classname);
  } finally {
    if (initialLock)
      unlockClassName(classname);
  }
}
synchronized (this.classloader) {
  return this.classloader.publicFindLoaded(classname);
}
</code></pre>

<p>  }</p>

<p>```</p>

<p>另外我们还知道它正在执行loadClass的动作，并且是从groovy调用来的，同样找到对应的代码：</p>

<p>```
protected Object executeScript(ScriptSource scriptSource, Class scriptClass)</p>

<pre><code>throws ScriptCompilationException
</code></pre>

<p>  {</p>

<pre><code>try
{
  GroovyObject goo = (GroovyObject)scriptClass.newInstance();//line 238

  if (this.groovyObjectCustomizer != null)
  {
    this.groovyObjectCustomizer.customize(goo);
  }

  if ((goo instanceof Script))
  {
    return ((Script)goo).run();
  }

  return goo;
}
catch (InstantiationException ex)
{
  throw new ScriptCompilationException(
    scriptSource, "Could not instantiate Groovy script class: " + scriptClass.getName(), ex);
}
catch (IllegalAccessException ex) {
  throw new ScriptCompilationException(
    scriptSource, "Could not access Groovy script constructor: " + scriptClass.getName(), ex);
}
</code></pre>

<p>  }
```</p>

<p>执行到第238行的时候</p>

<p><code>
GroovyObject goo = (GroovyObject)scriptClass.newInstance();//line 238
</code></p>

<p>突然发现调用了</p>

<p><code>
java.lang.ClassLoader.loadClass(ClassLoader.java:247)
</code></p>

<p>而我们看到上面第238行的逻辑其实就是实例化一个对象，然后进行强转，我们看看对应的字节码：</p>

<p><code>
 0: aload_2
 1: invokevirtual #164                // Method java/lang/Class.newInstance:()Ljava/lang/Object;
 4: checkcast     #168                // class groovy/lang/GroovyObject
 7: astore_3
</code></p>

<p>其实就对应这么几条字节码指令，其实在jvm里当我们执行checkcast指令的时候会触发类加载的动作：</p>

<p>```
void TemplateTable::checkcast() {</p>

<pre><code>...
call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
...
</code></pre>

<p>}</p>

<p>IRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))
  // Force resolving; quicken the bytecode
  int which = get_index_u2(thread, Bytecodes::_checkcast);
  constantPoolOop cpool = method(thread)->constants();
  // We'd expect to assert that we're only here to quicken bytecodes, but in a multithreaded
  // program we might have seen an unquick'd bytecode in the interpreter but have another
  // thread quicken the bytecode before we get here.
  // assert( cpool->tag_at(which).is_unresolved_klass(), "should only come here to quicken bytecodes" );
  klassOop klass = cpool->klass_at(which, CHECK);
  thread->set_vm_result(klass);
IRT_END</p>

<p>klassOop klass_at(int which, TRAPS) {</p>

<pre><code>constantPoolHandle h_this(THREAD, this);
return klass_at_impl(h_this, which, CHECK_NULL);
</code></pre>

<p>}</p>

<p>klassOop constantPoolOopDesc::klass_at_impl(constantPoolHandle this_oop, int which, TRAPS) {</p>

<pre><code>...
klassOop k_oop = SystemDictionary::resolve_or_fail(name, loader, h_prot, true, THREAD);
...
</code></pre>

<p>}</p>

<p>//SystemDictionary::resolve_or_fail最终会调用到下面这个方法
klassOop SystemDictionary::resolve_instance_class_or_null(Symbol* name, Handle class_loader, Handle protection_domain, TRAPS) {
  ...
  // Class is not in SystemDictionary so we have to do loading.
  // Make sure we are synchronized on the class loader before we proceed
  Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
  check_loader_lock_contention(lockObject, THREAD);
  ObjectLocker ol(lockObject, THREAD, DoObjectLock);
  ...
  //此时会调用ClassLoader.loadClass来加载类了
  ...
}</p>

<p>Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
  // If class_loader is NULL we synchronize on _system_loader_lock_obj
  if (class_loader.is_null()) {</p>

<pre><code>return Handle(THREAD, _system_loader_lock_obj);
</code></pre>

<p>  } else {</p>

<pre><code>return class_loader;
</code></pre>

<p>  }
}
```</p>

<p><code>SystemDictionary::resolve_instance_class_or_null</code>这个方法非常关键了，在里面我们看到会获取一把锁ObjectLocker，其相当于我们java代码里的<code>synchronized</code>关键字，而对象对应的是lockObject，这个对象是上面的<code>SystemDictionary::compute_loader_lock_object</code>方法返回的，从代码可知只要不是bootstrapClassloader加载的类就会返回当前classloader对象，也就是说当我们在加载一个类的时候其实是会持有当前类加载对象的锁的，在获取了这把锁之后就会调用ClassLoader.loadClass来加载类了。这其实就解释了<code>HSFBizProcessor-4-thread-4</code>这个线程为什么持有了
<code>
object 0x00000007608e6fc8, a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader
</code>
这个类加载的锁，不过遗憾的是因为这把锁不是java层面来显示加载的，因此我们在<code>jstack</code>线程dump的输出里居然看不到这把锁的存在.</p>

<h3>HSFBizProcessor-4-thread-5</h3>

<p>先上堆栈：</p>

<p>```
"HSFBizProcessor-4-thread-5":</p>

<pre><code>at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLoadedClass(Unknown Source)
- waiting to lock &lt;0x00000007608e6fc8&gt; (a com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader)
at org.eclipse.osgi.baseadaptor.loader.ClasspathManager.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.buddy.DependentPolicy.loadClass(Unknown Source)
at org.eclipse.osgi.internal.loader.buddy.PolicyHandler.doBuddyClassLoading(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.loader.BundleLoader.findClass(Unknown Source)
at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(Unknown Source)
at com.alipay.cloudengine.extensions.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:121)
at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:169)
</code></pre>

<p>```</p>

<p>这个线程栈其实和之前那个线程差不多，只是等的锁不一样，另外触发类加载的动作是<code>Class.forName</code>，获取大家也猜到了，其实是在下面两行堆栈之间同样获取了一把类加载器的锁</p>

<p>```</p>

<pre><code>at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
at java.lang.Class.forName0(Native Method)
</code></pre>

<p>```</p>

<p>这里的代码我也不细贴了，最终调用的jvm里的方法都是一样的，获取锁的逻辑也是一样的</p>

<h2>总结</h2>

<p>想象下这种场景，两个线程分别使用不同的classloader对两个类进行类加载，然而由于osgi类加载机制的缘故，在loadClass过程中可能会委托给别的classloader去加载，而正巧，这两个线程在获取当前classloader的锁之后，然后分别委托对方的classloader去加载，可以看到文章开头列的那个findLoadedClass方法，而synchronized的那个classloader正好是对方的classloader，从而导致了死锁</p>
]]></content>
  </entry>
  
</feed>
