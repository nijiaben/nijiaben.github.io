
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>你假笨</title>
  <meta name="author" content="你假笨">

   
  <meta name="description" content="技术宅改变世界">
  
  <meta name="keywords" content="">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://nijiaben.github.io/blog">
  <link href="/favicon.ico" rel="icon">
  <!--
  <link href='http://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>
  -->
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="你假笨" type="application/atom+xml">
  <link href="/js/google-code-prettify/vibrant-ink.css" media="screen, projection" rel="stylesheet" type="text/css"]]>
  <script src="/js/jquery.js"></script>
  <script src="/js/bootstrap-collapse.js"></script>
  <script src="/js/modernizr-2.0.js"></script>
  <script src="/js/octopress.js" type="text/javascript"></script>
  <script src="/js/application.js"></script>
  <script type="text/javascript "src="/js/google-code-prettify/prettify.js"></script>
  <script type="text/javascript"]]>
    	$(function(){     
		 $('pre').addClass('prettyprint').attr('style','overflow:auto');
	         window.prettyPrint && prettyPrint();
                 $('table').addClass('table')});
  </script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52812422-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <div class="navbar navbar-inverse navbar-static-top">
  	<div class="navbar-inner">
  	  <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".navbar-responsive-collapse">
          <span class="fui-menu-24"></span>
        </a>
  	  	<div class="nav-collapse collapse navbar-responsive-collapse" style="height:0;">
  	      <ul class="nav">
    
        <li ><a href="/">博客</a></li>
    
        <li ><a href="/archives/index.html">目录</a></li>
    
        <li ><a href="/comments/latest.html">最新评论</a></li>
    
        <li ><a href="/about/index.html">关于你假笨</a></li>
    
</ul>

<ul class="nav pull-right">
    
    
    
    
    <li><a href="http://weibo.com/nijiaben" title="Sina Weibo Profile"><i class="icon-weibo social-navbar"></i></a></li>
    
    
    
    
    
    
    <li><a href="/atom.xml" title="RSS Feed"><i class="icon-rss-sign social-navbar"></i></a></li>
    

    
</ul>

  	    </div>
  	  </div>
  	</div>
  </div>
  <div class="container" id="main">
      <div class="row-fluid">
        <div id="content">
          


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2016-03-31T18:27:35+08:00" pubdate data-updated="true">Mar 31<span>st</span>, 2016</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2016/03/31/cpu-thread/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/cpu/"><span class="badge">CPU</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2016/03/31/cpu-thread/">如何定位消耗CPU最多的线程</a></h1>
      <p>之前有朋友反馈说发的内容希望有个梯度，逐步加深，前面发了几篇关于jvm源码分析的文章，可能我觉得我已经把内容写得浅显易懂了，但是对于某些没怎么接触的同学来说还是比较难理解，这个我以后慢慢改进吧，今天发篇轻松点的文章，可能大家在工作过程中也会可能碰到类似的问题，或许有经验的同学看到这个题目就知道我要说什么了，也有自己的定位方法。</p>

<p>话不多说了，先来看代码吧</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class Test{
</span><span class='line'>        public static void main(String args[]){
</span><span class='line'>                for(int i=0;i&lt;10;i++){
</span><span class='line'>                        new Thread(){
</span><span class='line'>                                public void run(){
</span><span class='line'>                                        try{
</span><span class='line'>                                                Thread.sleep(100000);
</span><span class='line'>                                        }catch(Exception e){}
</span><span class='line'>                                }
</span><span class='line'>                        }.start();
</span><span class='line'>                }
</span><span class='line'>                Thread t=new Thread(){
</span><span class='line'>                        public void run(){
</span><span class='line'>                                int i=0;
</span><span class='line'>                                while(true){
</span><span class='line'>                                        i=(i++)/100;
</span><span class='line'>                                }
</span><span class='line'>                        }
</span><span class='line'>                };
</span><span class='line'>                t.setName("Busiest Thread");
</span><span class='line'>                t.start();
</span><span class='line'>        }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个例子里新创建了11个线程，其中10个线程没干什么事，主要是sleep，另外有一个线程在循环里一直跑着，可以想象这个线程是这个进程里最耗cpu的线程了，那怎么把这个线程给抓出来呢？</p>

<p>首先我们可以通过<code>top -Hp &lt;pid&gt;</code>来看这个进程里所有线程的cpu消耗情况，得到类似下面的数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ top -Hp 18207
</span><span class='line'>top - 19:11:43 up 573 days,  2:43,  2 users,  load average: 3.03, 3.03, 3.02
</span><span class='line'>Tasks:  44 total,   1 running,  43 sleeping,   0 stopped,   0 zombie
</span><span class='line'>Cpu(s): 18.8%us,  0.0%sy,  0.0%ni, 81.1%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
</span><span class='line'>Mem:  99191752k total, 98683576k used,   508176k free,   128248k buffers
</span><span class='line'>Swap:  1999864k total,   191064k used,  1808800k free, 17413760k cached
</span><span class='line'>
</span><span class='line'>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
</span><span class='line'>18250 admin     20   0 26.1g  28m  10m R 99.9  0.0   0:19.50 java Test
</span><span class='line'>18207 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18208 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.09 java Test
</span><span class='line'>18209 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18210 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18211 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18212 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18213 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18214 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18215 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18216 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18217 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18218 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18219 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18220 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18221 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18222 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18223 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18224 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18225 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18226 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test
</span><span class='line'>18227 admin     20   0 26.1g  28m  10m S  0.0  0.0   0:00.00 java Test</span></code></pre></td></tr></table></div></figure>


<p>拿到这个结果之后，我们可以看到cpu最高的线程是pid为18250的线程，占了99.9%：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
</span><span class='line'>18250 admin     20   0 26.1g  28m  10m R 99.9  0.0   0:19.50 java Test</span></code></pre></td></tr></table></div></figure>


<p>接着我们可以通过<code>jstack &lt;pid&gt;</code>的输出来看各个线程栈:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ jstack 18207
</span><span class='line'>2016-03-30 19:12:23
</span><span class='line'>Full thread dump OpenJDK 64-Bit Server VM (25.66-b60 mixed mode):
</span><span class='line'>
</span><span class='line'>"Attach Listener" #30 daemon prio=9 os_prio=0 tid=0x00007fb90be13000 nid=0x47d7 waiting on condition [0x0000000000000000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>
</span><span class='line'>"DestroyJavaVM" #29 prio=5 os_prio=0 tid=0x00007fb96245b800 nid=0x4720 waiting on condition [0x0000000000000000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>
</span><span class='line'>"Busiest Thread" #28 prio=5 os_prio=0 tid=0x00007fb91498d000 nid=0x474a runnable [0x00007fb9065fe000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>  at Test$2.run(Test.java:18)
</span><span class='line'>
</span><span class='line'>"Thread-9" #27 prio=5 os_prio=0 tid=0x00007fb91498c800 nid=0x4749 waiting on condition [0x00007fb906bfe000]
</span><span class='line'>   java.lang.Thread.State: TIMED_WAITING (sleeping)
</span><span class='line'>  at java.lang.Thread.sleep(Native Method)
</span><span class='line'>  at Test$1.run(Test.java:9)
</span><span class='line'>
</span><span class='line'>"Thread-8" #26 prio=5 os_prio=0 tid=0x00007fb91498b800 nid=0x4748 waiting on condition [0x00007fb906ffe000]
</span><span class='line'>   java.lang.Thread.State: TIMED_WAITING (sleeping)
</span><span class='line'>  at java.lang.Thread.sleep(Native Method)
</span><span class='line'>  at Test$1.run(Test.java:9)
</span><span class='line'>
</span><span class='line'>"Thread-7" #25 prio=5 os_prio=0 tid=0x00007fb91498b000 nid=0x4747 waiting on condition [0x00007fb9073fe000]
</span><span class='line'>   java.lang.Thread.State: TIMED_WAITING (sleeping)
</span><span class='line'>  at java.lang.Thread.sleep(Native Method)
</span><span class='line'>  at Test$1.run(Test.java:9)
</span><span class='line'>
</span><span class='line'>"Thread-6" #24 prio=5 os_prio=0 tid=0x00007fb91498a000 nid=0x4746 waiting on condition [0x00007fb9077fe000]
</span><span class='line'>   java.lang.Thread.State: TIMED_WAITING (sleeping)
</span><span class='line'>  at java.lang.Thread.sleep(Native Method)
</span><span class='line'>  at Test$1.run(Test.java:9)
</span><span class='line'>...   </span></code></pre></td></tr></table></div></figure>


<p>上面的线程栈我们注意到nid的值其实就是线程ID，它是十六进制的，我们将消耗cpu最高的线程<code>18250</code>，转成十六进制<code>0x474a</code>，然后从上面的线程栈里找到<code>nid=0x474a</code>的线程，其栈为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>"Busiest Thread" #28 prio=5 os_prio=0 tid=0x00007fb91498d000 nid=0x474a runnable [0x00007fb9065fe000]
</span><span class='line'>   java.lang.Thread.State: RUNNABLE
</span><span class='line'>  at Test$2.run(Test.java:18)</span></code></pre></td></tr></table></div></figure>


<p>即将最耗cpu的线程找出来了，是<code>Businest Thread</code></p>

<h1>欢迎各位关注个人微信公众号，主要围绕JVM写一系列的原理性，性能调优的文章</h1>

<p><img src="/images/gzh.jpg" width="200" height="200"></p>

      
      
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2016-03-27T11:31:25+08:00" pubdate data-updated="true">Mar 27<span>th</span>, 2016</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2016/03/27/object-wait-notify/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2016/03/27/object-wait-notify/">JVM源码分析之Object.wait/notify(All)完全解读</a></h1>
      <h2>概述</h2>

<p>本文其实一直都想写，因为各种原因一直拖着没写，直到开公众号的第一天，有朋友再次问到这个问题，这次让我静心下来准备写下这篇文章，本文有些东西是我自己的理解，比如为什么JDK一开始要这么设计，初衷是什么，没怎么去找相关资料，所以只能谈谈自己的理解，所以大家看到文章之后可以谈谈自己的看法，对于实现部分我倒觉得说清楚问题不大，code is here，看明白了就知道怎么回事了。</p>


      
       <a href="/blog/2016/03/27/object-wait-notify/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2016-03-15T13:51:58+08:00" pubdate data-updated="true">Mar 15<span>th</span>, 2016</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2016/03/15/ygc-classloader/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/classloader/"><span class="badge">ClassLoader</span></a>
          
          <a href="/blog/categories/gc/"><span class="badge">GC</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2016/03/15/ygc-classloader/">JVM源码分析之自定义类加载器如何拉长YGC</a></h1>
      <h2>概述</h2>

<p>本文重点讲述毕玄大师在其公众号上发的一个GC问题<a href="http://hellojava.info/?p=438">一个jstack/jmap等不能用的case</a>（PS：话说毕大师超级喜欢在题目里用case这个词，我觉得题目还是能尽量做到顾名思义好，不然要找起相关文章来真的好难找），对于毕大师那篇文章，题目上没有提到GC的那个问题，不过进入到文章里可以看到，既然文章提到了jstack/jmap的问题，这里也简单回答下jstack/jmap无法使用的问题，其实最常见的场景是使用jstack/jmap的用户和目标进程不是同一个用户，哪怕你执行jstack/jmap的动作是root用户也无济于事，详情可以参考我的这篇文章，<a href="http://lovestblog.cn/blog/2014/06/18/jvm-attach/">JVM Attach机制实现</a>,主要是讲JVM Attach机制的，不过毕大师这里主要提到的是jmap -heap/histo这两个参数带来的问题，如果使用-heap/histo的参数，其实和大家使用-F参数是一样的，底层都是通过serviceability agent来实现的，并不是jvm attach的方式，通过sa连上去之后会挂起进程，在serviceability agent里存在bug可能导致detach的动作不会被执行，从而会让进程一直挂着，可以通过top命令验证进程是否处于T状态，如果是说明进程被挂起了，如果进程被挂起了，可以通过kill -CONT [pid]来恢复。</p>


      
       <a href="/blog/2016/03/15/ygc-classloader/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-10-21T18:54:01+08:00" pubdate data-updated="true">Oct 21<span>st</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/10/21/deadlock/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/deadlock/"><span class="badge">DeadLock</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/10/21/deadlock/">消失的死锁</a></h1>
      <h2>问题描述</h2>

<p>如果java层面发生了死锁，当我们使用<code>jstack</code>命令的时候其实是可以将死锁的信息给dump出来的，在dump结果的最后会有类似<code>Found one Java-level deadlock:</code>的关键字，接着会把发生死锁的线程的堆栈及对应的同步锁给打印出来，这次碰到一个系统就发生类似的问题，不过这个dump文档里虽然提到了如下的死锁信息：</p>


      
       <a href="/blog/2015/10/21/deadlock/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-09-14T13:17:50+08:00" pubdate data-updated="true">Sep 14<span>th</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/09/14/javaagent/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/agent/"><span class="badge">Agent</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/09/14/javaagent/">JVM源码分析之javaagent原理完全解读</a></h1>
      <p><code>注:文章首发于InfoQ：</code><a href="http://www.infoq.com/cn/articles/javaagent-illustrated">JVM源码分析之javaagent原理完全解读</a></p>

<h2>概述</h2>

<p>本文重点讲述javaagent的具体实现，因为它面向的是我们java程序员，而且agent都是用java编写的，不需要太多的c/c++编程基础，不过这篇文章里也会讲到JVMTIAgent(c实现的)，因为javaagent的运行还是依赖于一个特殊的JVMTIAgent。</p>


      
       <a href="/blog/2015/09/14/javaagent/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-08-21T18:58:53+08:00" pubdate data-updated="true">Aug 21<span>st</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/08/21/rssxmx/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          <a href="/blog/categories/oomkiller/"><span class="badge">OOMKiller</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/08/21/rssxmx/">进程物理内存远大于Xmx的问题分析</a></h1>
      <h2>问题描述</h2>

<p>最近经常被问到一个问题，&#8221;为什么我们系统进程占用的物理内存(Res/Rss)会远远大于设置的Xmx值&#8221;，比如Xmx设置1.7G，但是top看到的Res的值却达到了3.0G，随着进程的运行，Res的值还在递增，直到达到某个值，被OS当做bad process直接被kill掉了。</p>


      
       <a href="/blog/2015/08/21/rssxmx/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-07-09T14:35:31+08:00" pubdate data-updated="true">Jul 9<span>th</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/07/09/final-reference/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/finalreference/"><span class="badge">FinalReference</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/07/09/final-reference/">JVM源码分析之FinalReference完全解读</a></h1>
      <p><code>注:文章首发于InfoQ：</code><a href="" title="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference">JVM源码分析之FinalReference</a></p>

<h2>概述</h2>

<p>JAVA对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了四种其他引用：SoftReference、WeakReference、PhantomReference、FinalReference，本文主要想讲的是FinalReference，因为我们在使用内存分析工具比如zprofiler、mat等在分析一些oom的heap的时候，经常能看到 <code>java.lang.ref.Finalizer</code>占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角<code>FinalReference</code>有着密不可分的关系。</p>


      
       <a href="/blog/2015/07/09/final-reference/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-05-12T13:49:57+08:00" pubdate data-updated="true">May 12<span>th</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/05/12/direct-buffer/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/05/12/direct-buffer/">JVM源码分析之堆外内存完全解读</a></h1>
      <h2>概述</h2>

<h3>广义的堆外内存</h3>

<p>说到堆外内存，那大家肯定想到堆内内存，这也是我们大家接触最多的，我们在jvm参数里通常设置-Xmx来指定我们的堆的最大值，不过这还不是我们理解的Java堆，-Xmx的值是新生代和老生代的和的最大值，我们在jvm参数里通常还会加一个参数-XX:MaxPermSize来指定持久代的最大值，那么我们认识的Java堆的最大值其实是-Xmx和-XX:MaxPermSize的总和，在分代算法下，新生代，老生代和持久代是连续的虚拟地址，因为它们是一起分配的，那么剩下的都可以认为是堆外内存(广义的)了，这些包括了jvm本身在运行过程中分配的内存，codecache，jni里分配的内存，DirectByteBuffer分配的内存等等</p>

<h3>狭义的堆外内存</h3>

<p>而作为java开发者，我们常说的堆外内存溢出了，其实是狭义的堆外内存，这个主要是指java.nio.DirectByteBuffer在创建的时候分配内存，我们这篇文章里也主要是讲狭义的堆外内存，因为它和我们平时碰到的问题比较密切</p>


      
       <a href="/blog/2015/05/12/direct-buffer/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-05-07T20:02:51+08:00" pubdate data-updated="true">May 7<span>th</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/05/07/system-gc/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          <a href="/blog/categories/systemgc/"><span class="badge">SystemGC</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/05/07/system-gc/">JVM源码分析之SystemGC完全解读</a></h1>
      <h2>概述</h2>

<p>JVM的GC一般情况下是JVM本身根据一定的条件触发的，不过我们还是可以做一些人为的触发，比如通过jvmti做强制GC，通过System.gc触发，还可以通过jmap来触发等，针对每个场景其实我们都可以写篇文章来做一个介绍，本文重点介绍下System.gc的原理</p>


      
       <a href="/blog/2015/05/07/system-gc/">Read on &rarr;</a> 
    </div>
  </div>


</article>


    <article class="post">

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-07-24T14:10:26+08:00" pubdate data-updated="true">Jul 24<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/07/24/jvm-thread-dump-bug/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          <a href="/blog/categories/thread/"><span class="badge">Thread</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/07/24/jvm-thread-dump-bug/">JVM Bug:多个线程持有一把锁?</a></h1>
      <p><code>注:文章首发于InfoQ，</code><a href="http://www.infoq.com/cn/articles/jvm-bug-thread">http://www.infoq.com/cn/articles/jvm-bug-thread</a></p>

<h2>JVM线程dump Bug描述</h2>

<p>&#8195;&#8195;在JAVA语言中，当同步块(<code>Synchronized</code>)被多个线程并发访问时，JVM中会采用基于互斥实现的重量级锁。JVM最多只允许一个线程持有这把锁，如果其它线程想要获得这把锁就必须处于等待状态，也就是说在同步块被并发访问时，最多只会有一个处于<code>RUNNABLE</code>状态的线程持有某把锁，而另外的线程因为竞争不到这把锁而都处于<code>BLOCKED</code>状态。然而有些时候我们会发现处于<code>BLOCKED</code>状态的线程，它的最上面那一帧在打印其正在等待的锁对象时，居然也会出现-locked的信息，这个信息和持有该锁的线程打印出来的结果是一样的(请看下图)，但是对比其他<code>BLOCKED</code>态的线程却并没有都出现这种情况。当我们再次dump线程时又可能出现不一样的结果。测试表明这可能是一个偶发的情况，本文就是针对这种情况对JVM内部的实现做了一个研究以寻找其根源。</p>


      
       <a href="/blog/2014/07/24/jvm-thread-dump-bug/">Read on &rarr;</a> 
    </div>
  </div>


</article>

<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
        </div>
      </div>
      <div class="row-fluid">
        <footer class="footer-page" role="contentinfo">
          <p>
  Copyright &copy; 2016 - 你假笨 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> - Theme by <a href="http://alexgaribay.com">Alex Garibay</a>
</p>


        </footer>
      </div>
  </div>
  





  <script type="text/javascript">
//    (function() {
 //     var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
   //   script.src = 'https://apis.google.com/js/plusone.js';
    //  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
   // })();
  </script>







</body>
</html>
