
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>JVM Attach机制实现 - 你假笨</title>
  <meta name="author" content="你假笨">

  
  <meta name="description" content="Attach是什么 在讲这个之前，我们先来点大家都知道的东西，当我们感觉线程一直卡在某个地方，想知道卡在哪里，首先想到的是进行线程dump，而常用的命令是jstack ，我们就可以看到如下线程栈了 大家是否注意过上面圈起来的两个线程，”Attach Listener”和“Signal &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://nijiaben.github.io/blog/2014/07/14/jvm-attach/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="你假笨" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  	<div id="logoLeft">{</div>
  	<div id="logoText">sihugh</div>
  	<div id="logoRight">}</div>
  	<div class="clear"></div>
  </div>
  <h1><a href="/">你假笨</a></h1>
  
    <h2>...jvm，linux，tcp...</h2>
  
  <div class="clear"></div>
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:nijiaben.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">JVM Attach机制实现</h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2014-07-14T19:15:52+08:00" pubdate data-updated="true">Jul 14<span>th</span>, 2014</time>
        
        
          | <a href="#comments">Comments</a>
         

      </p>
    
  </header>


<div class="entry-content"><h2>Attach是什么</h2>

<p>   在讲这个之前，我们先来点大家都知道的东西，当我们感觉线程一直卡在某个地方，想知道卡在哪里，首先想到的是进行线程dump，而常用的命令是jstack <pid>，我们就可以看到如下线程栈了</p>

<p><img src="/images/2014/07/trd.png"></p>

<p>   大家是否注意过上面圈起来的两个线程，”Attach Listener”和“Signal Dispatcher”，这两个线程是我们这次要讲的Attach机制的关键，先偷偷告诉各位，其实Attach Listener这个线程在jvm起来的时候可能并没有的，后面会细说。</p>

<p>   那Attach机制是什么？说简单点就是jvm提供一种jvm进程间通信的能力，能让一个进程传命令给另外一个进程，并让它执行内部的一些操作，比如说我们为了让另外一个jvm进程把线程dump出来，那么我们跑了一个jstack的进程，然后传了个pid的参数，告诉它要哪个进程进行线程dump，既然是两个进程，那肯定涉及到进程间通信，以及传输协议的定义，比如要执行什么操作，传了什么参数等</p>

<!--more-->


<h2>Attach能做些什么</h2>

<p>   总结起来说，比如内存dump，线程dump，类信息统计(比如加载的类及大小以及实例个数等)，动态加载agent(使用过btrace的应该不陌生)，动态设置vm flag(但是并不是所有的flag都可以设置的，因为有些flag是在jvm启动过程中使用的，是一次性的)，打印vm flag，获取系统属性等，这些对应的源码(AttachListener.cpp)如下</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static AttachOperationFunctionInfo funcs[] = {
</span><span class='line'>  { "agentProperties",  get_agent_properties },
</span><span class='line'>  { "datadump",         data_dump },
</span><span class='line'>  { "dumpheap",         dump_heap },
</span><span class='line'>  { "load",             JvmtiExport::load_agent_library },
</span><span class='line'>  { "properties",       get_system_properties },
</span><span class='line'>  { "threaddump",       thread_dump },
</span><span class='line'>  { "inspectheap",      heap_inspection },
</span><span class='line'>  { "setflag",          set_flag },
</span><span class='line'>  { "printflag",        print_flag },
</span><span class='line'>  { "jcmd",             jcmd },
</span><span class='line'>  { NULL,               NULL }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>后面是命令对应的处理函数。</p>

<h2>Attach在jvm里如何实现的</h2>

<h3>Attach Listener线程的创建</h3>

<p> 前面也提到了，jvm在启动过程中可能并没有启动Attach Listener这个线程，可以通过jvm参数来启动，代码  （Threads::create_vm）如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  if (!DisableAttachMechanism) {
</span><span class='line'>    if (StartAttachListener || AttachListener::init_at_startup()) {
</span><span class='line'>      AttachListener::init();
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>bool AttachListener::init_at_startup() {
</span><span class='line'>  if (ReduceSignalUsage) {
</span><span class='line'>    return true;
</span><span class='line'>  } else {
</span><span class='line'>    return false;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中DisableAttachMechanism，StartAttachListener ，ReduceSignalUsage均默认是false(globals.hpp)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>product(bool, DisableAttachMechanism, false,                              \
</span><span class='line'>         "Disable mechanism that allows tools to Attach to this VM”)   
</span><span class='line'>product(bool, StartAttachListener, false,                                 \
</span><span class='line'>          "Always start Attach Listener at VM startup")  
</span><span class='line'>product(bool, ReduceSignalUsage, false,                                   \
</span><span class='line'>          "Reduce the use of OS signals in Java and/or the VM”)  </span></code></pre></td></tr></table></div></figure>


<p>因此AttachListener::init()并不会被执行，而Attach Listener线程正是在此方法里创建的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Starts the Attach Listener thread
</span><span class='line'>void AttachListener::init() {
</span><span class='line'>  EXCEPTION_MARK;
</span><span class='line'>  klassOop k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), true, CHECK);
</span><span class='line'>  instanceKlassHandle klass (THREAD, k);
</span><span class='line'>  instanceHandle thread_oop = klass-&gt;allocate_instance_handle(CHECK);
</span><span class='line'>
</span><span class='line'>  const char thread_name[] = "Attach Listener";
</span><span class='line'>  Handle string = java_lang_String::create_from_str(thread_name, CHECK);
</span><span class='line'>
</span><span class='line'>  // Initialize thread_oop to put it into the system threadGroup
</span><span class='line'>  Handle thread_group (THREAD, Universe::system_thread_group());
</span><span class='line'>  JavaValue result(T_VOID);
</span><span class='line'>  JavaCalls::call_special(&result, thread_oop,
</span><span class='line'>                       klass,
</span><span class='line'>                       vmSymbols::object_initializer_name(),
</span><span class='line'>                       vmSymbols::threadgroup_string_void_signature(),
</span><span class='line'>                       thread_group,
</span><span class='line'>                       string,
</span><span class='line'>                       CHECK);
</span><span class='line'>
</span><span class='line'>  KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
</span><span class='line'>  JavaCalls::call_special(&result,
</span><span class='line'>                        thread_group,
</span><span class='line'>                        group,
</span><span class='line'>                        vmSymbols::add_method_name(),
</span><span class='line'>                        vmSymbols::thread_void_signature(),
</span><span class='line'>                        thread_oop,             // ARG 1
</span><span class='line'>                        CHECK);
</span><span class='line'>
</span><span class='line'>  { MutexLocker mu(Threads_lock);
</span><span class='line'>    JavaThread* listener_thread = new JavaThread(&Attach_listener_thread_entry);
</span><span class='line'>
</span><span class='line'>    // Check that thread and osthread were created
</span><span class='line'>    if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) {
</span><span class='line'>      vm_exit_during_initialization("java.lang.OutOfMemoryError",
</span><span class='line'>                                    "unable to create new native thread");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    java_lang_Thread::set_thread(thread_oop(), listener_thread);
</span><span class='line'>    java_lang_Thread::set_daemon(thread_oop());
</span><span class='line'>
</span><span class='line'>    listener_thread-&gt;set_threadObj(thread_oop());
</span><span class='line'>    Threads::add(listener_thread);
</span><span class='line'>    Thread::start(listener_thread);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>既然在启动的时候不会创建这个线程，那么我们在上面看到的那个线程是怎么创建的呢，这个就要关注另外一个线程“Signal Dispatcher”了，顾名思义是处理信号的，这个线程是在jvm启动的时候就会创建的，具体代码就不说了。</p>

<p>下面以jstack的实现来说明触发Attach这一机制进行的过程，jstack命令的实现其实是一个叫做JStack.java的类，查看jstack代码后会走到下面的方法里</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static void runThreadDump(String pid, String args[]) throws Exception {
</span><span class='line'>        VirtualMachine vm = null;
</span><span class='line'>        try {
</span><span class='line'>            vm = VirtualMachine.Attach(pid);
</span><span class='line'>        } catch (Exception x) {
</span><span class='line'>            String msg = x.getMessage();
</span><span class='line'>            if (msg != null) {
</span><span class='line'>                System.err.println(pid + ": " + msg);
</span><span class='line'>            } else {
</span><span class='line'>                x.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>            if ((x instanceof AttachNotSupportedException) &&
</span><span class='line'>                (loadSAClass() != null)) {
</span><span class='line'>                System.err.println("The -F option can be used when the target " +
</span><span class='line'>                    "process is not responding");
</span><span class='line'>            }
</span><span class='line'>            System.exit(1);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Cast to HotSpotVirtualMachine as this is implementation specific
</span><span class='line'>        // method.
</span><span class='line'>        InputStream in = ((HotSpotVirtualMachine)vm).remoteDataDump((Object[])args);
</span><span class='line'>
</span><span class='line'>        // read to EOF and just print output
</span><span class='line'>        byte b[] = new byte[256];
</span><span class='line'>        int n;
</span><span class='line'>        do {
</span><span class='line'>            n = in.read(b);
</span><span class='line'>            if (n &gt; 0) {
</span><span class='line'>                String s = new String(b, 0, n, "UTF-8");
</span><span class='line'>                System.out.print(s);
</span><span class='line'>            }
</span><span class='line'>        } while (n &gt; 0);
</span><span class='line'>        in.close();
</span><span class='line'>        vm.detach();
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>请注意VirtualMachine.Attach(pid);这行代码，触发Attach pid的关键，如果是在linux下会走到下面的构造函数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LinuxVirtualMachine(AttachProvider provider, String vmid)
</span><span class='line'>        throws AttachNotSupportedException, IOException
</span><span class='line'>    {
</span><span class='line'>        super(provider, vmid);
</span><span class='line'>
</span><span class='line'>        // This provider only understands pids
</span><span class='line'>        int pid;
</span><span class='line'>        try {
</span><span class='line'>            pid = Integer.parseInt(vmid);
</span><span class='line'>        } catch (NumberFormatException x) {
</span><span class='line'>            throw new AttachNotSupportedException("Invalid process identifier");
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Find the socket file. If not found then we attempt to start the
</span><span class='line'>        // Attach mechanism in the target VM by sending it a QUIT signal.
</span><span class='line'>        // Then we attempt to find the socket file again.
</span><span class='line'>        path = findSocketFile(pid);
</span><span class='line'>        if (path == null) {
</span><span class='line'>            File f = createAttachFile(pid);
</span><span class='line'>            try {
</span><span class='line'>                // On LinuxThreads each thread is a process and we don't have the
</span><span class='line'>                // pid of the VMThread which has SIGQUIT unblocked. To workaround
</span><span class='line'>                // this we get the pid of the "manager thread" that is created
</span><span class='line'>                // by the first call to pthread_create. This is parent of all
</span><span class='line'>                // threads (except the initial thread).
</span><span class='line'>                if (isLinuxThreads) {
</span><span class='line'>                    int mpid;
</span><span class='line'>                    try {
</span><span class='line'>                        mpid = getLinuxThreadsManager(pid);
</span><span class='line'>                    } catch (IOException x) {
</span><span class='line'>                        throw new AttachNotSupportedException(x.getMessage());
</span><span class='line'>                    }
</span><span class='line'>                    assert(mpid &gt;= 1);
</span><span class='line'>                    sendQuitToChildrenOf(mpid);
</span><span class='line'>                } else {
</span><span class='line'>                    sendQuitTo(pid);
</span><span class='line'>                }
</span><span class='line'>
</span><span class='line'>                // give the target VM time to start the Attach mechanism
</span><span class='line'>                int i = 0;
</span><span class='line'>                long delay = 200;
</span><span class='line'>                int retries = (int)(AttachTimeout() / delay);
</span><span class='line'>                do {
</span><span class='line'>                    try {
</span><span class='line'>                        Thread.sleep(delay);
</span><span class='line'>                    } catch (InterruptedException x) { }
</span><span class='line'>                    path = findSocketFile(pid);
</span><span class='line'>                    i++;
</span><span class='line'>                } while (i &lt;= retries && path == null);
</span><span class='line'>                if (path == null) {
</span><span class='line'>                    throw new AttachNotSupportedException(
</span><span class='line'>                        "Unable to open socket file: target process not responding " +
</span><span class='line'>                        "or HotSpot VM not loaded");
</span><span class='line'>                }
</span><span class='line'>            } finally {
</span><span class='line'>                f.delete();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Check that the file owner/permission to avoid Attaching to
</span><span class='line'>        // bogus process
</span><span class='line'>        checkPermissions(path);
</span><span class='line'>
</span><span class='line'>        // Check that we can connect to the process
</span><span class='line'>        // - this ensures we throw the permission denied error now rather than
</span><span class='line'>        // later when we attempt to enqueue a command.
</span><span class='line'>        int s = socket();
</span><span class='line'>        try {
</span><span class='line'>            connect(s, path);
</span><span class='line'>        } finally {
</span><span class='line'>            close(s);
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>这里要解释下代码了，首先看到调用了createAttachFile方法在目标进程的cwd目录下创建了一个文件/proc/<pid>/cwd/.Attach_pid<pid>，这个在后面的信号处理过程中会取出来做判断(为了安全)，另外我们知道在linux下线程是用进程实现的，在jvm启动过程中会创建很多线程，比如我们上面的信号线程，也就是会看到很多的pid(应该是LWP)，那么如何找到这个信号处理线程呢，从上面实现来看是找到我们传进去的pid的父进程，然后给它的所有子进程都发送一个SIGQUIT信号，而jvm里除了信号线程，其他线程都设置了对此信号的屏蔽，因此收不到该信号，于是该信号就传给了“Signal Dispatcher”，在传完之后作轮询等待看目标进程是否创建了某个文件，AttachTimeout默认超时时间是5000ms，可通过设置系统变量sun.tools.Attach.AttachTimeout来指定，下面是Signal Dispatcher线程的entry实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void signal_thread_entry(JavaThread* thread, TRAPS) {
</span><span class='line'>  os::set_priority(thread, NearMaxPriority);
</span><span class='line'>  while (true) {
</span><span class='line'>    int sig;
</span><span class='line'>    {
</span><span class='line'>      // FIXME : Currently we have not decieded what should be the status
</span><span class='line'>      //         for this java thread blocked here. Once we decide about
</span><span class='line'>      //         that we should fix this.
</span><span class='line'>      sig = os::signal_wait();
</span><span class='line'>    }
</span><span class='line'>    if (sig == os::sigexitnum_pd()) {
</span><span class='line'>       // Terminate the signal thread
</span><span class='line'>       return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    switch (sig) {
</span><span class='line'>      case SIGBREAK: {
</span><span class='line'>        // Check if the signal is a trigger to start the Attach Listener - in that
</span><span class='line'>        // case don't print stack traces.
</span><span class='line'>        if (!DisableAttachMechanism && AttachListener::is_init_trigger()) {
</span><span class='line'>          continue;
</span><span class='line'>        }
</span><span class='line'>        // Print stack traces
</span><span class='line'>        // Any SIGBREAK operations added here should make sure to flush
</span><span class='line'>        // the output stream (e.g. tty-&gt;flush()) after output.  See 4803766.
</span><span class='line'>        // Each module also prints an extra carriage return after its output.
</span><span class='line'>        VM_PrintThreads op;
</span><span class='line'>        VMThread::execute(&op);
</span><span class='line'>        VM_PrintJNI jni_op;
</span><span class='line'>        VMThread::execute(&jni_op);
</span><span class='line'>        VM_FindDeadlocks op1(tty);
</span><span class='line'>        VMThread::execute(&op1);
</span><span class='line'>        Universe::print_heap_at_SIGBREAK();
</span><span class='line'>        if (PrintClassHistogram) {
</span><span class='line'>          VM_GC_HeapInspection op1(gclog_or_tty, true /* force full GC before heap inspection */,
</span><span class='line'>                                   true /* need_prologue */);
</span><span class='line'>          VMThread::execute(&op1);
</span><span class='line'>        }
</span><span class='line'>        if (JvmtiExport::should_post_data_dump()) {
</span><span class='line'>          JvmtiExport::post_data_dump();
</span><span class='line'>        }
</span><span class='line'>        break;
</span><span class='line'>      }
</span><span class='line'>      ….
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当信号是SIGBREAK(在jvm里做了#define，其实就是SIGQUIT)的时候，就会触发
AttachListener::is_init_trigger()的执行，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bool AttachListener::is_init_trigger() {
</span><span class='line'>  if (init_at_startup() || is_initialized()) {
</span><span class='line'>    return false;               // initialized at startup or already initialized
</span><span class='line'>  }
</span><span class='line'>  char fn[PATH_MAX+1];
</span><span class='line'>  sprintf(fn, ".Attach_pid%d", os::current_process_id());
</span><span class='line'>  int ret;
</span><span class='line'>  struct stat64 st;
</span><span class='line'>  RESTARTABLE(::stat64(fn, &st), ret);
</span><span class='line'>  if (ret == -1) {
</span><span class='line'>    snprintf(fn, sizeof(fn), "%s/.Attach_pid%d",
</span><span class='line'>             os::get_temp_directory(), os::current_process_id());
</span><span class='line'>    RESTARTABLE(::stat64(fn, &st), ret);
</span><span class='line'>  }
</span><span class='line'>  if (ret == 0) {
</span><span class='line'>    // simple check to avoid starting the Attach mechanism when
</span><span class='line'>    // a bogus user creates the file
</span><span class='line'>    if (st.st_uid == geteuid()) {
</span><span class='line'>      init();
</span><span class='line'>      return true;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  return false;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一开始会判断当前进程目录下是否有个.Attach_pid<pid>文件（前面提到了），如果没有就会在/tmp下创建一个/tmp/.Attach_pid<pid>，当那个文件的uid和自己的uid是一致的情况下（为了安全）再调用init方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Starts the Attach Listener thread
</span><span class='line'>void AttachListener::init() {
</span><span class='line'>  EXCEPTION_MARK;
</span><span class='line'>  klassOop k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_Thread(), true, CHECK);
</span><span class='line'>  instanceKlassHandle klass (THREAD, k);
</span><span class='line'>  instanceHandle thread_oop = klass-&gt;allocate_instance_handle(CHECK);
</span><span class='line'>
</span><span class='line'>  const char thread_name[] = "Attach Listener";
</span><span class='line'>  Handle string = java_lang_String::create_from_str(thread_name, CHECK);
</span><span class='line'>
</span><span class='line'>  // Initialize thread_oop to put it into the system threadGroup
</span><span class='line'>  Handle thread_group (THREAD, Universe::system_thread_group());
</span><span class='line'>  JavaValue result(T_VOID);
</span><span class='line'>  JavaCalls::call_special(&result, thread_oop,
</span><span class='line'>                       klass,
</span><span class='line'>                       vmSymbols::object_initializer_name(),
</span><span class='line'>                       vmSymbols::threadgroup_string_void_signature(),
</span><span class='line'>                       thread_group,
</span><span class='line'>                       string,
</span><span class='line'>                       CHECK);
</span><span class='line'>
</span><span class='line'>  KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
</span><span class='line'>  JavaCalls::call_special(&result,
</span><span class='line'>                        thread_group,
</span><span class='line'>                        group,
</span><span class='line'>                        vmSymbols::add_method_name(),
</span><span class='line'>                        vmSymbols::thread_void_signature(),
</span><span class='line'>                        thread_oop,             // ARG 1
</span><span class='line'>                        CHECK);
</span><span class='line'>
</span><span class='line'>  { MutexLocker mu(Threads_lock);
</span><span class='line'>    JavaThread* listener_thread = new JavaThread(&Attach_listener_thread_entry);
</span><span class='line'>
</span><span class='line'>    // Check that thread and osthread were created
</span><span class='line'>    if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) {
</span><span class='line'>      vm_exit_during_initialization("java.lang.OutOfMemoryError",
</span><span class='line'>                                    "unable to create new native thread");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    java_lang_Thread::set_thread(thread_oop(), listener_thread);
</span><span class='line'>    java_lang_Thread::set_daemon(thread_oop());
</span><span class='line'>
</span><span class='line'>    listener_thread-&gt;set_threadObj(thread_oop());
</span><span class='line'>    Threads::add(listener_thread);
</span><span class='line'>    Thread::start(listener_thread);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>此时水落石出了，看到创建了一个线程，并且取名为Attach Listener。再看看其子类LinuxAttachListener的init方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int LinuxAttachListener::init() {
</span><span class='line'>  char path[UNIX_PATH_MAX];          // socket file
</span><span class='line'>  char initial_path[UNIX_PATH_MAX];  // socket file during setup
</span><span class='line'>  int listener;                      // listener socket (file descriptor)
</span><span class='line'>
</span><span class='line'>  // register function to cleanup
</span><span class='line'>  ::atexit(listener_cleanup);
</span><span class='line'>
</span><span class='line'>  int n = snprintf(path, UNIX_PATH_MAX, "%s/.java_pid%d",
</span><span class='line'>                   os::get_temp_directory(), os::current_process_id());
</span><span class='line'>  if (n &lt; (int)UNIX_PATH_MAX) {
</span><span class='line'>    n = snprintf(initial_path, UNIX_PATH_MAX, "%s.tmp", path);
</span><span class='line'>  }
</span><span class='line'>  if (n &gt;= (int)UNIX_PATH_MAX) {
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // create the listener socket
</span><span class='line'>  listener = ::socket(PF_UNIX, SOCK_STREAM, 0);
</span><span class='line'>  if (listener == -1) {
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // bind socket
</span><span class='line'>  struct sockaddr_un addr;
</span><span class='line'>  addr.sun_family = AF_UNIX;
</span><span class='line'>  strcpy(addr.sun_path, initial_path);
</span><span class='line'>  ::unlink(initial_path);
</span><span class='line'>  int res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
</span><span class='line'>  if (res == -1) {
</span><span class='line'>    RESTARTABLE(::close(listener), res);
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // put in listen mode, set permissions, and rename into place
</span><span class='line'>  res = ::listen(listener, 5);
</span><span class='line'>  if (res == 0) {
</span><span class='line'>      RESTARTABLE(::chmod(initial_path, S_IREAD|S_IWRITE), res);
</span><span class='line'>      if (res == 0) {
</span><span class='line'>          res = ::rename(initial_path, path);
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  if (res == -1) {
</span><span class='line'>    RESTARTABLE(::close(listener), res);
</span><span class='line'>    ::unlink(initial_path);
</span><span class='line'>    return -1;
</span><span class='line'>  }
</span><span class='line'>  set_path(path);
</span><span class='line'>  set_listener(listener);
</span><span class='line'>
</span><span class='line'>  return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>看到其创建了一个监听套接字，并创建了一个文件/tmp/.java_pid<pid>，这个文件就是客户端之前一直在轮询等待的文件，随着这个文件的生成，意味着Attach的过程圆满结束了。</p>

<h3>Attach listener接收请求</h3>

<p>看看它的entry实现Attach_listener_thread_entry</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void Attach_listener_thread_entry(JavaThread* thread, TRAPS) {
</span><span class='line'>  os::set_priority(thread, NearMaxPriority);
</span><span class='line'>
</span><span class='line'>  thread-&gt;record_stack_base_and_size();
</span><span class='line'>
</span><span class='line'>  if (AttachListener::pd_init() != 0) {
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>  AttachListener::set_initialized();
</span><span class='line'>
</span><span class='line'>  for (;;) {
</span><span class='line'>    AttachOperation* op = AttachListener::dequeue();
</span><span class='line'>    if (op == NULL) {
</span><span class='line'>      return;   // dequeue failed or shutdown
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    ResourceMark rm;
</span><span class='line'>    bufferedStream st;
</span><span class='line'>    jint res = JNI_OK;
</span><span class='line'>
</span><span class='line'>    // handle special detachall operation
</span><span class='line'>    if (strcmp(op-&gt;name(), AttachOperation::detachall_operation_name()) == 0) {
</span><span class='line'>      AttachListener::detachall();
</span><span class='line'>    } else {
</span><span class='line'>      // find the function to dispatch too
</span><span class='line'>      AttachOperationFunctionInfo* info = NULL;
</span><span class='line'>      for (int i=0; funcs[i].name != NULL; i++) {
</span><span class='line'>        const char* name = funcs[i].name;
</span><span class='line'>        assert(strlen(name) &lt;= AttachOperation::name_length_max, "operation &lt;= name_length_max");
</span><span class='line'>        if (strcmp(op-&gt;name(), name) == 0) {
</span><span class='line'>          info = &(funcs[i]);
</span><span class='line'>          break;
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      // check for platform dependent Attach operation
</span><span class='line'>      if (info == NULL) {
</span><span class='line'>        info = AttachListener::pd_find_operation(op-&gt;name());
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>      if (info != NULL) {
</span><span class='line'>        // dispatch to the function that implements this operation
</span><span class='line'>        res = (info-&gt;func)(op, &st);
</span><span class='line'>      } else {
</span><span class='line'>        st.print("Operation %s not recognized!", op-&gt;name());
</span><span class='line'>        res = JNI_ERR;
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // operation complete - send result and output to client
</span><span class='line'>    op-&gt;complete(res, &st);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从代码来看就是从队列里不断取AttachOperation，然后找到请求命令对应的方法进行执行，比如我们一开始说的jstack命令，找到 { &#8220;threaddump&#8221;,       thread_dump }的映射关系，然后执行thread_dump方法</p>

<p>再来看看其要调用的AttachListener::dequeue()，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AttachOperation* AttachListener::dequeue() {
</span><span class='line'>  JavaThread* thread = JavaThread::current();
</span><span class='line'>  ThreadBlockInVM tbivm(thread);
</span><span class='line'>
</span><span class='line'>  thread-&gt;set_suspend_equivalent();
</span><span class='line'>  // cleared by handle_special_suspend_equivalent_condition() or
</span><span class='line'>  // java_suspend_self() via check_and_wait_while_suspended()
</span><span class='line'>
</span><span class='line'>  AttachOperation* op = LinuxAttachListener::dequeue();
</span><span class='line'>
</span><span class='line'>  // were we externally suspended while we were waiting?
</span><span class='line'>  thread-&gt;check_and_wait_while_suspended();
</span><span class='line'>
</span><span class='line'>  return op;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最终调用的是LinuxAttachListener::dequeue()，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LinuxAttachOperation* LinuxAttachListener::dequeue() {
</span><span class='line'>  for (;;) {
</span><span class='line'>    int s;
</span><span class='line'>
</span><span class='line'>    // wait for client to connect
</span><span class='line'>    struct sockaddr addr;
</span><span class='line'>    socklen_t len = sizeof(addr);
</span><span class='line'>    RESTARTABLE(::accept(listener(), &addr, &len), s);
</span><span class='line'>    if (s == -1) {
</span><span class='line'>      return NULL;      // log a warning?
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // get the credentials of the peer and check the effective uid/guid
</span><span class='line'>    // - check with jeff on this.
</span><span class='line'>    struct ucred cred_info;
</span><span class='line'>    socklen_t optlen = sizeof(cred_info);
</span><span class='line'>    if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
</span><span class='line'>      int res;
</span><span class='line'>      RESTARTABLE(::close(s), res);
</span><span class='line'>      continue;
</span><span class='line'>    }
</span><span class='line'>    uid_t euid = geteuid();
</span><span class='line'>    gid_t egid = getegid();
</span><span class='line'>
</span><span class='line'>    if (cred_info.uid != euid || cred_info.gid != egid) {
</span><span class='line'>      int res;
</span><span class='line'>      RESTARTABLE(::close(s), res);
</span><span class='line'>      continue;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // peer credential look okay so we read the request
</span><span class='line'>    LinuxAttachOperation* op = read_request(s);
</span><span class='line'>    if (op == NULL) {
</span><span class='line'>      int res;
</span><span class='line'>      RESTARTABLE(::close(s), res);
</span><span class='line'>      continue;
</span><span class='line'>    } else {
</span><span class='line'>      return op;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们看到如果没有请求的话，会一直accept在那里，当来了请求，然后就会创建一个套接字，并读取数据，构建出LinuxAttachOperation返回并执行。</p>

<p>整个过程就这样了，从Attach线程创建到接收请求，处理请求。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">你假笨</span></span>

      








  


<time datetime="2014-07-14T19:15:52+08:00" pubdate data-updated="true">Jul 14<span>th</span>, 2014</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://nijiaben.github.io/blog/2014/07/14/jvm-attach/" data-via="" data-counturl="http://nijiaben.github.io/blog/2014/07/14/jvm-attach/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left articlenav" href="/blog/2014/07/08/jdk-sql-deadlock/" title="Previous Post: JDK的sql设计不合理导致的驱动类初始化死锁问题">&laquo; JDK的sql设计不合理导致的驱动类初始化死锁问题</a>
      
      
        <a class="basic-alignment right articlenav" href="/blog/2014/07/14/tcp-broken-pipe/" title="Next Post: 从tcp原理角度理解Broken pipe和Connection reset by peer的区别">从tcp原理角度理解Broken pipe和Connection reset by peer的区别 &raquo;</a>
      
    </p>
  </footer>
</article>


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title=""></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"nijiaben"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>我的信息</h1>
  <p>
  	数码控<br/>
    码农@Alipay中间件团队，花名寒泉子<br/><br/>
    本博关注的技术领域：<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java虚拟机，linux操作系统，tcp/ip通信，中间件，框架容器等<br/><br/>
    联系方式：<br/>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微博：<a href="http://weibo.com/u/1071312434" target="_blank">你假笨_泉子</a><br/>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来往/微信：nijiaben<br/>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;邮箱：nijiaben@gmail.com<br/>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;欢迎各位发简历加入我们的团队
  </p>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/07/14/tcp-broken-pipe/">从tcp原理角度理解Broken pipe和Connection reset by peer的区别</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/14/jvm-attach/">JVM Attach机制实现</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/08/jdk-sql-deadlock/">JDK的sql设计不合理导致的驱动类初始化死锁问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/23/new-begin/">Octopress新纪元</a>
      </li>
    
  </ul>
</section>




<section>
<h1>Recent Comments</h1>
<ul class="ds-recent-comments" data-num-items="10" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="18"></ul>

</section><section>
  <h1>友情链接</h1>
  <ul>
  	<li>
      <a href="http://alipaymiddleware.com/" target="_blank">支付宝中间件团队</a>
    </li>
    <li>
      <a href="http://nijiaben.iteye.com/" target="_blank">你假笨Iteye</a>
    </li>
    <li>
      <a href="http://coolshell.cn/" target="_blank">酷壳CoolShell</a>
    </li>
    <li>
      <a href="http://mindhacks.cn/" target="_blank">刘未鹏MIND HACKS</a>
    </li>
    <li>
      <a href="http://blog.codingnow.com/" target="_blank">云风</a>
    </li>
    <li>
      <a href="http://www.cnblogs.com/Solstice/" target="_blank">陈硕</a>
    </li>
  </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 你假笨 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
