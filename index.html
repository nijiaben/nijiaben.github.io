
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>你假笨</title>
  <meta name="author" content="你假笨">

   
  <meta name="description" content="技术宅改变世界">
  
  <meta name="keywords" content="">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://nijiaben.github.io">
  <link href="/favicon.ico" rel="icon">
  <!--
  <link href='http://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>
  -->
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="你假笨" type="application/atom+xml">
  <link href="/js/google-code-prettify/vibrant-ink.css" media="screen, projection" rel="stylesheet" type="text/css"]]>
  <script src="/js/jquery.js"></script>
  <script src="/js/bootstrap-collapse.js"></script>
  <script src="/js/modernizr-2.0.js"></script>
  <script src="/js/octopress.js" type="text/javascript"></script>
  <script src="/js/application.js"></script>
  <script type="text/javascript "src="/js/google-code-prettify/prettify.js"></script>
  <script type="text/javascript"]]>
    	$(function(){     
		 $('pre').addClass('prettyprint').attr('style','overflow:auto');
	         window.prettyPrint && prettyPrint();
                 $('table').addClass('table')});
  </script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-52812422-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <div class="navbar navbar-inverse navbar-static-top">
  	<div class="navbar-inner">
  	  <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".navbar-responsive-collapse">
          <span class="fui-menu-24"></span>
        </a>
  	  	<div class="nav-collapse collapse navbar-responsive-collapse" style="height:0;">
  	      <ul class="nav">
    
        <li ><a href="/">博客</a></li>
    
        <li ><a href="/archives/index.html">目录</a></li>
    
        <li ><a href="/comments/latest.html">最新评论</a></li>
    
        <li ><a href="/about/index.html">关于你假笨</a></li>
    
</ul>

<ul class="nav pull-right">
    
    
    
    
    <li><a href="http://weibo.com/nijiaben" title="Sina Weibo Profile"><i class="icon-weibo social-navbar"></i></a></li>
    
    
    
    
    
    
    <li><a href="/atom.xml" title="RSS Feed"><i class="icon-rss-sign social-navbar"></i></a></li>
    

    
</ul>

  	    </div>
  	  </div>
  	</div>
  </div>
  <div class="container" id="main">
      <div class="row-fluid">
        <div id="content">
          <div class="jumbotron">
  <div class="container">
    <img src="/images/header/header.jpg" width="100" height="100">
    
      你假笨
    
    <h3 class="tagline">
      
        jvm，linux，tcp&#8230;
      
    </h3>
  </div>
</div>


<div class="blog-index">
  
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-07-09T14:35:31+08:00" pubdate data-updated="true">Jul 9<span>th</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/07/09/final-reference/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm,finalreference/"><span class="badge">JVM,FinalReference</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/07/09/final-reference/">JVM源码分析之FinalReference</a></h1>
      <p>注:文章首发于InfoQ：<a href="" title="http://www.infoq.com/cn/articles/jvm-source-code-analysis-finalreference">JVM源码分析之FinalReference</a></p>

<h2>概述</h2>

<p>JAVA对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了四种其他引用：SoftReference、WeakReference、PhantomReference、FinalReference，本文主要想讲的是FinalReference，因为我们在使用内存分析工具比如zprofiler、mat等在分析一些oom的heap的时候，经常能看到 <code>java.lang.ref.Finalizer</code>占用的内存大小远远排在前面，而这个类占用的内存大小又和我们这次的主角<code>FinalReference</code>有着密不可分的关系。</p>

<p>对于FinalReference及关联的内容，我们可能有如下印象：
* 自己代码里从没有使用过
* 线程dump之后，我们能看到一个叫做<code>Finalizer</code>的java线程
* 偶尔能注意到<code>java.lang.ref.Finalizer</code>的存在
* 我们在类里可能会写finalize方法</p>

<p>那FinalReference到底存在的意义是什么，以怎样的形式和我们的代码相关联呢，这是本文要理清的问题。</p>

<h2>JDK中的FinalReference</h2>

<p>首先我们看看FinalReference在JDK里的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class FinalReference&lt;T&gt; extends Reference&lt;T&gt; {
</span><span class='line'>
</span><span class='line'>    public FinalReference(T referent, ReferenceQueue&lt;? super T&gt; q) {
</span><span class='line'>        super(referent, q);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>大家应该注意到了类访问权限是package的，这也就意味着我们不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现<code>java.lang.ref.Finalizer</code>，这个类也是我们在概述里提到的，而此类的访问权限也是package的，并且是final的，意味着真的不能被扩展了，接下来的重点我们围绕<code>java.lang.ref.Finalizer</code>展开(PS：后续讲Finalizer相关的其实也就是在说FinalReference)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>final class Finalizer extends FinalReference { /* Package-private; must be in
</span><span class='line'>                                                  same package as the Reference
</span><span class='line'>                                                  class */
</span><span class='line'>
</span><span class='line'>    /* A native method that invokes an arbitrary object's finalize method is
</span><span class='line'>       required since the finalize method is protected
</span><span class='line'>     */
</span><span class='line'>    static native void invokeFinalizeMethod(Object o) throws Throwable;
</span><span class='line'>
</span><span class='line'>    private static ReferenceQueue queue = new ReferenceQueue();
</span><span class='line'>    private static Finalizer unfinalized = null;
</span><span class='line'>    private static final Object lock = new Object();
</span><span class='line'>
</span><span class='line'>    private Finalizer
</span><span class='line'>        next = null,
</span><span class='line'>        prev = null;
</span><span class='line'>        
</span><span class='line'>    private Finalizer(Object finalizee) {
</span><span class='line'>        super(finalizee, queue);
</span><span class='line'>        add();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /* Invoked by VM */
</span><span class='line'>    static void register(Object finalizee) {
</span><span class='line'>        new Finalizer(finalizee);
</span><span class='line'>    }  
</span><span class='line'>    
</span><span class='line'>    private void add() {
</span><span class='line'>        synchronized (lock) {
</span><span class='line'>            if (unfinalized != null) {
</span><span class='line'>                this.next = unfinalized;
</span><span class='line'>                unfinalized.prev = this;
</span><span class='line'>            }
</span><span class='line'>            unfinalized = this;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>      
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>   }    
</span></code></pre></td></tr></table></div></figure>


<h3>Finalizer的构造函数</h3>

<p>从构造函数上我们获得下面的几个关键信息
* private：意味着我们在外面无法自己构建这类对象
* finalizee参数：FinalReference指向的对象引用
* 调用add方法：将当前对象插入到Finalizer对象链里，链里的对象和Finalizer类静态相关联，言外之意是在这个链里的对象都无法被gc掉，除非将这种引用关系剥离掉（因为Finalizer类无法被unload）</p>

<p>虽然外面无法创建Finalizer对象，但是注意到有一个register的静态方法，在方法里会创建这种对象，同时将这个对象加入到Finalizer对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p>

<h2>Finalizer对象何时被注册到Finalizer对象链里</h2>

<p>类其实有挺多的修饰，比如final，abstract，public等等，如果一个类有final修饰，我们就说这个类是一个final类，上面列的都是语法层面我们可以显示标记的，在jvm里其实还给类标记其他一些符号，比如finalizer，表示这个类是一个finalizer类（为了和java.lang.ref.Fianlizer类进行区分，下文要提到的finalizer类的地方都说成f类），gc在处理这种类的对象的时候要做一些特殊的处理，如在这个对象被回收之前会调用一下它的finalize方法。</p>

<h3>如何判断一个类是不是一个f类</h3>

<p>在讲这个问题之前，我们先来看下<code>java.lang.Object</code>里的一个方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protected void finalize() throws Throwable { }</span></code></pre></td></tr></table></div></figure>


<p>在Object类里定义了一个名为finalize的空方法，这意味着Java世界里的所有类都会继承这个方法，甚至可以覆写该方法，并且根据方法覆写原则，如果子类覆盖此方法，方法访问权限都是至少是protected级别的，这样其子类就算没有覆写此方法也会继承此方法。</p>

<p>而判断当前类是否是一个f类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的名为finalize的方法，而另外一个要求是<code>finalize方法必须非空</code>，因此我们的Object类虽然含有一个finalize方法，但是并不是一个f类，Object的对象在被gc回收的时候其实并不会去调用它的finalize方法。</p>

<p>需要注意的是我们的类在被加载过程中其实就已经被标记为是否为f类了（遍历所有方法，包括父类的方法，只要有一个非空的参数为空返回void的finalize方法就认为是一个f类）。</p>

<h3>f类的对象何时传到Finalizer.register方法</h3>

<p>对象的创建其实是被拆分成多个步骤的，比如<code>A a=new A(2)</code>这样一条语句对应的字节码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0: new           #1                  // class A
</span><span class='line'>3: dup
</span><span class='line'>4: iconst_2
</span><span class='line'>5: invokespecial #11                 // Method "&lt;init&gt;":(I)V</span></code></pre></td></tr></table></div></figure>


<p>先执行new分配好对象空间，然后再执行invokespecial调用构造函数，jvm里其实可以让用户选择在这两个时机中的任意一个将当前对象传递给Finalizer.register方法来注册到Finalizer对象链里，这个选择依赖于RegisterFinalizersAtInit这个vm参数是否被设置，默认值为true，也就是在调用构造函数返回之前调用Finalizer.register方法，如果通过-XX:-RegisterFinalizersAtInit关闭了该参数，那将在对象空间分配好之后就将这个对象注册进去。</p>

<p>另外需要提一点的是当我们通过clone的方式复制一个对象的时候，如果当前类是一个f类，那么在clone完成的时候将调用Finalizer.register方法进行注册。</p>

<h3>hotspot如何实现f类对象在构造函数执行完毕后调用Finalizer.register</h3>

<p>这个实现比较有意思，在这里简单提一下，我们知道一个构造函数执行的时候，会去调用父类的构造函数，主要是为了能对继承自父类的属性也能做初始化，那么任何一个对象的初始化最终都会调用到Object的空构造函数里（任何空的构造函数其实并不空，会含有三条字节码指令，如下代码所示），为了不对所有的类的构造函数都做埋点调用Finalizer.register方法，hotspot的实现是在Object这个类在做初始化的时候将构造函数里的<code>return</code>指令替换为<code>_return_register_finalizer</code>指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令的时候调用Finalizer.register方法，这样就在侵入性很小的情况下完美地解决了这个问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0: aload_0
</span><span class='line'>1: invokespecial #21                 // Method java/lang/Object."&lt;init&gt;":()V
</span><span class='line'>4: return</span></code></pre></td></tr></table></div></figure>


<h2>f类对象的GC回收</h2>

<h3>FinalizerThread线程</h3>

<p>在Finalizer类的clinit方法（静态块）里我们看到它会创建了一个FinalizerThread的守护线程，这个线程的优先级并不是最高的，意味着在cpu很紧张的情况下其被调度的优先级可能会受到影响</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  private static class FinalizerThread extends Thread {
</span><span class='line'>        private volatile boolean running;
</span><span class='line'>        FinalizerThread(ThreadGroup g) {
</span><span class='line'>            super(g, "Finalizer");
</span><span class='line'>        }
</span><span class='line'>        public void run() {
</span><span class='line'>            if (running)
</span><span class='line'>                return;
</span><span class='line'>            running = true;
</span><span class='line'>            for (;;) {
</span><span class='line'>                try {
</span><span class='line'>                    Finalizer f = (Finalizer)queue.remove();
</span><span class='line'>                    f.runFinalizer();
</span><span class='line'>                } catch (InterruptedException x) {
</span><span class='line'>                    continue;
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    static {
</span><span class='line'>        ThreadGroup tg = Thread.currentThread().getThreadGroup();
</span><span class='line'>        for (ThreadGroup tgn = tg;
</span><span class='line'>             tgn != null;
</span><span class='line'>             tg = tgn, tgn = tg.getParent());
</span><span class='line'>        Thread finalizer = new FinalizerThread(tg);
</span><span class='line'>        finalizer.setPriority(Thread.MAX_PRIORITY - 2);
</span><span class='line'>        finalizer.setDaemon(true);
</span><span class='line'>        finalizer.start();
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>这个线程主要就是从queue里取Finalizer对象，然后执行该对象的runFinalizer方法，这个方法主要是将Finalizer对象从Finalizer对象链里剥离出来，这样意味着下次gc发生的时候就可能将其关联的f对象gc掉了，最后将这个Finalizer对象关联的f对象传给了一个native方法invokeFinalizeMethod</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void runFinalizer() {
</span><span class='line'>        synchronized (this) {
</span><span class='line'>            if (hasBeenFinalized()) return;
</span><span class='line'>            remove();
</span><span class='line'>        }
</span><span class='line'>        try {
</span><span class='line'>            Object finalizee = this.get();
</span><span class='line'>            if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {
</span><span class='line'>                invokeFinalizeMethod(finalizee);
</span><span class='line'>                /* Clear stack slot containing this variable, to decrease
</span><span class='line'>                   the chances of false retention with a conservative GC */
</span><span class='line'>                finalizee = null;
</span><span class='line'>            }
</span><span class='line'>        } catch (Throwable x) { }
</span><span class='line'>        super.clear();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'> static native void invokeFinalizeMethod(Object o) throws Throwable;
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p>其实invokeFinalizeMethod方法就是调了这个f对象的finalize方法，看到这里大家应该恍然大悟了，整个过程都串起来了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JNIEXPORT void JNICALL
</span><span class='line'>Java_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,
</span><span class='line'>                                                  jobject ob)
</span><span class='line'>{
</span><span class='line'>    jclass cls;
</span><span class='line'>    jmethodID mid;
</span><span class='line'>
</span><span class='line'>    cls = (*env)-&gt;GetObjectClass(env, ob);
</span><span class='line'>    if (cls == NULL) return;
</span><span class='line'>    mid = (*env)-&gt;GetMethodID(env, cls, "finalize", "()V");
</span><span class='line'>    if (mid == NULL) return;
</span><span class='line'>    (*env)-&gt;CallVoidMethod(env, ob, mid);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>f对象的finalize方法抛出异常会导致FinalizeThread退出吗</h3>

<p>不知道大家有没有想过如果f对象的finalize方法抛了一个没捕获的异常，这个FinalizerThread会不会退出呢，细心的读者看上面的代码其实就可以找到答案，在runFinalizer方法里对Throwable的异常都进行了捕获，因此不可能出现FinalizerThread因异常未捕获而退出的情况。</p>

<h3>f对象的finalize方法会执行多次吗</h3>

<p>如果我们在f对象的finalize方法里重新将当前对象赋值出去，变成可达对象，当这个f对象再次变成不可达的时候还会被执行finalize方法吗？答案是否定的，因为在执行完第一次finalize方法之后，这个f对象已经和之前的Finalizer对象关系剥离了，也就是下次gc的时候不会再发现Finalizer对象指向该f对象了，自然也就不会调用这个f对象的finalize方法了。</p>

<h3>Finalizer对象何时被放到ReferenceQueue里</h3>

<p>除了这里要说的环节之外，整个过程大家应该都比较清楚了。</p>

<p>当gc发生的时候，gc算法会判断f类对象是不是只被Finalizer类引用（f类对象被Finalizer对象引用，然后放到Finalizer对象链里），如果这个类仅仅被Finalizer对象引用的时候，说明这个对象在不久的将来会被回收了现在可以执行它的finalize方法了，于是会将这个Finalizer对象放到Finalizer类的ReferenceQueue里，但是这个f类对象其实并没有被回收，因为Finalizer这个类还对他们持有引用，在gc完成之前，jvm会调用ReferenceQueue里的lock对象的notify方法（当ReferenceQueue为空的时候，FinalizerThread线程会调用ReferenceQueue的lock对象的wait方法直到被jvm唤醒），此时就会执行上面FinalizeThread线程里看到的其他逻辑了。</p>

<h2>Finalizer导致的内存泄露</h2>

<p>这里举一个简单的例子，我们使用挺广的socket通信，SocksSocketImpl的父类其实就实现了finalize方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Cleans up if the user forgets to close it.
</span><span class='line'> */
</span><span class='line'>protected void finalize() throws IOException {
</span><span class='line'>      close();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其实这么做的主要目的是万一用户忘记关闭socket了，那么在这个对象被回收的时候能主动关闭socket来释放一些系统资源，但是如果真的是用户忘记关闭了，那这些socket对象可能因为FinalizeThread迟迟没有执行到这些socket对象的finalize方法，而导致内存泄露，这种问题我们碰到过多次，因此对于这类情况除了大家好好注意貌似没有什么更好的方法了，该做的事真不能省.</p>

<h2>Finalizer的客观评价</h2>

<p>上面的过程基本对Finalizer的实现细节进行完整剖析了，java里我们看到有构造函数，但是并没有看到析构函数一说，Finalizer其实是实现了析构函数的概念，我们在对象被回收前可以执行一些『收拾性』的逻辑，应该说是一个特殊场景的补充，但是这种概念的实现给我们的f对象生命周期以及gc等带来了一些影响：
* f对象因为Finalizer的引用而变成了一个临时的强引用，即使没有其他的强引用了，还是无法立即被回收
* f对象至少经历两次GC才能被回收，因为只有在FinalizerThread执行完了f对象的finalize方法的情况下才有可能被下次gc回收，而有可能期间已经经历过多次gc了，但是一直还没执行f对象的finalize方法
* cpu资源比较稀缺的情况下FinalizerThread线程有可能因为优先级比较低而延迟执行f对象的finalize方法
* 因为f对象的finalize方法迟迟没有执行，有可能会导致大部分f对象进入到old分代，此时容易引发old分代的gc，甚至fullgc，gc暂停时间明显变长
* f对象的finalize方法被调用了，但是这个对象其实还并没有被回收，虽然可能在不久的将来会被回收</p>

      
      
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-05-12T13:49:57+08:00" pubdate data-updated="true">May 12<span>th</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/05/12/direct-buffer/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/05/12/direct-buffer/">JVM源码分析之堆外内存完全解读</a></h1>
      <h2>概述</h2>

<h3>广义的堆外内存</h3>

<p>说到堆外内存，那大家肯定想到堆内内存，这也是我们大家接触最多的，我们在jvm参数里通常设置-Xmx来指定我们的堆的最大值，不过这还不是我们理解的Java堆，-Xmx的值是新生代和老生代的和的最大值，我们在jvm参数里通常还会加一个参数-XX:MaxPermSize来指定持久代的最大值，那么我们认识的Java堆的最大值其实是-Xmx和-XX:MaxPermSize的总和，在分代算法下，新生代，老生代和持久代是连续的虚拟地址，因为它们是一起分配的，那么剩下的都可以认为是堆外内存(广义的)了，这些包括了jvm本身在运行过程中分配的内存，codecache，jni里分配的内存，DirectByteBuffer分配的内存等等</p>

<h3>狭义的堆外内存</h3>

<p>而作为java开发者，我们常说的堆外内存溢出了，其实是狭义的堆外内存，这个主要是指java.nio.DirectByteBuffer在创建的时候分配内存，我们这篇文章里也主要是讲狭义的堆外内存，因为它和我们平时碰到的问题比较密切</p>


      
       <a href="/blog/2015/05/12/direct-buffer/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2015-05-07T20:02:51+08:00" pubdate data-updated="true">May 7<span>th</span>, 2015</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2015/05/07/system-gc/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          <a href="/blog/categories/systemgc/"><span class="badge">SystemGC</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2015/05/07/system-gc/">JVM源码分析之SystemGC完全解读</a></h1>
      <h2>概述</h2>

<p>JVM的GC一般情况下是JVM本身根据一定的条件触发的，不过我们还是可以做一些人为的触发，比如通过jvmti做强制GC，通过System.gc触发，还可以通过jmap来触发等，针对每个场景其实我们都可以写篇文章来做一个介绍，本文重点介绍下System.gc的原理</p>


      
       <a href="/blog/2015/05/07/system-gc/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-07-24T14:10:26+08:00" pubdate data-updated="true">Jul 24<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/07/24/jvm-thread-dump-bug/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          <a href="/blog/categories/thread/"><span class="badge">Thread</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/07/24/jvm-thread-dump-bug/">JVM Bug:多个线程持有一把锁?</a></h1>
      <p><code>注:文章首发于InfoQ，</code><a href="http://www.infoq.com/cn/articles/jvm-bug-thread">http://www.infoq.com/cn/articles/jvm-bug-thread</a></p>

<h2>JVM线程dump Bug描述</h2>

<p>&#8195;&#8195;在JAVA语言中，当同步块(<code>Synchronized</code>)被多个线程并发访问时，JVM中会采用基于互斥实现的重量级锁。JVM最多只允许一个线程持有这把锁，如果其它线程想要获得这把锁就必须处于等待状态，也就是说在同步块被并发访问时，最多只会有一个处于<code>RUNNABLE</code>状态的线程持有某把锁，而另外的线程因为竞争不到这把锁而都处于<code>BLOCKED</code>状态。然而有些时候我们会发现处于<code>BLOCKED</code>状态的线程，它的最上面那一帧在打印其正在等待的锁对象时，居然也会出现-locked的信息，这个信息和持有该锁的线程打印出来的结果是一样的(请看下图)，但是对比其他<code>BLOCKED</code>态的线程却并没有都出现这种情况。当我们再次dump线程时又可能出现不一样的结果。测试表明这可能是一个偶发的情况，本文就是针对这种情况对JVM内部的实现做了一个研究以寻找其根源。</p>


      
       <a href="/blog/2014/07/24/jvm-thread-dump-bug/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-07-19T09:58:49+08:00" pubdate data-updated="true">Jul 19<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/07/19/java-debug-log/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/debug/"><span class="badge">DEBUG</span></a>
          
          <a href="/blog/categories/jdwp/"><span class="badge">JDWP</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/07/19/java-debug-log/">从日志上理解JAVA调试机制</a></h1>
      <p>&#8195;&#8195;JAVA调试我想大家都玩过，或许因为非常完美地集成到了我们日常的IDE里，比如eclipse，netbeans，可是大家有没有想过它是怎么实现的呢，接下来我会从vm中打印的调试日志来跟大家认识下这个调试体系。</p>


      
       <a href="/blog/2014/07/19/java-debug-log/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-07-08T16:39:46+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/07/08/jdk-sql-deadlock/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/classloader/"><span class="badge">ClassLoader</span></a>
          
          <a href="/blog/categories/deadlock/"><span class="badge">DeadLock</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/07/08/jdk-sql-deadlock/">JDK的sql设计不合理导致的驱动类初始化死锁问题</a></h1>
      <h2>问题描述</h2>

<p>&#8195;&#8195;当我们一个系统既需要mysql驱动，也需要oracle驱动的时候，在并发加载初始化这些驱动类的过程中产生死锁的可能性非常大，下面是一个模拟的例子，对于Thread2的实现其实是jdk里java.sql.DriverService的逻辑，也是我们第一次调用java.sql.DriverManager.registerDriver注册一个驱动实例要走的逻辑(jdk1.6下)，不过这篇文章是使用我们生产环境的一个系统的线程dump和内存dump为基础进行分析展开的。</p>


      
       <a href="/blog/2014/07/08/jdk-sql-deadlock/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-06-28T11:33:07+08:00" pubdate data-updated="true">Jun 28<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/06/28/hsdb-string/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/hsdb/"><span class="badge">HSDB</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/06/28/hsdb-string/">通过HSDB来了解String值的真身在哪里</a></h1>
      <p>&#8195;&#8195;最近通过<code>@RednaxelaFX</code>的一篇文章得知了HSDB，并好好研究了一下用法，对学习jvm的人来说绝对是一个利器，可以摆脱GDB，直接图形化看内存结构布局，具体的用法我就不多说了，这篇<a href="http://rednaxelafx.iteye.com/blog/1847971">文章</a>介绍得很详细了，这次写文章主要是想通过这一利器来分析下String的值在java里的内存情况，不同场景下的String的值到底是在内存里的哪块区域，这里强调的是值，并不是对象，因为对象我们都知道是存在heap里的，我们看java.lang.String的源码会看到有一个value数组，这里才是真正的值，本文顺带也是hsdb用法的一个介绍，如此利器希望给大家带来不一样的乐趣。</p>


      
       <a href="/blog/2014/06/28/hsdb-string/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-06-18T19:15:52+08:00" pubdate data-updated="true">Jun 18<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/06/18/jvm-attach/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/attach/"><span class="badge">Attach</span></a>
          
          <a href="/blog/categories/jvm/"><span class="badge">JVM</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/06/18/jvm-attach/">JVM Attach机制实现</a></h1>
      <h2>Attach是什么</h2>

<p>   &#8195;&#8195;在讲这个之前，我们先来点大家都知道的东西，当我们感觉线程一直卡在某个地方，想知道卡在哪里，首先想到的是进行线程dump，而常用的命令是jstack <pid>，我们就可以看到如下线程栈了</p>


      
       <a href="/blog/2014/06/18/jvm-attach/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-05-20T19:31:28+08:00" pubdate data-updated="true">May 20<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/05/20/tcp-broken-pipe/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/tcp/"><span class="badge">TCP</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/05/20/tcp-broken-pipe/">从tcp原理角度理解Broken pipe和Connection reset by peer的区别</a></h1>
      <p>&#8195;&#8195;以前我们经常会碰到<code>Broken pipe</code>或者<code>Connection reset by peer</code>之类的异常，但是tcp实现里什么情况下会抛出这些异常呢，以前我给对方的回答都是模棱两可的，自己说实话都没把握，因为自己也没有验证过，对它们的认识都是从网上看来的，正确与否也不知道，昨天独明突然又问到这个问题，前段时间正好对tcp这块研究了一段时间，有了点理论知识之后再从实践角度对此问题进行一下分析，下面对我这次的调研过程进行下描述与大家分享，希望大家以后对此类问题都能很自信地应答。</p>

<h2>三次握手和四次挥手过程</h2>

<p>&#8195;&#8195;在讲具体的原因之前，我们有必要补充下tcp这块的一些基础知识，我们都知道tcp通信有三次握手和四次挥手，网上介绍的文章也一大堆，图我也懒得画了，直接网上找一个图给大家</p>


      
       <a href="/blog/2014/05/20/tcp-broken-pipe/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
    <hr>
    
  
  
    <article>
      

  <div class="row-fluid">
    <div class="span2 post-meta">
	  <h5 class="date-time">








  


<i class="icon-calendar-empty"></i> <time datetime="2014-05-04T10:43:57+08:00" pubdate data-updated="true">May 4<span>th</span>, 2014</time></h5>
          <div class="row-fluid">
          
           <a href="/blog/2014/05/04/pcduino-web-site/#comments"]]>Comments </a><span class="fui-bubble-16"></span>         
          
          </div>
          
          <div class="row-fluid">
          
          <a href="/blog/categories/pcduino/"><span class="badge">PCDUINO</span></a>
          
          <a href="/blog/categories/web/"><span class="badge">WEB</span></a>
          
          </div>
          
    </div>
    <div class="span10 post-container">
      <h1 class="link"><a href="/blog/2014/05/04/pcduino-web-site/">pcduino搭建web站点IP映射解决方案</a></h1>
      <p>&#8195;&#8195;在pcduino上搭建站点，有两个问题首先需要解决</p>

<ul>
<li> 域名绑定</li>
<li> 端口映射</li>
</ul>


<p>&#8195;&#8195;如果你的pcduino连的路由器的IP已经是公网IP，按照如下步骤查看</p>

<ul>
<li> 打开路由器管理页面，比如<code>192.168.1.1</code>，查看运行状态里WAN显示的IP地址</li>
<li> 打开<code>www.ip138.com</code>，上面会显示你的公网IP</li>
<li> 如果以上两者相等，说明你的路由器就是直接连的公网，否则外面可能还有一层或者几层路由器，这个就比较麻烦了，你必须要有操作他们的权限才能继续往下走</li>
</ul>



      
       <a href="/blog/2014/05/04/pcduino-web-site/">Read on &rarr;</a> 
    </div>
  </div>



    </article>
    
  
  <div class="pagination">
    
    <a class="prev" href="/blog/page/2/">&larr; Older</a>
    

    
  </div>
</div>


        </div>
      </div>
      <div class="row-fluid">
        <footer class="footer-page" role="contentinfo">
          <p>
  Copyright &copy; 2015 - 你假笨 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> - Theme by <a href="http://alexgaribay.com">Alex Garibay</a>
</p>


        </footer>
      </div>
  </div>
  





  <script type="text/javascript">
//    (function() {
 //     var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
   //   script.src = 'https://apis.google.com/js/plusone.js';
    //  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
   // })();
  </script>







</body>
</html>
